<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yp_ren Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yapengren.github.io/"/>
  <updated>2019-08-14T09:22:49.471Z</updated>
  <id>https://yapengren.github.io/</id>
  
  <author>
    <name>renyapeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis 知识点</title>
    <link href="https://yapengren.github.io/wiki/Mybatis-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Mybatis-知识点/</id>
    <published>2019-08-14T09:20:15.000Z</published>
    <updated>2019-08-14T09:22:49.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MyBatis-中-resultType-和-resultMap-的区别"><a href="#MyBatis-中-resultType-和-resultMap-的区别" class="headerlink" title="MyBatis 中 resultType 和 resultMap 的区别"></a><a href="https://www.cnblogs.com/coder-lzh/p/8960928.html" target="_blank" rel="noopener">MyBatis 中 resultType 和 resultMap 的区别</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MyBatis-中-resultType-和-resultMap-的区别&quot;&gt;&lt;a href=&quot;#MyBatis-中-resultType-和-resultMap-的区别&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 中 resultType
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Mybatis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Mybatis/"/>
    
    
      <category term="mybatis" scheme="https://yapengren.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说说</title>
    <link href="https://yapengren.github.io/wiki/synchronized-%E5%92%8C-lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%94%A8%E6%96%B0%E7%9A%84lock%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E8%AF%B4/"/>
    <id>https://yapengren.github.io/wiki/synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说说/</id>
    <published>2019-08-04T06:32:36.000Z</published>
    <updated>2019-08-04T06:47:41.012Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原始构成"><a href="#原始构成" class="headerlink" title="原始构成"></a>原始构成</h3><ul><li><p>synchronized 是关键字，属于JVM层面</p><ul><li><p>monitorenter（底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象只有在同步块或者方法中才能调用 wait/notify 等方法）</p></li><li><p>monitorexit</p></li></ul></li><li><p>Lock 是具体类（java.util.concurrent.locks.lock）是api层面的锁</p></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li><p>synchronized 不需要用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。</p></li><li><p>ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象。需要 lock() 和unlock() 方法配合 try/finally 语句块来完成。</p></li></ul><h3 id="等待是否可中断"><a href="#等待是否可中断" class="headerlink" title="等待是否可中断"></a>等待是否可中断</h3><ul><li><p>synchronized 不可中断，除非抛出异常或者正常运行完成。</p></li><li><p>ReentrantLock可中断</p><ul><li>1.设置超时方法 tryLock(long timeout,TimeUnit unit)</li><li>2.lockInterruptibly()放代码块中，调用interrupt()方法可中断</li></ul></li></ul><h3 id="加锁是否公平"><a href="#加锁是否公平" class="headerlink" title="加锁是否公平"></a>加锁是否公平</h3><ul><li><p>synchronized 非公平锁</p></li><li><p>ReentrantLock 两者都可以，默认非公平锁，构造方法可以传入 boolean 值，true为公平锁，false为非公平锁</p></li></ul><h3 id="锁绑定多个条件-Condition"><a href="#锁绑定多个条件-Condition" class="headerlink" title="锁绑定多个条件 Condition"></a>锁绑定多个条件 Condition</h3><ul><li>synchronized 没有</li></ul><ul><li>ReentrantLock 用来实现分组唤醒需要唤醒的线程，可以<strong>精确唤醒</strong>，而不是像 synchronized 要么随机唤醒一个要么唤醒全部线程。</li></ul><h3 id="举例：锁绑定多个条件-Condition"><a href="#举例：锁绑定多个条件-Condition" class="headerlink" title="举例：锁绑定多个条件 Condition"></a>举例：锁绑定多个条件 Condition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * A打印5次，B打印10次，C打印15次</span></span><br><span class="line"><span class="comment"> * 紧接着</span></span><br><span class="line"><span class="comment"> * A打印5次，B打印10次，C打印15次</span></span><br><span class="line"><span class="comment"> * 打印10轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockdemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原始构成&quot;&gt;&lt;a href=&quot;#原始构成&quot; class=&quot;headerlink&quot; title=&quot;原始构成&quot;&gt;&lt;/a&gt;原始构成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;synchronized 是关键字，属于JVM层面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;monitorente
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="https://yapengren.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java hash 原理</title>
    <link href="https://yapengren.github.io/wiki/java-hash-%E5%8E%9F%E7%90%86/"/>
    <id>https://yapengren.github.io/wiki/java-hash-原理/</id>
    <published>2019-08-04T05:23:50.000Z</published>
    <updated>2019-08-04T05:24:25.244Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5nkvcllvaj318c0mqt9z.jpg" alt="88FE31C1-3E38-4DC9-A207-96016AA72F1F"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5nkvcllvaj318c0mqt9z.jpg&quot; alt=&quot;88FE31C1-3E38-4DC9-A207-96016AA72F1F&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>让我们同步进阶</title>
    <link href="https://yapengren.github.io/wiki/%E8%AE%A9%E6%88%91%E4%BB%AC%E5%90%8C%E6%AD%A5%E8%BF%9B%E9%98%B6/"/>
    <id>https://yapengren.github.io/wiki/让我们同步进阶/</id>
    <published>2019-08-04T05:18:18.000Z</published>
    <updated>2019-08-06T07:51:19.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h3><p><a href="http://cmsblogs.com/" target="_blank" rel="noopener">Java技术驿站</a></p><p><a href="https://cyc2018.github.io/CS-Notes/" target="_blank" rel="noopener">CS-Notes</a></p><p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></p><h3 id="架构知识点"><a href="#架构知识点" class="headerlink" title="架构知识点"></a>架构知识点</h3><p><a href="https://doocs.github.io/advanced-java" target="_blank" rel="noopener">互联网 java 工程师进阶知识完全扫盲</a></p><h3 id="spring-boot-amp-cloud"><a href="#spring-boot-amp-cloud" class="headerlink" title="spring boot &amp; cloud"></a>spring boot &amp; cloud</h3><p><a href="http://blog.didispace.com/spring-cloud-learning/" target="_blank" rel="noopener">Spring Cloud 程序猿DD</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识点&quot;&gt;&lt;a href=&quot;#基础知识点&quot; class=&quot;headerlink&quot; title=&quot;基础知识点&quot;&gt;&lt;/a&gt;基础知识点&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://cmsblogs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis 知识点</title>
    <link href="https://yapengren.github.io/wiki/redis-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/redis-知识点/</id>
    <published>2019-08-04T05:12:21.000Z</published>
    <updated>2019-08-04T05:15:47.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis用过哪些数据数据，以及Redis底层怎么实现"><a href="#Redis用过哪些数据数据，以及Redis底层怎么实现" class="headerlink" title="Redis用过哪些数据数据，以及Redis底层怎么实现"></a>Redis用过哪些数据数据，以及Redis底层怎么实现</h3><p>string, hash, list, set, zset</p><h3 id="Redis缓存穿透，缓存雪崩"><a href="#Redis缓存穿透，缓存雪崩" class="headerlink" title="Redis缓存穿透，缓存雪崩"></a><a href="https://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">Redis缓存穿透，缓存雪崩</a></h3><h3 id="如何使用Redis来实现分布式锁"><a href="#如何使用Redis来实现分布式锁" class="headerlink" title="如何使用Redis来实现分布式锁"></a><a href="https://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">如何使用Redis来实现分布式锁</a></h3><h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决"></a><a href="https://blog.csdn.net/hjm4702192/article/details/80518856" target="_blank" rel="noopener">Redis的并发竞争问题如何解决</a></h3><h3 id="Redis持久化的几种方式，优缺点是什么，怎么实现的"><a href="#Redis持久化的几种方式，优缺点是什么，怎么实现的" class="headerlink" title="Redis持久化的几种方式，优缺点是什么，怎么实现的"></a><a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">Redis持久化的几种方式，优缺点是什么，怎么实现的</a></h3><h3 id="aof-文件太大会怎么样"><a href="#aof-文件太大会怎么样" class="headerlink" title="aof 文件太大会怎么样"></a><a href="https://www.cnblogs.com/xingzc/p/6384677.html" target="_blank" rel="noopener">aof 文件太大会怎么样</a></h3><h3 id="Redis的缓存失效策略-amp-最大缓存策略"><a href="#Redis的缓存失效策略-amp-最大缓存策略" class="headerlink" title="Redis的缓存失效策略 &amp; 最大缓存策略"></a><a href="https://www.cnblogs.com/moonandstar08/p/5686498.html" target="_blank" rel="noopener">Redis的缓存失效策略 &amp; 最大缓存策略</a></h3><h3 id="Redis集群，高可用，原理"><a href="#Redis集群，高可用，原理" class="headerlink" title="Redis集群，高可用，原理"></a>Redis集群，高可用，原理</h3><h3 id="Redis缓存分片"><a href="#Redis缓存分片" class="headerlink" title="Redis缓存分片"></a><a href="https://www.cnblogs.com/shiw27/p/8360485.html" target="_blank" rel="noopener">Redis缓存分片</a></h3><h3 id="Redis的数据淘汰策略"><a href="#Redis的数据淘汰策略" class="headerlink" title="Redis的数据淘汰策略"></a><a href="https://blog.csdn.net/yangtuogege/article/details/77970896" target="_blank" rel="noopener">Redis的数据淘汰策略</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis用过哪些数据数据，以及Redis底层怎么实现&quot;&gt;&lt;a href=&quot;#Redis用过哪些数据数据，以及Redis底层怎么实现&quot; class=&quot;headerlink&quot; title=&quot;Redis用过哪些数据数据，以及Redis底层怎么实现&quot;&gt;&lt;/a&gt;Redis
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/redis/"/>
    
    
      <category term="redis" scheme="https://yapengren.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring 知识点</title>
    <link href="https://yapengren.github.io/wiki/Spring-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Spring-知识点/</id>
    <published>2019-08-04T05:01:51.000Z</published>
    <updated>2019-08-04T05:05:38.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BeanFactory-和-FactoryBean？"><a href="#BeanFactory-和-FactoryBean？" class="headerlink" title="BeanFactory 和 FactoryBean？"></a><a href="https://blog.csdn.net/qiesheng/article/details/72875315" target="_blank" rel="noopener">BeanFactory 和 FactoryBean？</a></h3><h3 id="Spring-IOC-的理解，其初始化过程？"><a href="#Spring-IOC-的理解，其初始化过程？" class="headerlink" title="Spring IOC 的理解，其初始化过程？"></a><a href="https://www.cnblogs.com/chenjunjie12321/p/6124649.html" target="_blank" rel="noopener">Spring IOC 的理解，其初始化过程？</a></h3><h3 id="BeanFactory-和-ApplicationContext？"><a href="#BeanFactory-和-ApplicationContext？" class="headerlink" title="BeanFactory 和 ApplicationContext？"></a><a href="https://blog.csdn.net/qq_32651225/article/details/78323527" target="_blank" rel="noopener">BeanFactory 和 ApplicationContext？</a></h3><h3 id="Spring-Bean-的生命周期，如何被管理的？"><a href="#Spring-Bean-的生命周期，如何被管理的？" class="headerlink" title="Spring Bean 的生命周期，如何被管理的？"></a><a href="https://www.cnblogs.com/kenshinobiy/p/4652008.html" target="_blank" rel="noopener">Spring Bean 的生命周期，如何被管理的？</a></h3><h3 id="Spring-Bean-的加载过程是怎样的？"><a href="#Spring-Bean-的加载过程是怎样的？" class="headerlink" title="Spring Bean 的加载过程是怎样的？"></a><a href="https://www.cnblogs.com/xrq730/p/6285358.html" target="_blank" rel="noopener">Spring Bean 的加载过程是怎样的？</a></h3><h3 id="如果要你实现Spring-AOP，请问怎么实现？"><a href="#如果要你实现Spring-AOP，请问怎么实现？" class="headerlink" title="如果要你实现Spring AOP，请问怎么实现？"></a>如果要你实现Spring AOP，请问怎么实现？</h3><h3 id="如果要你实现Spring-IOC，你会注意哪些问题？"><a href="#如果要你实现Spring-IOC，你会注意哪些问题？" class="headerlink" title="如果要你实现Spring IOC，你会注意哪些问题？"></a>如果要你实现Spring IOC，你会注意哪些问题？</h3><h3 id="Spring-是如何管理事务的，事务管理机制？"><a href="#Spring-是如何管理事务的，事务管理机制？" class="headerlink" title="Spring 是如何管理事务的，事务管理机制？"></a><a href="https://www.cnblogs.com/dongfangshenhua/p/6949521.html" target="_blank" rel="noopener">Spring 是如何管理事务的，事务管理机制？</a></h3><h3 id="Spring-的不同事务传播行为有哪些，干什么用的？"><a href="#Spring-的不同事务传播行为有哪些，干什么用的？" class="headerlink" title="Spring 的不同事务传播行为有哪些，干什么用的？"></a><a href="https://www.cnblogs.com/dongfangshenhua/p/6949521.html" target="_blank" rel="noopener">Spring 的不同事务传播行为有哪些，干什么用的？</a></h3><h3 id="Spring-中用到了那些设计模式？"><a href="#Spring-中用到了那些设计模式？" class="headerlink" title="Spring 中用到了那些设计模式？"></a><a href="https://www.cnblogs.com/baizhanshi/p/6187537.html" target="_blank" rel="noopener">Spring 中用到了那些设计模式？</a></h3><h3 id="Spring-MVC-的工作原理？"><a href="#Spring-MVC-的工作原理？" class="headerlink" title="Spring MVC 的工作原理？"></a><a href="https://www.cnblogs.com/xiaoxi/p/6164383.html" target="_blank" rel="noopener">Spring MVC 的工作原理？</a></h3><h3 id="Spring-循环注入的原理？"><a href="#Spring-循环注入的原理？" class="headerlink" title="Spring 循环注入的原理？"></a>Spring 循环注入的原理？</h3><h3 id="Spring-AOP的理解，各个术语，他们是怎么相互工作的？"><a href="#Spring-AOP的理解，各个术语，他们是怎么相互工作的？" class="headerlink" title="Spring AOP的理解，各个术语，他们是怎么相互工作的？"></a><a href="https://www.jianshu.com/p/5015f212e4e4" target="_blank" rel="noopener">Spring AOP的理解，各个术语，他们是怎么相互工作的？</a></h3><h3 id="Spring-如何保证-Controller-并发的安全？"><a href="#Spring-如何保证-Controller-并发的安全？" class="headerlink" title="Spring 如何保证 Controller 并发的安全？"></a><a href="https://www.cnblogs.com/tiancai/p/9627109.html" target="_blank" rel="noopener">Spring 如何保证 Controller 并发的安全？</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BeanFactory-和-FactoryBean？&quot;&gt;&lt;a href=&quot;#BeanFactory-和-FactoryBean？&quot; class=&quot;headerlink&quot; title=&quot;BeanFactory 和 FactoryBean？&quot;&gt;&lt;/a&gt;&lt;a href=
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS 流程图</title>
    <link href="https://yapengren.github.io/wiki/FastDFS-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/FastDFS-流程图/</id>
    <published>2019-08-04T03:34:10.000Z</published>
    <updated>2019-08-04T03:42:02.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastDFS-执行流程"><a href="#FastDFS-执行流程" class="headerlink" title="FastDFS 执行流程"></a>FastDFS 执行流程</h3><p>FastDFS 服务端有三个角色：跟踪服务器（Tracker Server）、存储服务器（Storage Server）和客户端（Client）。 </p><ul><li><p>Tracker Server：跟踪服务器，主要做调度工作，起负载均衡的作用。在内存记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽。相比 GFS 中的 Master 更为精简，不记录文件索引信息，占用的内存量很少。 </p></li><li><p>Storage Server：存储服务器（又称存储节点或数据服务器），文件和文件属性（Meta Data）都保存到存储服务器上。Storage Server 直接利用 OS 的文件系统调用管理文件。 </p></li><li><p>Client：客户端，作为业务请求的发起方，通过专有接口，使用 TCP/IP 协议与跟踪器服务器或存储节点进行数据交互。FastDFS 向使用者提供基本文件访问接口，如 upload、download、append、delete 等，以客户端库的方式提供给用户使用。 </p></li></ul><p>通过一张图来看一下 FastDFS 的运行机制： </p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5nhqjznlqj30ie0gdjw7.jpg" alt="9F8CC1B1-7DF4-42E5-A387-2FA00924B117"></p><p>Tracker 相当于 FastDFS 的大脑，不论是上传还是下载都是通过 Tracker 来分配资源；客户端一般可以使用 Ngnix 等静态服务器来调用或者做一部分的缓存；存储服务器内部分为卷（或者叫做组），卷与卷之间是平行的关系，可以根据资源的使用情况随时增加，卷内服务器文件相互同步备份，以达到容灾的目的。</p><h3 id="上传机制"><a href="#上传机制" class="headerlink" title="上传机制"></a>上传机制</h3><p>首先客户端请求 Tracker 服务获取到存储服务器的 IP 地址和端口，然后客户端根据返回的 IP 地址和端口号请求上传文件，存储服务器接收到请求后生产文件，并且将文件内容写入磁盘并返回给客户端 file_id、路径信息、文件名等信息，客户端保存相关信息上传完毕。 </p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5nhr79buzj30p10d6wfu.jpg" alt="1"></p><h3 id="下载机制"><a href="#下载机制" class="headerlink" title="下载机制"></a>下载机制</h3><p>客户端带上文件名信息请求 Tracker 服务获取到存储服务器的 IP 地址和端口，然后客户端根据返回的 IP 地址和端口号请求下载文件，存储服务器接收到请求后返回文件给客户端。 </p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5nhriqa0dj30om0bdjtg.jpg" alt="6542D65C-57D6-4B08-A3D5-CA1578F3091D"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastDFS-执行流程&quot;&gt;&lt;a href=&quot;#FastDFS-执行流程&quot; class=&quot;headerlink&quot; title=&quot;FastDFS 执行流程&quot;&gt;&lt;/a&gt;FastDFS 执行流程&lt;/h3&gt;&lt;p&gt;FastDFS 服务端有三个角色：跟踪服务器（Tracker
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="文件存储" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="FastDFS" scheme="https://yapengren.github.io/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>springMVC 流程图</title>
    <link href="https://yapengren.github.io/wiki/springMVC-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/springMVC-流程图/</id>
    <published>2019-08-04T03:30:24.000Z</published>
    <updated>2019-08-04T07:55:50.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5nhlgldvpj30ha0asdgj.jpg" alt="1"></p><h3 id="springMVC执行流程"><a href="#springMVC执行流程" class="headerlink" title="springMVC执行流程"></a>springMVC执行流程</h3><ol><li><p>用户发送请求至前端控制器 <code>DispatcherServlet</code></p></li><li><p>前端控制器 <code>DispatcherServlet</code> 收到请求调用处理器映射器``HandlerMapping`。 </p></li><li><p>处理器映射器 <code>HandlerMapping</code> 根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器一并返回给前端控制器``DispatcherServlet`。 </p></li><li><p>前端控制器 <code>DispatcherServlet</code> 通过处理器适配器 <code>HandlerAdapter</code> 调用处理器 </p></li><li><p>执行处理器，执行业务逻辑(Controller，也叫后端控制器)。 </p></li><li><p><code>Controller</code> 执行完成返回 <code>ModelAndView</code> </p></li><li><p>处理器适配器 <code>HandlerAdapter</code> 将 controller 执行结果 <code>ModelAndView</code> 返回给前端控制器 <code>DispatcherServlet</code> </p></li><li><p>前端控制器 <code>DispatcherServlet</code> 将 <code>ModelAndView</code> 传给视图解析器  <code>ViewResolver</code> </p></li><li><p>视图解析器 <code>ViewResolver</code> 解析后返回具体 View </p></li><li><p><code>DispatcherServlet</code> 对 View 进行渲染视图（即将模型数据填充至视图中）。 </p></li><li><p><code>DispatcherServlet</code> 响应用户 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5nhlgldvpj30ha0asdgj.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;springMVC执行流程&quot;&gt;&lt;a href=&quot;#springMVC执行流程&quot; 
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>shiro 流程图</title>
    <link href="https://yapengren.github.io/wiki/shiro-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/shiro-流程图/</id>
    <published>2019-08-04T03:28:49.000Z</published>
    <updated>2019-08-04T03:29:39.636Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5nhjbbi30j30se0g1glz.jpg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5nhjbbi30j30se0g1glz.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="权限认证" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="shiro" scheme="https://yapengren.github.io/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis 架构图</title>
    <link href="https://yapengren.github.io/wiki/Mybatis-%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/Mybatis-架构图/</id>
    <published>2019-08-04T03:21:42.000Z</published>
    <updated>2019-08-04T03:27:50.671Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5nheb2f59j30lu0k6754.jpg" alt="1"></p><ol><li>mybatis配置    </li></ol><p><code>SqlMapConfig.xml</code>，此文件作为 mybatis 的全局配置文件，配置了 mybatis 的运行环境等信息。 </p><p><code>mapper.xml</code> 文件即sql映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 <code>SqlMapConfig.xml</code> 中加载。 </p><ol start="2"><li><p>通过 mybatis 环境等配置信息构造 <code>SqlSessionFactory</code> 即会话工厂 </p></li><li><p>由会话工厂创建 sqlSession 即会话，操作数据库需要通过 sqlSession 进行。 </p></li><li><p>mybatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。 </p></li><li><p><code>Mapped Statement</code> 也是 mybatis 一个底层封装对象，它包装了 mybatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 <code>Mapped Statement</code> 对象，sql 的 id 即是 Mapped statement 的id。 </p></li><li><p>Mapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql前将输入的 java 对象映射至 sql 中，输入参数映射就是 jdbc 编程中对preparedStatement 设置参数。 </p></li><li><p>Mapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql 后将输出结果映射至 java 对象中，输出结果映射过程相当于 jdbc 编程中对结果的解析处理过程。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5nheb2f59j30lu0k6754.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mybatis配置    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;SqlMa
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Mybatis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Mybatis/"/>
    
    
      <category term="mybatis" scheme="https://yapengren.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 架构</title>
    <link href="https://yapengren.github.io/wiki/Dubbo-%E6%9E%B6%E6%9E%84/"/>
    <id>https://yapengren.github.io/wiki/Dubbo-架构/</id>
    <published>2019-08-04T03:15:00.000Z</published>
    <updated>2019-08-04T03:20:10.521Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"></p><h3 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h3><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的服务提供方</td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的服务消费方</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td><code>Container</code></td><td>服务运行容器</td></tr></tbody></table><h3 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h3><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg&quot; alt=&quot;dubbo-architucture&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;节点角色说明&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Dubbo" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Dubbo/"/>
    
    
      <category term="dubbo" scheme="https://yapengren.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础知识点</title>
    <link href="https://yapengren.github.io/wiki/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Java-基础知识点/</id>
    <published>2019-08-03T10:01:30.000Z</published>
    <updated>2019-08-03T10:10:57.651Z</updated>
    
    <content type="html"><![CDATA[<h4 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a><a href="https://www.cnblogs.com/IvesHe/p/6108933.html" target="_blank" rel="noopener">List 和 Set 的区别</a></h4><h4 id="HashSet-是如何保证不重复的"><a href="#HashSet-是如何保证不重复的" class="headerlink" title="HashSet 是如何保证不重复的"></a><a href="https://blog.csdn.net/u010698072/article/details/52802179" target="_blank" rel="noopener">HashSet 是如何保证不重复的</a></h4><h4 id="HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"></a>HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）</h4><h4 id="HashMap-的扩容过程"><a href="#HashMap-的扩容过程" class="headerlink" title="HashMap 的扩容过程"></a><a href="https://www.cnblogs.com/KingIceMou/p/6976574.html" target="_blank" rel="noopener">HashMap 的扩容过程</a></h4><h4 id="HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</a></h4><h4 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final finally finalize"></a><a href="https://www.cnblogs.com/smart-hwt/p/8257330.html" target="_blank" rel="noopener">final finally finalize</a></h4><h4 id="强引用-、软引用、-弱引用、虚引用"><a href="#强引用-、软引用、-弱引用、虚引用" class="headerlink" title="强引用 、软引用、 弱引用、虚引用"></a><a href="https://www.cnblogs.com/yw-ah/p/5830458.html" target="_blank" rel="noopener">强引用 、软引用、 弱引用、虚引用</a></h4><h4 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h4><h4 id="Arrays-sort-实现原理和-Collection-实现原理"><a href="#Arrays-sort-实现原理和-Collection-实现原理" class="headerlink" title="Arrays.sort 实现原理和 Collection 实现原理"></a><a href="https://www.baidu.com/link?url=tFFtzrDujnsZH0r1y1MZalWy6NmEAsBEz6vglax_eysgtZFiTwK9ObeHWDTChqttMgr4EGAdu37jSmtyJfTx4Zts21A8ThRRzS9IWGPl5MS&wd=&eqid=9d74567f00035750000000025c417222" target="_blank" rel="noopener">Arrays.sort 实现原理和 Collection 实现原理</a></h4><h4 id="LinkedHashMap的应用"><a href="#LinkedHashMap的应用" class="headerlink" title="LinkedHashMap的应用"></a><a href="https://www.cnblogs.com/xiaoxi/p/6170590.html" target="_blank" rel="noopener">LinkedHashMap的应用</a></h4><h4 id="cloneable接口实现原理"><a href="#cloneable接口实现原理" class="headerlink" title="cloneable接口实现原理"></a>cloneable接口实现原理</h4><h4 id="异常分类以及处理机制"><a href="#异常分类以及处理机制" class="headerlink" title="异常分类以及处理机制"></a><a href="https://blog.csdn.net/hguisu/article/details/6155636#t0" target="_blank" rel="noopener">异常分类以及处理机制</a></h4><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><a href="https://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html" target="_blank" rel="noopener">wait和sleep的区别</a></h4><h4 id="数组在内存中如何分配"><a href="#数组在内存中如何分配" class="headerlink" title="数组在内存中如何分配"></a><a href="https://www.cnblogs.com/chenpi/p/5489732.html" target="_blank" rel="noopener">数组在内存中如何分配</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;List-和-Set-的区别&quot;&gt;&lt;a href=&quot;#List-和-Set-的区别&quot; class=&quot;headerlink&quot; title=&quot;List 和 Set 的区别&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/IvesHe/p/61
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 知识点</title>
    <link href="https://yapengren.github.io/wiki/Mysql-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Mysql-知识点/</id>
    <published>2019-08-03T09:36:37.000Z</published>
    <updated>2019-08-03T10:07:10.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="mysql-索引类型"><a href="#mysql-索引类型" class="headerlink" title="mysql 索引类型"></a><a href="https://www.cnblogs.com/luyucheng/p/6289714.html" target="_blank" rel="noopener">mysql 索引类型</a></h4><h4 id="sql-优化的几种方式"><a href="#sql-优化的几种方式" class="headerlink" title="sql 优化的几种方式"></a><a href="https://blog.csdn.net/jie_liang/article/details/77340905" target="_blank" rel="noopener">sql 优化的几种方式</a></h4><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><h4 id="数据库事务的-4-种隔离级别"><a href="#数据库事务的-4-种隔离级别" class="headerlink" title="数据库事务的 4 种隔离级别"></a><a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">数据库事务的 4 种隔离级别</a></h4><h4 id="数据库事务的-4-个基本特性"><a href="#数据库事务的-4-个基本特性" class="headerlink" title="数据库事务的 4 个基本特性"></a><a href="https://blog.csdn.net/mfl0315/article/details/51981792" target="_blank" rel="noopener">数据库事务的 4 个基本特性</a></h4><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="Mysql中FIND-IN-SET-和IN区别简析"><a href="#Mysql中FIND-IN-SET-和IN区别简析" class="headerlink" title="Mysql中FIND_IN_SET()和IN区别简析"></a><a href="https://www.jb51.net/article/125744.htm" target="_blank" rel="noopener">Mysql中FIND_IN_SET()和IN区别简析</a></h4><h4 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html" target="_blank" rel="noopener">MySQL Explain详解</a></h4><h4 id="MySQL中concat以及group-concat的使用"><a href="#MySQL中concat以及group-concat的使用" class="headerlink" title="MySQL中concat以及group_concat的使用"></a><a href="https://blog.csdn.net/mary19920410/article/details/76545053" target="_blank" rel="noopener">MySQL中concat以及group_concat的使用</a></h4><h4 id="MySQL中order-by语句对null字段的排序"><a href="#MySQL中order-by语句对null字段的排序" class="headerlink" title="MySQL中order by语句对null字段的排序"></a><a href="https://www.cnblogs.com/Wcy100/p/5376399.html" target="_blank" rel="noopener">MySQL中order by语句对null字段的排序</a></h4><h3 id="SQL练习"><a href="#SQL练习" class="headerlink" title="SQL练习"></a>SQL练习</h3><h4 id="MySQL经典练习题及答案，常用SQL语句练习50题"><a href="#MySQL经典练习题及答案，常用SQL语句练习50题" class="headerlink" title="MySQL经典练习题及答案，常用SQL语句练习50题"></a><a href="https://blog.csdn.net/qq_41936662/article/details/80393172" target="_blank" rel="noopener">MySQL经典练习题及答案，常用SQL语句练习50题</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h3&gt;&lt;h4 id=&quot;mysql-索引类型&quot;&gt;&lt;a href=&quot;#mysql-索引类型&quot; class=&quot;headerlink&quot; title=&quot;m
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>intellij idea 修改记录</title>
    <link href="https://yapengren.github.io/wiki/intellij-idea-%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95/"/>
    <id>https://yapengren.github.io/wiki/intellij-idea-修改记录/</id>
    <published>2019-08-02T10:13:00.000Z</published>
    <updated>2019-08-04T03:50:15.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤文件"><a href="#过滤文件" class="headerlink" title="过滤文件"></a>过滤文件</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5li1vj2waj31ak0u0199.jpg" alt="image-20190802181535850"></p><h3 id="显示多-Tabs"><a href="#显示多-Tabs" class="headerlink" title="显示多 Tabs"></a>显示多 Tabs</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5mm7u2b81j31au0u07ii.jpg" alt="image-20190803172518386"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;过滤文件&quot;&gt;&lt;a href=&quot;#过滤文件&quot; class=&quot;headerlink&quot; title=&quot;过滤文件&quot;&gt;&lt;/a&gt;过滤文件&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5li1vj2waj31
      
    
    </summary>
    
      <category term="开发工具" scheme="https://yapengren.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDE" scheme="https://yapengren.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDE/"/>
    
    
      <category term="util" scheme="https://yapengren.github.io/tags/util/"/>
    
  </entry>
  
  <entry>
    <title>mac brew 服务</title>
    <link href="https://yapengren.github.io/wiki/mac-brew-%E6%9C%8D%E5%8A%A1/"/>
    <id>https://yapengren.github.io/wiki/mac-brew-服务/</id>
    <published>2019-08-02T09:40:48.000Z</published>
    <updated>2019-08-02T10:01:21.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="brew-常用命令"><a href="#brew-常用命令" class="headerlink" title="brew 常用命令"></a>brew 常用命令</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span>搜索软件</span><br><span class="line"><span class="keyword">brew </span>search nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">brew </span>安装软件</span><br><span class="line"><span class="keyword">brew </span>install nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">brew </span>卸载软件</span><br><span class="line"><span class="keyword">brew </span>uninstall nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">brew </span>升级</span><br><span class="line"><span class="symbol">sudo</span> <span class="keyword">brew </span>update</span><br><span class="line"></span><br><span class="line">查看安装信息</span><br><span class="line"><span class="symbol">sudo</span> <span class="keyword">brew </span><span class="meta">info</span> nginx </span><br><span class="line"></span><br><span class="line">查看已安装软件</span><br><span class="line"><span class="keyword">brew </span>list</span><br></pre></td></tr></table></figure><h3 id="brew-安装nginx"><a href="#brew-安装nginx" class="headerlink" title="brew 安装nginx"></a>brew 安装nginx</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line"><span class="symbol">sudo</span> <span class="keyword">brew </span>install nginx</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line"><span class="symbol">sudo</span> <span class="keyword">brew </span>services start nginx</span><br><span class="line"></span><br><span class="line">重启</span><br><span class="line"><span class="symbol">sudo</span> <span class="keyword">brew </span>services restart nginx</span><br><span class="line"></span><br><span class="line">停止</span><br><span class="line"><span class="symbol">sudo</span> <span class="keyword">brew </span>services stop nginx</span><br><span class="line"></span><br><span class="line">查看</span><br><span class="line"><span class="symbol">cat</span> /usr/local/etc/nginx/nignx.conf</span><br></pre></td></tr></table></figure><h3 id="brew-redis"><a href="#brew-redis" class="headerlink" title="brew redis"></a>brew redis</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">启动</span><br><span class="line">redis-server /usr/local/etc/redis-<span class="number">6379</span>.conf</span><br><span class="line"></span><br><span class="line">停止</span><br><span class="line">redis-cli -<span class="selector-tag">p</span> <span class="number">6379</span> shutdown</span><br></pre></td></tr></table></figure><h3 id="brew-安装-activemq"><a href="#brew-安装-activemq" class="headerlink" title="brew 安装 activemq"></a>brew 安装 activemq</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">brew <span class="keyword">install</span> activemq</span><br><span class="line"></span><br><span class="line">查看版本</span><br><span class="line">activemq —<span class="keyword">version</span></span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">activemq <span class="keyword">start</span></span><br><span class="line"></span><br><span class="line">地址</span><br><span class="line"><span class="keyword">http</span>://localhost:<span class="number">8161</span>    <span class="keyword">admin</span>   <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><h3 id="brew-安装-rabbitmq"><a href="#brew-安装-rabbitmq" class="headerlink" title="brew 安装 rabbitmq"></a>brew 安装 rabbitmq</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">brew <span class="keyword">install</span> rabbitmq</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">brew services <span class="keyword">start</span> rabbitmq</span><br><span class="line"></span><br><span class="line">地址</span><br><span class="line"><span class="keyword">http</span>://localhost:<span class="number">15672</span>    guest    guest</span><br></pre></td></tr></table></figure><h3 id="brew-安装-mongodb"><a href="#brew-安装-mongodb" class="headerlink" title="brew 安装 mongodb"></a>brew 安装 mongodb</h3><p>参考：<a href="https://blog.csdn.net/ligh_sqh/article/details/81112428" target="_blank" rel="noopener">https://blog.csdn.net/ligh_sqh/article/details/81112428</a></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line"></span><br><span class="line">启动 mongodb 客户端</span><br><span class="line">cd <span class="regexp">~/software/</span>adminmongo</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line">客户端地址    <span class="string">http:</span><span class="comment">//localhost:1234</span></span><br></pre></td></tr></table></figure><h3 id="nacos-启动命令"><a href="#nacos-启动命令" class="headerlink" title="nacos 启动命令"></a>nacos 启动命令</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sh ～<span class="regexp">/software/</span>nacos<span class="regexp">/bin/</span>startup.sh -m standalone</span><br></pre></td></tr></table></figure><h3 id="elasticsearch-head-安装和启动-elasticsearch-GUI客户端"><a href="#elasticsearch-head-安装和启动-elasticsearch-GUI客户端" class="headerlink" title="elasticsearch-head 安装和启动 -elasticsearch GUI客户端"></a>elasticsearch-head 安装和启动 -elasticsearch GUI客户端</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br><span class="line">npm run <span class="literal">start</span></span><br><span class="line"></span><br><span class="line">http://localhost:<span class="number">9100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;brew-常用命令&quot;&gt;&lt;a href=&quot;#brew-常用命令&quot; class=&quot;headerlink&quot; title=&quot;brew 常用命令&quot;&gt;&lt;/a&gt;brew 常用命令&lt;/h3&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
      <category term="系统方面" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2/"/>
    
      <category term="mac" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2/mac/"/>
    
    
      <category term="mac" scheme="https://yapengren.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>token 防表单重复提交</title>
    <link href="https://yapengren.github.io/wiki/token-%E9%98%B2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"/>
    <id>https://yapengren.github.io/wiki/token-防表单重复提交/</id>
    <published>2019-08-02T03:16:10.000Z</published>
    <updated>2019-08-04T03:10:49.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h3><p>加载页面时候调用 <code>initToken()</code> 方法，生成 token 存入页面隐藏域中</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="comment">--隐藏域-防止表单的重复提交--%&gt;</span></span><br><span class="line">&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"examToken"</span> id=<span class="string">"examToken"</span>&gt;&lt;/<span class="built_in">input</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h3><p>表单提交的时候带上 token</p><h3 id="方法添加注解"><a href="#方法添加注解" class="headerlink" title="方法添加注解"></a>方法添加注解</h3><p>springMVC 方法上添加注解 <code>@TokenCheck(isCheckToken = true)</code></p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解 <code>TokenCheck.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解会在class字节码文件中存在，在运行时可以通过反射获取到</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) </span><br><span class="line"><span class="comment">// 定义注解的作用目标**作用范围字段、枚举的常量/方法</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="comment">// 说明该注解将被包含在javadoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TokenCheck &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCheckToken</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义注解拦截器"><a href="#自定义注解拦截器" class="headerlink" title="自定义注解拦截器"></a>自定义注解拦截器</h3><p>springMVC 配置文件 <code>spring-servlet.xml</code> 添加 <code>&lt;mvc:interceptors</code> 拦截器</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path=<span class="string">"/**"</span> /&gt;</span><br><span class="line">        &lt;bean class="com.ycx.exam.web.comm.interceptor.TokenCheckDuplicateSubmitInterceptor"&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h3 id="拦截器内容"><a href="#拦截器内容" class="headerlink" title="拦截器内容"></a>拦截器内容</h3><p>TokenCheckDuplicateSubmitInterceptor.java</p><p>在拦截器中判断<code>TokenCheck</code>注解<code>isCheckToken</code>是否为 true，如果为 true，则执行缓存校验；</p><p>先从 redis 缓存中获取到 token 集合，再从缓存中查询 token；</p><p>如果存在，则属于重复提交，返回；</p><p>如果不存在，则属于首次提交，将此token压入token集合中并将token集合放回redis中；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenCheckDuplicateSubmitInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getLogger(TokenCheckDuplicateSubmitInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        WebApplicationContext context = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext());</span><br><span class="line">        CacheService cacheService = (CacheService) context.getBean(<span class="string">"cacheService"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cacheService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"token拦截器校验重复提交，缓存service为空!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            TokenCheck annotation = method.getAnnotation(TokenCheck.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isCheckToken = annotation.isCheckToken();</span><br><span class="line">                <span class="keyword">if</span> (isCheckToken) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> isExist = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">boolean</span> isgetLock = getLock(cacheService, <span class="string">"examTokenLock"</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (isgetLock) &#123;</span><br><span class="line">                        isExist = checkTokenExist(request, cacheService);</span><br><span class="line">                        <span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">                            log.warn(<span class="string">"token拦截重复提交校验"</span> + method.getName() + <span class="string">"重复提交!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cacheService.releaseLock(<span class="string">"examTokenLock"</span>);</span><br><span class="line">                    <span class="keyword">return</span> isExist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheService</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> second    秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(CacheService cacheService, String cacheKey, <span class="keyword">long</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isgetLock = cacheService.getLock(cacheKey, <span class="string">"1"</span>, second);</span><br><span class="line">        <span class="comment">//如果没有获得锁，将默认进行三次锁的获取</span></span><br><span class="line">        <span class="keyword">if</span> (!isgetLock) &#123;</span><br><span class="line">            log.info(<span class="string">"获得分布式锁失败，进入等待..........."</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                isgetLock = cacheService.getLock(cacheKey, <span class="string">"1"</span>, second);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isgetLock) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isgetLock) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isgetLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheService</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTokenExist</span><span class="params">(HttpServletRequest request, CacheService cacheService)</span> </span>&#123;</span><br><span class="line">        String token = request.getParameter(<span class="string">"examToken"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            log.warn(<span class="string">"token拦截器校验重复提交，页面提交过来token为空!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        token = token.trim();</span><br><span class="line">        LRULinkedHashMap&lt;String, String&gt; cmap = (LRULinkedHashMap&lt;String, String&gt;) cacheService.getCacheData(<span class="string">"examTokenMap"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">131072</span>;</span><br><span class="line">            <span class="comment">// 最近最少使用算法，linkedHashMap实现，主要是针对缓存过期策略实现</span></span><br><span class="line">            cmap = <span class="keyword">new</span> LRULinkedHashMap&lt;String, String&gt;(size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"token缓存map存在，size="</span> + cmap.size());</span><br><span class="line">        &#125;</span><br><span class="line">        String ieExist = cmap.get(token);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(ieExist)) &#123;</span><br><span class="line">            log.info(<span class="string">"缓存不存在token="</span> + token);</span><br><span class="line">            String valu = cmap.put(token, <span class="string">"1"</span>);</span><br><span class="line">            cacheService.setCacheDataForType(<span class="string">"examTokenMap"</span>, cmap, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">            log.info(<span class="string">"将token="</span> + token + <span class="string">"加入缓存成功!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"将token="</span> + token + <span class="string">"已经存在，重复提交!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生成-token&quot;&gt;&lt;a href=&quot;#生成-token&quot; class=&quot;headerlink&quot; title=&quot;生成 token&quot;&gt;&lt;/a&gt;生成 token&lt;/h3&gt;&lt;p&gt;加载页面时候调用 &lt;code&gt;initToken()&lt;/code&gt; 方法，生成 token 
      
    
    </summary>
    
      <category term="技术开发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="解决方案" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
</feed>

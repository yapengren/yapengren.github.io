<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yp_ren Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yapengren.github.io/"/>
  <updated>2019-09-02T02:53:12.624Z</updated>
  <id>https://yapengren.github.io/</id>
  
  <author>
    <name>renyapeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>稀疏数组 sparsearray</title>
    <link href="https://yapengren.github.io/wiki/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84-sparsearray/"/>
    <id>https://yapengren.github.io/wiki/稀疏数组-sparsearray/</id>
    <published>2019-09-01T06:37:41.000Z</published>
    <updated>2019-09-02T02:53:12.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>编写的五子棋程序中，有存盘退出和续上盘的功能。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jtgf40z1j30zw0fcgp7.jpg" alt="image-20190901103926746"></p><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据</p><h3 id="稀疏数组基本介绍"><a href="#稀疏数组基本介绍" class="headerlink" title="稀疏数组基本介绍"></a>稀疏数组基本介绍</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><h3 id="稀疏数组处理方法"><a href="#稀疏数组处理方法" class="headerlink" title="稀疏数组处理方法"></a>稀疏数组处理方法</h3><ol><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ol><h3 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jthducssj30r20k0q7p.jpg" alt="image-20190901104024821"></p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><ol><li>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</li><li>把稀疏数组存盘，并且可以重新恢复原来的二维数组数</li></ol><h3 id="整体思路分析"><a href="#整体思路分析" class="headerlink" title="整体思路分析"></a>整体思路分析</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jtib2spsj31gi0e2n21.jpg" alt="image-20190901104117834"></p><p>原始的二维数组 –&gt; 稀疏数组的思路</p><ol><li><p>遍历原始的二维数组，得到有效数据的个数 sum</p></li><li><p>根据 sum 可以创建稀疏数组 <code>sparseArr int[sum + 1][3]</code></p></li><li><p>将二维数组的有效数据存入到稀疏数组</p></li></ol><p>稀疏数组 –&gt; 原始的二维数组的思路</p><ol><li><p>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如 <code>int[][] chessArr = new int[11][11]</code></p></li><li><p>在读取稀疏数组后几行的数据，并赋给原始的二维数组</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">// 0表示没有棋子，1表示黑棋，2表示蓝棋</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">"原始的二维数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始的二维数组 --&gt; 稀疏数组的思路</span></span><br><span class="line">        <span class="comment">// 1、遍历二维数组，得到非 0 数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">// 3、遍历二维数组，将非 0 数据存入 sparseArr</span></span><br><span class="line">        <span class="comment">// count 用于记录是第几个非 0 数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"稀疏数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稀疏数组 --&gt; 原始的二维数组的思路</span></span><br><span class="line">        <span class="comment">// 1.  先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如 int[][] chessArr = new int[11][11]</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 2.  在读取稀疏数组后几行的数据，并赋给原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;编写的五子棋程序中，有存盘退出和续上盘的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://yapengren.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java 基础题</title>
    <link href="https://yapengren.github.io/wiki/java-%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>https://yapengren.github.io/wiki/java-基础题/</id>
    <published>2019-09-01T01:38:39.000Z</published>
    <updated>2019-09-01T01:39:49.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">    System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">    System.out.println(<span class="string">"j="</span> + j);</span><br><span class="line">    System.out.println(<span class="string">"k="</span> + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i=4</span><br><span class="line">j=1</span><br><span class="line">k=11</span><br></pre></td></tr></table></figure><p>i++：先使用再 +1</p><p>++i：先 +1 再使用</p><h3 id="初始化和实例初始化"><a href="#初始化和实例初始化" class="headerlink" title="初始化和实例初始化"></a>初始化和实例初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 实例代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 普通方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 静态方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 实例代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 普通方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 静态方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Facther 静态方法</span><br><span class="line">Facther 静态代码块</span><br><span class="line">Son 静态方法</span><br><span class="line">Son 静态代码块</span><br><span class="line">Son 普通方法</span><br><span class="line">Facther 实例代码块</span><br><span class="line">Facther 构造方法</span><br><span class="line">Son 普通方法</span><br><span class="line">Son 实例代码块</span><br><span class="line">Son 构造方法</span><br><span class="line">-----</span><br><span class="line">Son 普通方法</span><br><span class="line">Facther 实例代码块</span><br><span class="line">Facther 构造方法</span><br><span class="line">Son 普通方法</span><br><span class="line">Son 实例代码块</span><br><span class="line">Son 构造方法</span><br></pre></td></tr></table></figure><h3 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Integer num = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"i=  "</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"str=  "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"num=  "</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"arr=  "</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">"my.a=  "</span> + my.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a, MyData m)</span> </span>&#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">"world"</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i=  1</span><br><span class="line">str=  hello</span><br><span class="line">num=  200</span><br><span class="line">arr=  [2, 2, 3, 4, 5]</span><br><span class="line">my.a=  11</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;自增变量&quot;&gt;&lt;a href=&quot;#自增变量&quot; class=&quot;headerlink&quot; title=&quot;自增变量&quot;&gt;&lt;/a&gt;自增变量&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库知识点</title>
    <link href="https://yapengren.github.io/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/数据库知识点/</id>
    <published>2019-08-27T09:58:46.000Z</published>
    <updated>2019-08-28T04:46:59.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><h3 id="第一范式-1st-NF-－列都是不可再分"><a href="#第一范式-1st-NF-－列都是不可再分" class="headerlink" title="第一范式(1st NF －列都是不可再分)"></a>第一范式(1st NF －列都是不可再分)</h3><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子 单元），则满足第一范式（1NF）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fan9n4muj30op05sq4c.jpg" alt="Attachment.jpeg"></p><h3 id="第二范式-2nd-NF－每个表只描述一件事情"><a href="#第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="第二范式(2nd NF－每个表只描述一件事情)"></a>第二范式(2nd NF－每个表只描述一件事情)</h3><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一 件事情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fankw6t9j30jj07cq4d.jpg" alt="Attachment.jpeg"></p><h3 id="第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="第三范式(3rd NF－ 不存在对非主键列的传递依赖)"></a>第三范式(3rd NF－ 不存在对非主键列的传递依赖)</h3><p>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编 号外，顾客姓名依赖于非主键顾客编号。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fanpp7gcj30jp08ejsw.jpg" alt="Attachment.jpeg"></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="MySQL-中FIND-IN-SET-和IN区别简析"><a href="#MySQL-中FIND-IN-SET-和IN区别简析" class="headerlink" title="MySQL 中FIND_IN_SET()和IN区别简析"></a><a href="https://www.jb51.net/article/125744.htm" target="_blank" rel="noopener">MySQL 中FIND_IN_SET()和IN区别简析</a></h3><h3 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html" target="_blank" rel="noopener">MySQL Explain详解</a></h3><h3 id="MySQL中concat以及group-concat的使用"><a href="#MySQL中concat以及group-concat的使用" class="headerlink" title="MySQL中concat以及group_concat的使用"></a><a href="https://blog.csdn.net/mary19920410/article/details/76545053" target="_blank" rel="noopener">MySQL中concat以及group_concat的使用</a></h3><h3 id="MySQL中order-by语句对null字段的排序"><a href="#MySQL中order-by语句对null字段的排序" class="headerlink" title="MySQL中order by语句对null字段的排序"></a><a href="https://www.cnblogs.com/Wcy100/p/5376399.html" target="_blank" rel="noopener">MySQL中order by语句对null字段的排序</a></h3><h2 id="SQL练习"><a href="#SQL练习" class="headerlink" title="SQL练习"></a>SQL练习</h2><h3 id="MySQL经典练习题及答案，常用SQL语句练习50题"><a href="#MySQL经典练习题及答案，常用SQL语句练习50题" class="headerlink" title="MySQL经典练习题及答案，常用SQL语句练习50题"></a><a href="https://blog.csdn.net/qq_41936662/article/details/80393172" target="_blank" rel="noopener">MySQL经典练习题及答案，常用SQL语句练习50题</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库三范式&quot;&gt;&lt;a href=&quot;#数据库三范式&quot; class=&quot;headerlink&quot; title=&quot;数据库三范式&quot;&gt;&lt;/a&gt;数据库三范式&lt;/h2&gt;&lt;h3 id=&quot;第一范式-1st-NF-－列都是不可再分&quot;&gt;&lt;a href=&quot;#第一范式-1st-NF-－列都是不
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务知识点</title>
    <link href="https://yapengren.github.io/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/数据库事务知识点/</id>
    <published>2019-08-27T09:20:07.000Z</published>
    <updated>2019-08-27T09:53:46.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库事务概念"><a href="#数据库事务概念" class="headerlink" title="数据库事务概念"></a>数据库事务概念</h2><h3 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h3><p>事务（transaction）是由指逻辑上对数据的的一组操作， 这组操作要么一次全部成功，如果这组操作全部失败，是不可分割的一个工作单位。</p><h2 id="数据库事务的-4-个基本性质（ACID）"><a href="#数据库事务的-4-个基本性质（ACID）" class="headerlink" title="数据库事务的 4 个基本性质（ACID）"></a>数据库事务的 4 个基本性质（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务的原子性是指事务是一个不可分割的工作单位，这组操作要么全部发生，否则全部不发生。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>在事务开始以前，被操作的数据的完整性处于一致性的状态，事务结束后，被操作的数据的完整性也必须处于一致性状态。</p><p>拿银行转账来说，一致性要求事务的执行不应改变A、B 两个账户的金额总和。如果没有这种一致性要求，转账过程中就会发生钱无中生有，或者不翼而飞的现象。事务应该把数据库从一个一致性状态转换到另外一个一致性状态。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>事务隔离性要求系统必须保证事务不受其他并发执行的事务的影响，也即要达到这样一种效果：对于任何一对事务T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前已经结束，要么在 T1 完成之后才开始执行。这样，每个事务都感觉不到系统中有其他事务在并发地执行。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>一个事务一旦成功提交，它对数据库的改变必须是永久的，即便是数据库发生故障也应该不回对其产生任何影响。</p><h2 id="数据库事务的-4-种隔离级别"><a href="#数据库事务的-4-种隔离级别" class="headerlink" title="数据库事务的 4 种隔离级别"></a>数据库事务的 4 种隔离级别</h2><h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是 3.6 万/月。但是发工资时老板不小心按错了数字，按成 3.9 万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了 3 千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成 3.6 万再提交。</p><p>分析：实际程序员这个月的工资还是 3.6 万，但是程序员看到的是 3.9 万。他看到的是老板还没提交事务时的数据。这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有 3.6 万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有 3.6 万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新 UPDATE 操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有 3.6 万），当他埋单时（事务开启，不允许其他事务的 UPDATE 修改操作），收费系统事先检测到他的卡里有 3.6 万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即 UPDATE 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 INSERT 操作，而不是 UPDATE 操作。</p><p>什么时候会出现幻读？</p><p>事例：程序员某一天去消费，花了 2 千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了 2 千元，就在这个时候，程序员花了 1 万买了一部电脑，即新增 INSERT 了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://blog.csdn.net/mfl0315/article/details/51981792" target="_blank" rel="noopener">https://blog.csdn.net/mfl0315/article/details/51981792</a></p><p>  <a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">https://blog.csdn.net/qq_33290787/article/details/51924963</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库事务概念&quot;&gt;&lt;a href=&quot;#数据库事务概念&quot; class=&quot;headerlink&quot; title=&quot;数据库事务概念&quot;&gt;&lt;/a&gt;数据库事务概念&lt;/h2&gt;&lt;h3 id=&quot;什么是数据库事务&quot;&gt;&lt;a href=&quot;#什么是数据库事务&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引知识点</title>
    <link href="https://yapengren.github.io/wiki/MySQL-%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/MySQL-索引知识点/</id>
    <published>2019-08-25T03:44:17.000Z</published>
    <updated>2019-08-25T08:54:22.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><ol><li>全值匹配</li><li>最佳左前缀法则。如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列</li><li>不在索引列上做任何操作（计算、函数、「自动或者手动」类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引（只访问索引的查询「索引列和查询列一致」），减少 select *</li><li>MySQL 在使用 != 或者 &lt;&gt; 的时候无法使用索引会导致全表扫描</li><li>is null，is not null 无法使用索引</li><li>like 以通配符开头 (‘%abc…’) MySQL 索引失效会变成全表扫描的操作</li><li>字符串不加单引号索引失效</li><li>少用 or，用它来连接时会索引失效 </li></ol><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>假设 index(a, b, c)</p><table><thead><tr><th align="left">Where 语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td align="left">where a = 3</td><td>Y，使用到 a</td></tr><tr><td align="left">where a = 3 and b = 5</td><td>Y，使用到 a，b</td></tr><tr><td align="left">where a = 3 and b = 5 and c = 4</td><td>Y，使用到 a，b，c</td></tr><tr><td align="left">where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td><td>N</td></tr><tr><td align="left">where a = 3 and c = 5</td><td>使用到 a，但是 c 不可以，b 中间断了</td></tr><tr><td align="left">where a = 3 and b &gt; 4 and c = 5</td><td>使用到 a 和 b，c 不能用在范围之后，b 断了</td></tr><tr><td align="left">where a = 3 and b like ‘kk%’ and c = 4</td><td>Y，使用到 a，b，c</td></tr><tr><td align="left">where a = 3 and b like ‘%kk’ and c = 4</td><td>Y，只用到 a</td></tr><tr><td align="left">where a = 3 and b like ‘%kk%’ and c = 4</td><td>Y，只用到 a</td></tr><tr><td align="left">where a = 3 and b like ‘k%kk%’ and c = 4</td><td>Y，只用到 a，b，c</td></tr></tbody></table><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  创建表</span><br><span class="line">create table test03(</span><br><span class="line"> id int primary key not null auto_increment,</span><br><span class="line"> c1 char(10),</span><br><span class="line"> c2 char(10),</span><br><span class="line"> c3 char(10),</span><br><span class="line"> c4 char(10),</span><br><span class="line"> c5 char(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;a1&apos;,&apos;a2&apos;,&apos;a3&apos;,&apos;a4&apos;,&apos;a5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;b1&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;b4&apos;,&apos;b5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;,&apos;c5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;d1&apos;,&apos;d2&apos;,&apos;d3&apos;,&apos;d4&apos;,&apos;d5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;e1&apos;,&apos;e2&apos;,&apos;e3&apos;,&apos;e4&apos;,&apos;e5&apos;);</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">create index idx_test03_c1234 on test03(c1,c2,c3,c4);</span><br></pre></td></tr></table></figure><p>问题：我们创建了复合索引idx_test03_c1234 ，根据以下SQL分析索引使用情况？</p><ol><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4=’a4’;<br>索引全部使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxein3zpj31v407y0wj.jpg" alt="image-20190825145131921"></p><ol start="2"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ and c3=’a3’;<br>索引全部使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxkebwxfj31v4088n11.jpg" alt="image-20190825145307176"></p><ol start="3"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3&gt;’a3’ and c4=’a4’;<br>索引 c1c2c3 使用，c4 未使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxjkp44uj31ua07w42g.jpg" alt="image-20190825145614418"></p><ol start="4"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4&gt;’a4’ and c3=’a3’;<br>索引全部使用 </li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxjyb630j31uo07yae1.jpg" alt="image-20190825145645207"></p><ol start="5"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ order by c3;<br>索引 c1c2 使用，c3 作用在排序而不是查找，c4 不使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxlhdwq5j31wy08642j.jpg" alt="image-20190825145812889"></p><ol start="6"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ order by c3;<br>索引 c1c2 使用 c3 作用在排序而不是查找，和 5 题一样</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxm32cxcj31x6088n16.jpg" alt="image-20190825145848614"></p><ol start="7"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ order by c4;<br>索引 c1c2 使用 ，但出现 Using filesort</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxn1x2g4j323u08ctcz.jpg" alt="image-20190825145943711"></p><ol start="8"><li>explain select * from test03 where c1=’a1’ and c5=’a5’ order by c2,c3;<br>索引 c1 使用，但是 c2，c3用于排序，无 filesort</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxnorlcwj320408aq74.jpg" alt="image-20190825150020427"></p><p>explain select * from test03 where c1=’a1’ and c5=’a5’ order by c3,c2;<br>索引 c1 使用，出现 filesort，我们建立索引 1234，它没有按照顺序来，3 2 颠倒了 </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxo1umiyj327a08678m.jpg" alt="image-20190825150041613"></p><ol start="9"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ order by c2,c3;<br>索引 c1c2 使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxofl0uij31x8082djv.jpg" alt="image-20190825150103386"></p><ol start="10"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c5=’a5’ order by c2,c3;<br>索引 c1c2 使用，但是 c2、c3 用于排序，无 filesort</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxp640boj322m084dk3.jpg" alt="image-20190825150145899"></p><p>explain select * from test03 where c1=’a1’ and c2=’a2’ and c5=’a5’ order by c3,c2;<br>本例有常量 c2 的情况，和 8.2 对比，无filesort</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxpei5n1j322w08242p.jpg" alt="image-20190825150159806"></p><ol start="11"><li>explain select * from test03 where c1=’a1’ and c4=’a4’ order by c2,c3;<br>索引 c1 使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxpmqucmj31uc084788.jpg" alt="image-20190825150212205"></p><ol start="12"><li>explain select * from test03 where c1=’a1’ and c4=’a4’ order by c3,c2;<br>索引 c1 使用, 出现了 Using where; Using temporary; Using filesort </li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxpz58v2j321a07ygpp.jpg" alt="image-20190825150232699"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引优化&quot;&gt;&lt;a href=&quot;#索引优化&quot; class=&quot;headerlink&quot; title=&quot;索引优化&quot;&gt;&lt;/a&gt;索引优化&lt;/h2&gt;&lt;h3 id=&quot;索引失效案例&quot;&gt;&lt;a href=&quot;#索引失效案例&quot; class=&quot;headerlink&quot; title=&quot;索引失效案
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL 的各种 JOIN 用法</title>
    <link href="https://yapengren.github.io/wiki/SQL-%E7%9A%84%E5%90%84%E7%A7%8D-JOIN-%E7%94%A8%E6%B3%95/"/>
    <id>https://yapengren.github.io/wiki/SQL-的各种-JOIN-用法/</id>
    <published>2019-08-24T07:41:20.000Z</published>
    <updated>2019-08-25T01:26:42.983Z</updated>
    
    <content type="html"><![CDATA[<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8ss22yj30qu0l4q5w.jpg" alt="img"></p><h3 id="Inner-JOIN"><a href="#Inner-JOIN" class="headerlink" title="Inner JOIN"></a>Inner JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8r7xc7j307604umx4.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt; </span><br><span class="line">FROM Table_A A</span><br><span class="line">INNER JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Left-JOIN"><a href="#Left-JOIN" class="headerlink" title="Left JOIN"></a>Left JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8t2omcj307604ugll.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Right-JOIN"><a href="#Right-JOIN" class="headerlink" title="Right JOIN"></a>Right JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8s6ylkj307604ugll.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Left-Excluding-JOIN"><a href="#Left-Excluding-JOIN" class="headerlink" title="Left Excluding JOIN"></a>Left Excluding JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8qxu6hj307604u3yh.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt; </span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE B.Key IS NULL</span><br></pre></td></tr></table></figure><h3 id="Right-Excluding-JOIN"><a href="#Right-Excluding-JOIN" class="headerlink" title="Right Excluding JOIN"></a>Right Excluding JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8roxm7j307604u0sp.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL</span><br></pre></td></tr></table></figure><h3 id="Outer-JOIN"><a href="#Outer-JOIN" class="headerlink" title="Outer JOIN"></a>Outer JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8u43nrj307604u3yi.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># oracle</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">FULL OUTER JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line"></span><br><span class="line"># MySQL</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Outer-Excluding-JOIN"><a href="#Outer-Excluding-JOIN" class="headerlink" title="Outer Excluding JOIN"></a>Outer Excluding JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8tobxfj307604udfu.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># oracle</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">FULL OUTER JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL OR B.Key IS NULL</span><br><span class="line"></span><br><span class="line"># mysql</span><br><span class="line">SELECT &lt;select_list&gt; </span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE B.Key IS NULL</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL</span><br></pre></td></tr></table></figure><blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>  <a href="https://www.runoob.com/w3cnote/sql-join-image-explain.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/sql-join-image-explain.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8ss22yj30qu0l4q
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL 执行顺序</title>
    <link href="https://yapengren.github.io/wiki/SQL-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://yapengren.github.io/wiki/SQL-执行顺序/</id>
    <published>2019-08-24T03:38:17.000Z</published>
    <updated>2019-08-24T03:43:52.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6amco99e5j32640jwagv.jpg" alt="1566617994720"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL-执行顺序&quot;&gt;&lt;a href=&quot;#SQL-执行顺序&quot; class=&quot;headerlink&quot; title=&quot;SQL 执行顺序&quot;&gt;&lt;/a&gt;SQL 执行顺序&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8m
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB 那些事</title>
    <link href="https://yapengren.github.io/wiki/MySQL-InnoDB-%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://yapengren.github.io/wiki/MySQL-InnoDB-那些事/</id>
    <published>2019-08-24T01:48:26.000Z</published>
    <updated>2019-08-25T01:31:01.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-InnoDB-聚簇索引和非聚簇索引"><a href="#MySQL-InnoDB-聚簇索引和非聚簇索引" class="headerlink" title="MySQL InnoDB 聚簇索引和非聚簇索引"></a>MySQL InnoDB 聚簇索引和非聚簇索引</h1><p>每个 InnoDB 表都有一个称为 「 聚簇索引 」 的特殊索引，通常情况下，这个聚簇索引就是 「 主键 」 ( primary key ) 。Innodb 使用它存储表中每一行的数据。</p><p>如果想要从查询、插入和其它数据库操作中获得最佳性能，那么我们就必须了解 InnoDB 如何使用 「 聚簇索引 」 来优化每个表的最常见检索和 DML 操作方式</p><ul><li><p>当我们在一个 Innodb 表上定义了一个主键，InnoDB 会默认的使用它作为聚簇索引。</p><p>使用 InnoDB 存储引擎时，建议为每个表都添加一个主键。如果该表没有一个逻辑唯一且非空列或列集合，那么可以添加一个带有 AUTO_INCREMENT 约束的自增列作为主键，InnoDB 会自动填充该列。</p></li><li><p>如果某个 InnoDB 表并没有定义主键。那么 InnoDB 会查找第一个 「 唯一索引 」( UNIQUE Index ) ，因为唯一索引的所有键 ( key ) 都是 <code>NOT</code> ，因此可以用来作为聚簇索引。</p></li><li><p>如果某个 InnoDB 表既没有定义主键，也没有一个合适的唯一索引。InnoDB 会在内部生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐式的聚簇索引</p><p>该聚簇索引的键 ( key ) 会包含一个自动为行生成的 ID 值 ( 行号 ) 。</p><p>该表中的所有行会按 InnoDB 分配给此类表中的行的 ID 排序。</p><p>行 ID 是一个 <strong>6</strong> 字节的字段，在插入新行时会单调自增。</p><p>因此，可以认为物理上的行保存顺序就是该行 ID 排序的排序顺序</p></li></ul><h2 id="聚簇索引如何加快查询速度"><a href="#聚簇索引如何加快查询速度" class="headerlink" title="聚簇索引如何加快查询速度"></a>聚簇索引如何加快查询速度</h2><p>通过聚簇索引访问行很快，因为索引搜索直接指向包含所有行数据页 ( data page )。</p><p>如果表很大，与那种索引页与数据页分离的 MyISAM 存储引擎相比， 聚簇索引体系结构通常可以节省磁盘 I/O 操作。</p><h2 id="非聚簇索引和聚簇索引的关系"><a href="#非聚簇索引和聚簇索引的关系" class="headerlink" title="非聚簇索引和聚簇索引的关系"></a>非聚簇索引和聚簇索引的关系</h2><p>非聚簇索引，通常也称之为 「 二级索引 」 ( Secondary Indexes ) 或 「 辅助索引 」 ，一般是指聚簇索引之外的所有其它的索引。</p><p>在 InnoDB 中，每个辅助索引中的每条记录都会包含该行的主键列 ( 也就是聚簇索引的键 ) ，以及为辅助索引指定的列。InnoDB 使用此主键值来搜索聚簇索引中的行。</p><p>如果主键很长，那么辅助索引就会占用更多空间，因此使用短主键是有利的，也是我们所推荐的。</p><h2 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h2><ol><li><p>首先，我们要认识到聚簇索引和非聚簇索引的划分依据是什么？</p><p>答案就是 InnoDB 会使用聚簇索引来保存数据，而非聚簇索引的目的仅仅是加快查询速度</p></li><li><p>在第一点认知基础上，我们就可以知道</p><ul><li>聚簇索引是唯一的，一个 InnoDB 表只有一个聚簇索引，而且一定会有一个聚簇索引，如果不存在，Innodb 存储引擎会自动添加一个</li><li>非聚簇所以可以有多个，而且只能由用户自己添加，InnoDB 默认并不会创建任何非聚簇索引。</li></ul></li><li><p>非聚簇索引中一定包含了聚簇索引的列值，但反过来却不存在。</p><p>因此，使用非聚簇索引查询数据一定会用到聚簇索引，但反过来却不存在。</p></li></ol><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="http://cmsblogs.com/?p=5463" target="_blank" rel="noopener">http://cmsblogs.com/?p=5463</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-InnoDB-聚簇索引和非聚簇索引&quot;&gt;&lt;a href=&quot;#MySQL-InnoDB-聚簇索引和非聚簇索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL InnoDB 聚簇索引和非聚簇索引&quot;&gt;&lt;/a&gt;MySQL InnoDB 聚簇索引
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis zset 实现简单限流</title>
    <link href="https://yapengren.github.io/wiki/Redis-zset-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%99%90%E6%B5%81/"/>
    <id>https://yapengren.github.io/wiki/Redis-zset-实现简单限流/</id>
    <published>2019-08-23T01:48:40.000Z</published>
    <updated>2019-08-25T01:31:15.173Z</updated>
    
    <content type="html"><![CDATA[<p>除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。</p><h1 id="如何使用-Redis-来实现简单限流策略？"><a href="#如何使用-Redis-来实现简单限流策略？" class="headerlink" title="如何使用 Redis 来实现简单限流策略？"></a>如何使用 Redis 来实现简单限流策略？</h1><p>首先我们来看一个常见的简单的限流策略。系统要限定用户的某个行为在指定的时间里只能允许发生 N 次，如何使用 Redis 的数据结构来实现这个限流的功能？</p><p>我们先定义这个接口，理解了这个接口的定义，读者就应该能明白我们期望达到的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定用户 user_id 的某个行为 action_key，在特定的时间内 period，只允许发生一定的次数 max_count</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActionAllowed</span><span class="params">(String userId, String actionKey, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个接口，5 分钟之内只能发帖 10 次</span></span><br><span class="line">limiter.isActionAllowed(<span class="string">"xiaoming"</span>, <span class="string">"publish"</span>, <span class="number">5</span> * <span class="number">60</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="错误方案"><a href="#错误方案" class="headerlink" title="错误方案"></a>错误方案</h2><blockquote><p>  将 userId 和 actionKey 拼成 key，在第一次请求时设置 value 为 1，设置过期时间 expire 为特定的时间 period</p><p>  每次请求的时候获取 value 值，若存在则 incr 自增 1，超过 maxCount 则做限制</p></blockquote><h3 id="问题模拟分析"><a href="#问题模拟分析" class="headerlink" title="问题模拟分析"></a>问题模拟分析</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g64rkjcypbj30ym0i80ti.jpg" alt="image-20190818163237023"></p><p>如上图：5 分钟之内只能发帖 10 次。</p><p>11:01 用户发帖 1 次，此时 redis 中存放数据 key 为 <code>userId:actionKey</code>，vlaue 为 1，过期时间 5 分钟；</p><p>11:05 用户发帖 8 次，发帖成功；</p><p>11:05 之后，key 过期时间到，被移除；</p><p>11:06 用户发帖，此时 redis 中 key 不存在，重新存放 key，发帖 8 次，发帖成功；</p><p>那么 11:05 -&gt; 11:06 时间段 2 分钟发帖 16 次，没有达到期望的功能；</p><h2 id="正确方案"><a href="#正确方案" class="headerlink" title="正确方案"></a>正确方案</h2><p>这个限流需求中存在一个滑动时间窗口，想想 zset 数据结构的 score 值，是不是可以通过 score 来圈出这个时间窗口来。而且我们只需要保留这个时间窗口，窗口之外的数据都可以砍掉。那这个 zset 的 value 填什么比较合适呢？它只需要保证唯一性即可，用 uuid 会比较浪费空间，那就改用毫秒时间戳吧。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g64rsbdgrgj30jr0cv3yj.jpg" alt></p><p>如图所示，用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个 key 保存下来。同一个用户同一种行为用一个 zset 记录。</p><p>为节省内存，我们只需要保留时间窗口内的行为记录，同时如果用户是冷用户，滑动时间窗口内的行为是空记录，那么这个 zset 就可以从内存中移除，不再占用空间。</p><p>通过统计滑动窗口内的行为数量与阈值 max_count 进行比较就可以得出当前的行为是否允许。用代码表示如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRateLimiter</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId    用户 user_id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionKey 某个行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period    特定的时间内，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount  最大允许的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActionAllowed</span><span class="params">(String userId, String actionKey, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        String key = String.format(<span class="string">"hist:%s:%s"</span>, userId, actionKey);</span><br><span class="line">        <span class="comment">// 毫秒时间戳</span></span><br><span class="line">        <span class="keyword">long</span> nowTs = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用了multi，也就是事务，能保证一系列指令的原子顺序执行</span></span><br><span class="line">        pipe.multi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放数据，value 和 score 都使用毫秒时间戳</span></span><br><span class="line">        pipe.zadd(key, nowTs, <span class="string">""</span> + nowTs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zremrangebyscore key min max 命令用于移除有序集中，指定分数（score）区间内的所有成员</span></span><br><span class="line">        <span class="comment">// 移除时间窗口之前的数据，剩下的都是时间窗口之内的</span></span><br><span class="line">        Response&lt;Long&gt; longResponse = pipe.zremrangeByScore(key, <span class="number">0</span>, nowTs - period * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于 count()，获取时间窗口内的行为数量</span></span><br><span class="line">        Response&lt;Long&gt; count = pipe.zcard(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 zset 过期时间，避免冷用户持续占用内存</span></span><br><span class="line">        <span class="comment">// 过期时间应该等于时间窗口的长度，再多宽限 1s</span></span><br><span class="line">        pipe.expire(key, period + <span class="number">1</span>);</span><br><span class="line">        pipe.exec();</span><br><span class="line">        pipe.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较数量是否超标</span></span><br><span class="line">        <span class="keyword">return</span> count.get() &lt;= maxCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">        SimpleRateLimiter limiter = <span class="keyword">new</span> SimpleRateLimiter(jedis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(limiter.isActionAllowed(<span class="string">"xiaoming"</span>, <span class="string">"publish"</span>, <span class="number">5</span> * <span class="number">60</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>因为它要记录时间窗口内所有的行为记录，如果这个量很大，比如限定 60s 内操作不得超过 100w 次这样的参数，它是不适合做这样的限流的，因为会消耗大量的存储空间。</p><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  《Redis 深度历险：核心原理与应用实践》   作者：钱文品</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。&lt;/p&gt;
&lt;h1 id=&quot;如何使
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>java死锁编程及定位分析</title>
    <link href="https://yapengren.github.io/wiki/java%E6%AD%BB%E9%94%81%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/"/>
    <id>https://yapengren.github.io/wiki/java死锁编程及定位分析/</id>
    <published>2019-08-21T09:37:44.000Z</published>
    <updated>2019-08-21T09:40:26.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁编程及定位分析"><a href="#死锁编程及定位分析" class="headerlink" title="死锁编程及定位分析"></a>死锁编程及定位分析</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>死锁是指两个或者两个以上的进程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉它们将都无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性也就很低，否则就会因争夺有限的资源而陷入死锁。</p><h3 id="产生死锁的主要原因"><a href="#产生死锁的主要原因" class="headerlink" title="产生死锁的主要原因"></a>产生死锁的主要原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h3 id="代码：DeadLockDemo"><a href="#代码：DeadLockDemo" class="headerlink" title="代码：DeadLockDemo"></a>代码：DeadLockDemo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA, lockB), <span class="string">"ThreadAAA"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB, lockA), <span class="string">"ThreadBBB"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  自己持有：  "</span> + lockA + <span class="string">"  尝试获得：  "</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"  自己持有：  "</span> + lockB + <span class="string">"  尝试获得：  "</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li>jps 命令定位进程号</li><li>jstack 找到死锁查看</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;死锁编程及定位分析&quot;&gt;&lt;a href=&quot;#死锁编程及定位分析&quot; class=&quot;headerlink&quot; title=&quot;死锁编程及定位分析&quot;&gt;&lt;/a&gt;死锁编程及定位分析&lt;/h2&gt;&lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解？</title>
    <link href="https://yapengren.github.io/wiki/java-%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%80%92%E5%BD%92%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/"/>
    <id>https://yapengren.github.io/wiki/java-公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解？/</id>
    <published>2019-08-20T06:29:56.000Z</published>
    <updated>2019-08-20T06:41:21.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</p><p>非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象。</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>公平锁/非公平锁：并发包中 ReentrantLock 的创建可以指定构造函数的 boolean 类型来得到公平锁或非公平锁，默认是非公平锁。</p><p>关于两者区别：</p><p>公平锁，就是很公平，在并发情况下，每个线程在获取锁时会查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己。</p><p>非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采取类似公平锁那种方式。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p><p>对于 Synchronized 而言，也是一种非公平锁。</p><h2 id="可重入锁（又名递归锁）"><a href="#可重入锁（又名递归锁）" class="headerlink" title="可重入锁（又名递归锁）"></a>可重入锁（又名递归锁）</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>可重入锁（也就是递归锁）：指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p><p>也就是说，线程可以进入任何一个它已经拥有的锁所有同步着的代码块。</p><h3 id="ReentrantLock-Synchronized-就是一个典型的可重入锁"><a href="#ReentrantLock-Synchronized-就是一个典型的可重入锁" class="headerlink" title="ReentrantLock/Synchronized 就是一个典型的可重入锁"></a>ReentrantLock/Synchronized 就是一个典型的可重入锁</h3><h3 id="可重入锁最大的作用是避免死锁"><a href="#可重入锁最大的作用是避免死锁" class="headerlink" title="可重入锁最大的作用是避免死锁"></a>可重入锁最大的作用是避免死锁</h3><h2 id="独占锁-共享锁"><a href="#独占锁-共享锁" class="headerlink" title="独占锁/共享锁"></a>独占锁/共享锁</h2><p>独占锁：指该锁一次只能被一个线程所持有。对 ReentrantLock 和 Synchronized 而言都是独占锁。</p><p>共享锁：指该锁可被多个线程所持有。</p><p>对 ReentrantReadWriteLock，其读锁是共享锁，其写锁是独占锁。读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁：是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下切换的消耗，缺点是循环会消耗CPU。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁和非公平锁&quot;&gt;&lt;/a&gt;公平锁和非公平锁&lt;/h2&gt;&lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList 知识点</title>
    <link href="https://yapengren.github.io/wiki/CopyOnWriteArrayList-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/CopyOnWriteArrayList-知识点/</id>
    <published>2019-08-20T06:19:07.000Z</published>
    <updated>2019-08-25T01:55:55.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>CopyOnWrite 容器即写时复制的容器。<br>往一个容器添加元素的时候，不直接往当前容器 Object[] 添加，而是先将当前 object[] 进行 Copy，复制出一个新的容器 Object[] newElements，<br>然后新的容器 Object[] newElements 里添加元素，<br>添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements)<br>这样做的好处是可以对 copyonwrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>所以 copyonwrite容器也是一种读写分离的思想，读和写不同的容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写时复制&quot;&gt;&lt;a href=&quot;#写时复制&quot; class=&quot;headerlink&quot; title=&quot;写时复制&quot;&gt;&lt;/a&gt;写时复制&lt;/h2&gt;&lt;p&gt;CopyOnWrite 容器即写时复制的容器。&lt;br&gt;往一个容器添加元素的时候，不直接往当前容器 Object[] 添加，而
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>原子类Atomiclnteger 的 ABA 问题谈谈？</title>
    <link href="https://yapengren.github.io/wiki/%E5%8E%9F%E5%AD%90%E7%B1%BBAtomiclnteger-%E7%9A%84-ABA-%E9%97%AE%E9%A2%98%E8%B0%88%E8%B0%88%EF%BC%9F/"/>
    <id>https://yapengren.github.io/wiki/原子类Atomiclnteger-的-ABA-问题谈谈？/</id>
    <published>2019-08-20T05:56:30.000Z</published>
    <updated>2019-08-20T06:17:01.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ABA问题怎么产生的"><a href="#ABA问题怎么产生的" class="headerlink" title="ABA问题怎么产生的"></a>ABA问题怎么产生的</h2><p>CAS会导致 ABA 问题</p><p>CAS 算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没问题的。</p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>解决ABA问题</p><h2 id="时间戳原子引用"><a href="#时间戳原子引用" class="headerlink" title="时间戳原子引用"></a>时间戳原子引用</h2><p>AtomicStampledReference<br>ABADemo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ABA问题怎么产生的&quot;&gt;&lt;a href=&quot;#ABA问题怎么产生的&quot; class=&quot;headerlink&quot; title=&quot;ABA问题怎么产生的&quot;&gt;&lt;/a&gt;ABA问题怎么产生的&lt;/h2&gt;&lt;p&gt;CAS会导致 ABA 问题&lt;/p&gt;
&lt;p&gt;CAS 算法实现一个重要前提需要取
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CAS 你知道吗？</title>
    <link href="https://yapengren.github.io/wiki/CAS-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/"/>
    <id>https://yapengren.github.io/wiki/CAS-你知道吗？/</id>
    <published>2019-08-20T05:49:03.000Z</published>
    <updated>2019-08-20T06:12:43.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h2><h2 id="CAS底层原理？如果知道，谈谈比对Unsafe的理解"><a href="#CAS底层原理？如果知道，谈谈比对Unsafe的理解" class="headerlink" title="CAS底层原理？如果知道，谈谈比对Unsafe的理解"></a>CAS底层原理？如果知道，谈谈比对Unsafe的理解</h2><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ol><li><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因为 Java 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p><p>注意 Unsafe 类中的所有方法都是 native 修饰的，也就是说 Unsafe 类中的方法都直接调用操作系统底层资源执行相应任务。</p></li><li><p>变量 valueOffset，表示该变量在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的。</p></li><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。</p></li></ol><h3 id="CAS-是什么"><a href="#CAS-是什么" class="headerlink" title="CAS 是什么"></a>CAS 是什么</h3><ol><li><p>unsafe.getAndAddInt</p><p>假设线程 A 和线程 B 两个线程同时执行 getAndAddInt 操作（分别跑在不同 CPU 上）</p><p>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 JMM 模型，线程 A 和线程 B 各自持有一份值为 3 的 value 的副本分别到各自的工作内存。</p><p>线程 A 通过 getIntVolatile（var1，var2）拿到 value 值 3，这是线程 A 被挂起。</p><p>线程 B 也通过 getIntVolatile（var1，var2）方法获得 value 值 3，此时刚好线程 B 没有被挂起并执行 compareAndSwap 方法比较内存值也为 3，成功修改内存值为 4，线程 B 打完收工，一切OK。</p><p>这是线程 A 回复，执行 compareAndSwapInt 方法比较，发现手里的值 3 与内存值 4 不一致，说明该值已经被其他线程抢险异步修改过了，那 A 线程本次修改失败，只能重新读取重新来一遍了。</p><p>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其他线程对它的修改，线程 A 总是能够看到，线程 A 继续执行 compareAndSwapInt 进行比较替换，直到成功。</p></li><li><p>底层汇编</p></li><li><p>简单版小总结<br>CAS（CompareAndSwap）<br>比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较知道主内存和工作内存中的值一致为止。</p></li></ol><p>CAS应用<br>CAS有 3 个操作数，内存值 V，旧的预期值 A，要修改的更新值 B。<br>当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p><h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><ol><li><p>循环时间长开销大<br>如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p></li><li><p>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们只能使用循环 CAS 的方式来保证原子操作，但是，对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p></li><li><p>引出来 ABA 问题？？？<br>通过原子引用解决 ABA 问题</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比较并交换&quot;&gt;&lt;a href=&quot;#比较并交换&quot; class=&quot;headerlink&quot; title=&quot;比较并交换&quot;&gt;&lt;/a&gt;比较并交换&lt;/h2&gt;&lt;h2 id=&quot;CAS底层原理？如果知道，谈谈比对Unsafe的理解&quot;&gt;&lt;a href=&quot;#CAS底层原理？如果知道，谈谈
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>谈谈你对 volatile 的理解</title>
    <link href="https://yapengren.github.io/wiki/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-volatile-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://yapengren.github.io/wiki/谈谈你对-volatile-的理解/</id>
    <published>2019-08-19T09:23:18.000Z</published>
    <updated>2019-08-19T09:33:51.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈你对-volatile-的理解"><a href="#谈谈你对-volatile-的理解" class="headerlink" title="谈谈你对 volatile 的理解"></a>谈谈你对 volatile 的理解</h2><p>volatile 是 Java 虚拟机提供的轻量级的同步机制</p><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回主内存中的。</p><p>这就可能存在一个线程 A 修改了共享变量 X 的值但还未写回主内存时，另一个线程 B 又对准内存中同一个共享变量 X 进行操作，但此时 A 线程工作内存中共享变量 X 对线程 B 来说并不是可见，这种工作内存与主内存同步存在延迟现象就造成了可见性问题。</p><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p>volatile 实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。</p><p>先了解一个概念，内存屏障又称内存栅栏，是一个CPU指令，它的作用有两个：<br>一是保证特定操作的执行顺序<br>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</p><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条 Memory Barrier 则告诉编译器和 CPU，不管什么指令都不能和这条 Memory Barrier 指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><h2 id="你在哪些地方用过volatile？"><a href="#你在哪些地方用过volatile？" class="headerlink" title="你在哪些地方用过volatile？"></a>你在哪些地方用过volatile？</h2><p>单例模式 DCL 代码<br>单例模式 volatile 分析</p><p>DCL（双端检锁）机制不一定线程安全，原因是有指令重排序的存在，加入 volatile 可以禁止指令重排。<br>原因在于某一个线程执行到第一个检测，读取到的 instance 不为 null 时，instance 的引用对象可能没有完成初始化。<br>指令重排只会保证串行语义的执行一致性（单线程），但并不会关心多线程间的语义一致性。<br>所以当一条线程访问 instance 不为 null 时，由于 instance 实例未必已初始化完成，也就造成了线程安全问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;谈谈你对-volatile-的理解&quot;&gt;&lt;a href=&quot;#谈谈你对-volatile-的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对 volatile 的理解&quot;&gt;&lt;/a&gt;谈谈你对 volatile 的理解&lt;/h2&gt;&lt;p&gt;volatile 是
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 线程池知识点</title>
    <link href="https://yapengren.github.io/wiki/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/java-线程池知识点/</id>
    <published>2019-08-19T07:33:15.000Z</published>
    <updated>2019-08-25T02:16:53.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么用线程池，优势"><a href="#为什么用线程池，优势" class="headerlink" title="为什么用线程池，优势"></a>为什么用线程池，优势</h2><p>线程池主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>主要特点是：线程复用、控制最大并发数、管理线程。</p><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h2 id="线程池如何使用"><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h2><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类。</p><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><ol><li><p>Executors.newFixedThreadPool(int)</p><p>执行长期的任务，性能好很多</p><p>主要特点：</p><ol><li>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue。</li></ol></li><li><p>Executors.newSingleThreadExecutor()</p><p>一个任务一个任务执行的场景</p><p>主要特点：</p><ol><li>创建一个单线程化的线程池，它只会唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li><li>newSingleThread 将 corePoolSize 和 maximumPoolSize 都设置为1，它使用的是LinkedBlockingQueue。</li></ol></li><li><p>Executors.newCachedThreadPool()</p><p>适用：执行很多短期异步的小程序或者负载较轻的服务器</p><p>主要特点：</p><ol><li><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p></li><li><p>newCachedThreadPool 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过 60 秒，就销毁线程。</p></li></ol></li></ol><h3 id="阿里巴巴-java-开发规范"><a href="#阿里巴巴-java-开发规范" class="headerlink" title="阿里巴巴 java 开发规范"></a>阿里巴巴 java 开发规范</h3><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下：</p><ol><li>FixedThreadPool 和 SingleThreadPool：<br>允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool：<br>允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM。</li></ol><h2 id="线程池的几个重要参数介绍"><a href="#线程池的几个重要参数介绍" class="headerlink" title="线程池的几个重要参数介绍"></a>线程池的几个重要参数介绍</h2><ol><li><h3 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h3></li></ol><p>线程池中的常驻核心线程数</p><p>  在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程。<br>  当线程池中的线程数目到达 corePoolSize 后，就会把到达的任务放到缓存队列当中。</p><ol start="2"><li><h3 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h3></li></ol><p>线程池能够容纳同时执行的最大线程数，此值必须大于等于1.</p><ol start="3"><li><h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3></li></ol><p>多余的空闲线程的存活时间。当前线程池数量超过 corePoolSize 时，当空闲时间达到 keepAliveTime 值时，多余空闲线程会被销毁直到只剩下 corePoolSize 个线程为止。</p><p>默认情况下：<br>只有当线程池中的线程数大于 corePoolSize 时 keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize。</p><ol start="4"><li><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3></li></ol><p>keepAliveTime 的单位</p><ol start="5"><li><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3></li></ol><p>任务队列，被提交但尚未被执行的任务。</p><ol start="6"><li><h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3></li></ol><p>表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。</p><ol start="7"><li><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3></li></ol><p>拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数。</p><h2 id="线程池的底层工作原理？"><a href="#线程池的底层工作原理？" class="headerlink" title="线程池的底层工作原理？"></a>线程池的底层工作原理？</h2><ol><li><p>在创建了线程池后，等待提交过来的任务请求。</p></li><li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p><ol><li>如果正在运行的线程数量 &lt; corePoolSize，那么马上创建线程运行这个任务。</li><li>如果正在运行的线程数量 &gt;= corePoolSize，那么将这个任务放入队列。</li><li>如果这个时候队列满了且正在运行的线程数量还 &lt; maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务。</li><li>如果队列满了且正在运行的线程数量 &gt;= maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li></ol></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p></li><li><p>当一个线程无事可做超过一定的时间 (keepAliveTime) 时，线程池会判断：</p><p>如果当前运行的线程数 &gt; corePoolSize，那么这个线程就被停掉。<br>所以线程池的所有任务完成后它最终会收缩到 corePoolSize 的大小。</p></li></ol><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>等待队列也满了，再也塞不下新任务了，同时线程池中的 max 线程也达到了，无法继续为新的任务服务。</p><p>这时候就需要拒绝策略机制合理的处理这个问题。</p><h3 id="JDK-内置的拒绝策略"><a href="#JDK-内置的拒绝策略" class="headerlink" title="JDK 内置的拒绝策略"></a>JDK 内置的拒绝策略</h3><ol><li>AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常阻止系统正常运行。</li><li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案。</li></ol><p>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口</p><h2 id="合理配置线程池你是如何考虑的？"><a href="#合理配置线程池你是如何考虑的？" class="headerlink" title="合理配置线程池你是如何考虑的？"></a>合理配置线程池你是如何考虑的？</h2><h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><p>CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</p><p>CPU 密集型任务配置尽可能少的线程数量：</p><p>一般公式为：<strong>CPU 核数 + 1个线程</strong>的线程池。</p><h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><ol><li>由于 IO 密集型任务线程并不是一直执行任务，则应配置尽可能多的线程，如 <strong>CPU 核数 * 2</strong>        </li><li>IO 密集型，即该任务需要大量的 IO，即大量的阻塞。</li></ol><p>在单线程上运行 IO 密集型的任务会导致浪费大量的 CPU 运算能力浪费在等待。</p><p>所以 IO 密集型任务中使用多线程可以大大的加速程序运行，即使在单核 CPU 上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO 密集型时，大部分线程都阻塞，故需要多配置线程数：</p><p>参考公式：<strong>CPU 核数 / (1 - 阻塞系数)</strong>    阻塞系数在 0.8-0.9 之间</p><p>比如 8 核 CPU：8 / (1 - 0.9) = 80 个线程数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么用线程池，优势&quot;&gt;&lt;a href=&quot;#为什么用线程池，优势&quot; class=&quot;headerlink&quot; title=&quot;为什么用线程池，优势&quot;&gt;&lt;/a&gt;为什么用线程池，优势&lt;/h2&gt;&lt;p&gt;线程池主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Redis 深度历险：核心原理与应用实践</title>
    <link href="https://yapengren.github.io/wiki/Redis-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>https://yapengren.github.io/wiki/Redis-深度历险：核心原理与应用实践/</id>
    <published>2019-08-18T03:26:40.000Z</published>
    <updated>2019-08-19T09:29:42.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础：万丈高楼平地起-——-Redis-基础数据结构"><a href="#基础：万丈高楼平地起-——-Redis-基础数据结构" class="headerlink" title="基础：万丈高楼平地起 —— Redis 基础数据结构"></a>基础：万丈高楼平地起 —— Redis 基础数据结构</h1><p>千里之行，始于足下。本节我们的学习目标是：快速理解并掌握 Redis 的基础知识。</p><p>由于本节内容是 Redis 最简单最容易掌握的知识，如果读者已经很熟悉 Redis 的基础数据结构，从珍惜生命的角度出发，你可以略过本节内容，跳到下一节继续阅读。如果你觉得本节的动画有点晃眼，阅读起来不那么舒服，可以看看作者的另一篇文章<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16" target="_blank" rel="noopener">《Redis 数据结构基础教程》</a>。</p><p>要体验 Redis，我们先从 Redis 安装说起。</p><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><p>体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：</p><ol><li>使用 Docker 安装。</li><li>通过 Github 源码编译。</li><li>直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。</li><li>如果读者懒于安装操作，也可以使用网页版的 <a href="https://link.juejin.im/?target=https%3A%2F%2Ftry.redis.io%2F" target="_blank" rel="noopener">Web Redis</a> 直接体验。</li></ol><p>具体操作如下：</p><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a><strong>Docker 方式</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 拉取 redis 镜像</span><br><span class="line">&gt; docker pull redis</span><br><span class="line"># 运行 redis 容器</span><br><span class="line">&gt; docker run --name myredis -d -p6379:6379 redis</span><br><span class="line"># 执行容器中的 redis-cli，可以直接使用命令行操作 redis</span><br><span class="line">&gt; docker exec -it myredis redis-cli</span><br></pre></td></tr></table></figure><h3 id="Github-源码编译方式"><a href="#Github-源码编译方式" class="headerlink" title="Github 源码编译方式"></a><strong>Github 源码编译方式</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载源码</span><br><span class="line">&gt; git clone --branch 2.8 --depth 1 git@github.com:antirez/redis.git</span><br><span class="line">&gt; cd redis</span><br><span class="line"># 编译</span><br><span class="line">&gt; make</span><br><span class="line">&gt; cd src</span><br><span class="line"># 运行服务器，daemonize表示在后台运行</span><br><span class="line">&gt; ./redis-server --daemonize yes</span><br><span class="line"># 运行命令行</span><br><span class="line">&gt; ./redis-cli</span><br></pre></td></tr></table></figure><h3 id="直接安装方式"><a href="#直接安装方式" class="headerlink" title="直接安装方式"></a><strong>直接安装方式</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mac</span><br><span class="line">&gt; brew install redis</span><br><span class="line"># ubuntu</span><br><span class="line">&gt; apt-get install redis</span><br><span class="line"># redhat</span><br><span class="line">&gt; yum install redis</span><br><span class="line"># 运行客户端</span><br><span class="line">&gt; redis-cli</span><br></pre></td></tr></table></figure><h2 id="Redis-基础数据结构"><a href="#Redis-基础数据结构" class="headerlink" title="Redis 基础数据结构"></a>Redis 基础数据结构</h2><p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。熟练掌握这 5 种基本数据结构的使用是 Redis 知识最基础也最重要的部分，它也是在 Redis 面试题中问到最多的内容。</p><p>本节将带领 Redis 初学者快速通关这 5 种基本数据结构。考虑到 Redis 的命令非常多，这里只选取那些最常见的指令进行讲解，如果有遗漏常见指令，读者可以在评论去留言。</p><h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string (字符串)"></a>string (字符串)</h3><p>字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63ohr8b7dg30b402iq2v.gif" alt="img"></p><p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63orqaky9j30fw04pglg.jpg" alt></p><p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><p><strong>键值对</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">OK</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; exists name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>批量键值对</strong></p><p>可以批量对多个字符串进行读写，节省网络耗时开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set name1 codehole</span><br><span class="line">OK</span><br><span class="line">&gt; set name2 holycoder</span><br><span class="line">OK</span><br><span class="line">&gt; mget name1 name2 name3 # 返回一个列表</span><br><span class="line">1) &quot;codehole&quot;</span><br><span class="line">2) &quot;holycoder&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">&gt; mset name1 boy name2 girl name3 unknown</span><br><span class="line">&gt; mget name1 name2 name3</span><br><span class="line">1) &quot;boy&quot;</span><br><span class="line">2) &quot;girl&quot;</span><br><span class="line">3) &quot;unknown&quot;</span><br></pre></td></tr></table></figure><p><strong>过期和 set 命令扩展</strong></p><p>可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间。不过这个「自动删除」的机制是比较复杂的，如果你感兴趣，可以继续深入阅读第 26 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b4c42405188251b3950d251" target="_blank" rel="noopener">《朝生暮死——过期策略》</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; expire name 5  # 5s 后过期</span><br><span class="line">...  # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setex name 5 codehole  # 5s 后过期，等价于 set+expire</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">... # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setnx name codehole  # 如果 name 不存在就执行 set 创建</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; setnx name holycoder</span><br><span class="line">(integer) 0  # 因为 name 已经存在，所以 set 创建不成功</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;  # 没有改变</span><br></pre></td></tr></table></figure><p><strong>计数</strong></p><p>如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set age 30</span><br><span class="line">OK</span><br><span class="line">&gt; incr age</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; incrby age 5</span><br><span class="line">(integer) 36</span><br><span class="line">&gt; incrby age -5</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; set codehole 9223372036854775807  # Long.Max</span><br><span class="line">OK</span><br><span class="line">&gt; incr codehole</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure><p>字符串是由多个字节组成，每个字节又是由 8 个 bit 组成，如此便可以将一个字符串看成很多 bit 的组合，这便是 bitmap「位图」数据结构，位图的具体使用会放到后面的章节来讲。</p><p>关于字符串的内部结构实现，请阅读第 32 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5af9d96fb9a04f83465ada" target="_blank" rel="noopener">《极度深寒 —— 探索「字符串」内部》</a></p><h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list (列表)"></a>list (列表)</h3><p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。</p><p>当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63ohr0h84g30dg03ctbr.gif" alt="img"></p><p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p><p><strong>右边进左边出：队列</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>右边进右边出：栈</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>慢操作</strong></p><p>lindex 相当于 Java 链表的<code>get(int index)</code>方法，它需要对链表进行遍历，性能随着参数<code>index</code>增大而变差。</p><p>ltrim 和字面上的含义不太一样，个人觉得它叫 lretain(保留) 更合适一些，因为 ltrim 跟的两个参数<code>start_index</code>和<code>end_index</code>定义了一个区间，在这个区间内的值，ltrim 要保留，区间之外统统砍掉。我们可以通过ltrim来实现一个定长的链表，这一点非常有用。</p><p>index 可以为负数，<code>index=-1</code>表示倒数第一个元素，同样<code>index=-2</code>表示倒数第二个元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex books 1  # O(n) 慎用</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange books 0 -1  # 获取所有元素，O(n) 慎用</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 -1 # O(n) 慎用</span><br><span class="line">OK</span><br><span class="line">&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负</span><br><span class="line">OK</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>快速列表</strong></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g63ow88g0aj30zk03dmx3.jpg" alt></p><p>如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 <code>linkedlist</code>，而是称之为快速链表 <code>quicklist</code> 的一个结构。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <code>ziplist</code>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 <code>quicklist</code>。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 <code>int</code> 类型的数据，结构上还需要两个额外的指针 <code>prev</code> 和 <code>next</code> 。所以 Redis 将链表和 <code>ziplist</code> 结合起来组成了 <code>quicklist</code>。也就是将多个 <code>ziplist</code> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p>关于列表的内部结构实现，请阅读第 34 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5c95226fb9a04fa42fc3f6" target="_blank" rel="noopener">《极度深寒 —— 探索「压缩列表」内部》</a>和第 35 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5c963be51d45199154e82e" target="_blank" rel="noopener">《极度深寒 —— 探索「快速列表」内部》</a></p><h3 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash (字典)"></a>hash (字典)</h3><p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63owu2opfj30g307pa9x.jpg" alt></p><p>不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g63ox5vprqj30zk09rt8u.jpg" alt></p><p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。</p><p>当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g63ohrt97jg30ci04gtb5.gif" alt="img"></p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</p><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hset books java &quot;think in java&quot;  # 命令行的字符串如果包含空格，要用引号括起来</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books golang &quot;concurrency in go&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books python &quot;python cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hgetall books  # entries()，key 和 value 间隔出现</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;concurrency in go&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;python cookbook&quot;</span><br><span class="line">&gt; hlen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; hget books java</span><br><span class="line">&quot;think in java&quot;</span><br><span class="line">&gt; hset books golang &quot;learning go programming&quot;  # 因为是更新操作，所以返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; hget books golang</span><br><span class="line">&quot;learning go programming&quot;</span><br><span class="line">&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot;  # 批量 set</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>同字符串对象一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 <code>hincrby</code>，和 <code>incr</code>使用基本一样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 老钱又老了一岁</span><br><span class="line">&gt; hincrby user-laoqian age 1</span><br><span class="line">(integer) 30</span><br></pre></td></tr></table></figure><p>关于字典的内部结构实现，请阅读第 33 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5bdbbd5188251ac22b5bf7" target="_blank" rel="noopener">《极度深寒 —— 探索「字典」内部》</a>。</p><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set (集合)"></a>set (集合)</h3><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值<code>NULL</code>。</p><p>当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g63ohqudedg30dg05kn0c.gif" alt="img"></p><p>set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sadd books python</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd books python  #  重复</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sadd books java golang</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; smembers books  # 注意顺序，和插入的并不一致，因为 set 是无序的</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; sismember books java  # 查询某个 value 是否存在，相当于 contains(o)</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember books rust</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; scard books  # 获取长度相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; spop books  # 弹出一个</span><br><span class="line">&quot;java&quot;</span><br></pre></td></tr></table></figure><h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset (有序集合)"></a>zset (有序集合)</h3><p>zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。</p><p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g63ohss9pag30b404g0ub.gif" alt="img"></p><p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。</p><p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; zadd books 9.0 &quot;think in java&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.9 &quot;java concurrency&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.6 &quot;java cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1  # 按 score 排序列出，参数区间为排名范围</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;think in java&quot;</span><br><span class="line">&gt; zrevrange books 0 -1  # 按 score 逆序列出，参数区间为排名范围</span><br><span class="line">1) &quot;think in java&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;java cookbook&quot;</span><br><span class="line">&gt; zcard books  # 相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zscore books &quot;java concurrency&quot;  # 获取指定 value 的 score</span><br><span class="line">&quot;8.9000000000000004&quot;  # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line">&gt; zrank books &quot;java concurrency&quot;  # 排名</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrangebyscore books 0 8.91  # 根据分值区间遍历 zset</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;8.5999999999999996&quot;</span><br><span class="line">3) &quot;java concurrency&quot;</span><br><span class="line">4) &quot;8.9000000000000004&quot;</span><br><span class="line">&gt; zrem books &quot;java concurrency&quot;  # 删除 value</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br></pre></td></tr></table></figure><p><strong>跳跃列表</strong></p><p>zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。</p><p>因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g63oycwdpwj30zk0323yh.jpg" alt></p><p>我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p><p>想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。</p><p>跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。</p><p>想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63oymhg7mj30vz069weo.jpg" alt></p><p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。</p><p>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？</p><p>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。</p><p>首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p><p>这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。</p><p>关于跳跃列表的内部结构实现，请阅读第 36 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c" target="_blank" rel="noopener">《极度深寒 —— 探索「跳跃列表」内部结构》</a></p><h2 id="容器型数据结构的通用规则"><a href="#容器型数据结构的通用规则" class="headerlink" title="容器型数据结构的通用规则"></a>容器型数据结构的通用规则</h2><p>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：</p><ol><li><p>create if not exists</p><p>如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。</p></li><li><p>drop if no elements</p><p>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。</p></li></ol><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。</p><p>还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set codehole yoyo</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire codehole 600</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl codehole</span><br><span class="line">(integer) 597</span><br><span class="line">127.0.0.1:6379&gt; set codehole yoyo</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl codehole</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ol><li>如果你是 Java 用户，请定义一个用户信息结构体，然后使用 <code>fastjson</code> 对用户信息对象进行序列化和反序列化，再使用 Jedis 对 Redis 缓存的用户信息进行存和取。</li><li>如果你是 Python 用户，使用内置的 JSON 包就可以了。然后通过 redis-py 来对 Redis 缓存的用户信息进行存和取。</li><li>想想如果要改成用 hash 结构来缓存用户信息，你该如何封装比较合适？</li><li>想想平时还有哪些指令你平时用过而本小节没有提到的？</li><li>回想一下掘金社区的功能模块中分别会使用到哪些数据结构？</li></ol><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F16375188%2Fredis-strings-vs-redis-hashes-to-represent-json-efficiency" target="_blank" rel="noopener">《存结构体信息到底该使用 hash 还是 string？》</a></li></ul><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  《Redis 深度历险：核心原理与应用实践》   作者：钱文品</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础：万丈高楼平地起-——-Redis-基础数据结构&quot;&gt;&lt;a href=&quot;#基础：万丈高楼平地起-——-Redis-基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;基础：万丈高楼平地起 —— Redis 基础数据结构&quot;&gt;&lt;/a&gt;基础：万丈高楼平
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/redis/"/>
    
    
      <category term="redis" scheme="https://yapengren.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码分析</title>
    <link href="https://yapengren.github.io/wiki/HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yapengren.github.io/wiki/HashMap-源码分析/</id>
    <published>2019-08-17T05:45:12.000Z</published>
    <updated>2019-08-19T09:26:39.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g62mklbo1uj30u40cg0tc.jpg" alt="image-20190817134639787"></p><p>在 Java 中，HashMap 的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。</p><p>在添加元素时，会根据 hash 值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p><p>当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。</p><p>数组的查询效率为 O(1)，链表的查询效率是 O(k)，红黑树的查询效率是 O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量为 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量为 2 的 30 次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个桶中的元素 ≥ 8 时进行树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个桶中的元素 ≤ 6 时把树转换成链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当桶的个数达到 64 的时候进行树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组，又叫做桶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为 enterSet() 的缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改次数，用于在迭代的时候执行快速失败策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h4 id="put-K-key-V-value-方法"><a href="#put-K-key-V-value-方法" class="headerlink" title="put(K key, V value) 方法"></a>put(K key, V value) 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 hash(key) 计算出 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，则 hash 值为0，否则调用 key 的 hashCode() 方法</span></span><br><span class="line">    <span class="comment">// 并让高 16 位与整个 hash 异或，这样做是为了使计算出的 hash 更分散</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果桶的数量为 0，则初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 resize() 初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n-1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="comment">// 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 新建一个节点放在桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果桶中已经有元素存在了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果桶中第一个元素的 key 与待插入元素的 key 相同，保存到 e 中用于后续修改 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果第一个元素是树节点，则调用树节点的 putTreeVal 插入元素</span></span><br><span class="line">            e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历这个桶对应的链表，binCount 用于存储链表中元素的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果链表遍历完了都没有找到相同 key 的元素，则 key 对应的元素不存在，则在链表最后插入一个新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入新节点后链表长度 &gt; 8，则判断是否需要树化，因为第一个元素没有加到 binCount 中，所以 -1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果待插入的 key 在链表中找到了，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了对应 key 的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 记录下旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 替换旧值为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里了说明没有找到元素</span></span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 元素数量 +1，判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 没有找到元素返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>计算 key 的 hash 值；</li><li>如果桶（数组）数量为 0，则初始化桶；</li><li>如果 key 所在的桶没有元素，则直接插入；</li><li>如果 key 所在的桶中的第一个元素的 key 与待插入的key相同，说明找到了元素，转后续流程（9）处理；</li><li>如果第一个元素是树节点，则调用树节点的 putTreeVal() 寻找元素或插入树节点；</li><li>如果不是以上三种情况，则遍历桶对应的链表查找 key 是否存在于链表中；</li><li>如果找到了对应 key 的元素，则转后续流程（9）处理；</li><li>如果没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化；</li><li>如果找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值；</li><li>如果插入了元素，则数量加 1 并判断是否需要扩容；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;继承体系&quot;&gt;&lt;a href=&quot;#继承体系&quot; class=&quot;headerlink&quot; title=&quot;继承体系&quot;&gt;&lt;/a&gt;继承体系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g62mklbo1uj30
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList 源码分析</title>
    <link href="https://yapengren.github.io/wiki/ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yapengren.github.io/wiki/ArrayList-源码分析/</id>
    <published>2019-08-17T02:28:42.000Z</published>
    <updated>2019-08-25T02:31:37.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g62gwty9i8j311i0jk0u2.jpg" alt="image-20190817103049755"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量为10，也就是通过 new ArrayList() 创建时的默认容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组</span></span><br><span class="line"><span class="comment"> * 这种是通过 new ArrayList(0) 创建时用的空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组</span></span><br><span class="line"><span class="comment"> * 这种是通过 new ArrayList() 创建时用的空数组</span></span><br><span class="line"><span class="comment"> * 与 EMPTY_ELEMENTDATA 的区别是在添加第一个元素时使用这个空数组会初始化为 DEFAULT_CAPACITY（10）个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存放元素的地方</span></span><br><span class="line"><span class="comment"> * 使用 transient 关键字能不序列化这个字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存放元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h4 id="ArrayList-int-initialCapacity-构造方法"><a href="#ArrayList-int-initialCapacity-构造方法" class="headerlink" title="ArrayList(int initialCapacity) 构造方法"></a>ArrayList(int initialCapacity) 构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量 &gt; 0，新建一个数组存储元素</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量 = 0，使用空数组 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量 &lt; 0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e) 方法"></a>add(E e) 方法</h4><p>添加元素到末尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将元素插入到最后一位</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小 10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的 1.5 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新容量发现比需要的容量还小，则以需要的容量为准</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量已经超过最大容量了，则使用最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 以新容量拷贝出来一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查是否需要扩容；</li><li>如果 elementData 等于 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则初始化容量大小为 DEFAULT_CAPACITY；</li><li>新容量是老容量的1.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；</li><li>创建新容量的数组并把老数组拷贝到新数组；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;继承体系&quot;&gt;&lt;a href=&quot;#继承体系&quot; class=&quot;headerlink&quot; title=&quot;继承体系&quot;&gt;&lt;/a&gt;继承体系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g62gwty9i8j31
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 知识点</title>
    <link href="https://yapengren.github.io/wiki/Dubbo-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Dubbo-知识点/</id>
    <published>2019-08-15T08:54:12.000Z</published>
    <updated>2019-08-18T03:35:04.396Z</updated>
    
    <content type="html"><![CDATA[<p>302</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;302&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="dubbo" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://yapengren.github.io/tags/dubbo/"/>
    
  </entry>
  
</feed>

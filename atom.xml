<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yp_ren Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yapengren.github.io/"/>
  <updated>2019-08-19T02:28:14.636Z</updated>
  <id>https://yapengren.github.io/</id>
  
  <author>
    <name>renyapeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis zset 实现简单限流</title>
    <link href="https://yapengren.github.io/wiki/Redis-zset-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%99%90%E6%B5%81/"/>
    <id>https://yapengren.github.io/wiki/Redis-zset-实现简单限流/</id>
    <published>2019-08-19T01:48:40.000Z</published>
    <updated>2019-08-19T02:28:14.636Z</updated>
    
    <content type="html"><![CDATA[<p>除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。</p><h1 id="如何使用-Redis-来实现简单限流策略？"><a href="#如何使用-Redis-来实现简单限流策略？" class="headerlink" title="如何使用 Redis 来实现简单限流策略？"></a>如何使用 Redis 来实现简单限流策略？</h1><p>首先我们来看一个常见的简单的限流策略。系统要限定用户的某个行为在指定的时间里只能允许发生 N 次，如何使用 Redis 的数据结构来实现这个限流的功能？</p><p>我们先定义这个接口，理解了这个接口的定义，读者就应该能明白我们期望达到的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定用户 user_id 的某个行为 action_key，在特定的时间内 period，只允许发生一定的次数 max_count</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActionAllowed</span><span class="params">(String userId, String actionKey, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个接口，5 分钟之内只能发帖 10 次</span></span><br><span class="line">limiter.isActionAllowed(<span class="string">"xiaoming"</span>, <span class="string">"publish"</span>, <span class="number">5</span> * <span class="number">60</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="错误方案"><a href="#错误方案" class="headerlink" title="错误方案"></a>错误方案</h2><blockquote><p>  将 userId 和 actionKey 拼成 key，在第一次请求时设置 value 为 1，设置过期时间 expire 为特定的时间 period</p><p>  每次请求的时候获取 value 值，若存在则 incr 自增 1，超过 maxCount 则做限制</p></blockquote><h3 id="问题模拟分析"><a href="#问题模拟分析" class="headerlink" title="问题模拟分析"></a>问题模拟分析</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g64rkjcypbj30ym0i80ti.jpg" alt="image-20190818163237023"></p><p>如上图：5 分钟之内只能发帖 10 次。</p><p>11:01 用户发帖 1 次，此时 redis 中存放数据 key 为 <code>userId:actionKey</code>，vlaue 为 1，过期时间 5 分钟；</p><p>11:05 用户发帖 8 次，发帖成功；</p><p>11:05 之后，key 过期时间到，被移除；</p><p>11:06 用户发帖，此时 redis 中 key 不存在，重新存放 key，发帖 8 次，发帖成功；</p><p>那么 11:05 -&gt; 11:06 时间段 2 分钟发帖 16 次，没有达到期望的功能；</p><h2 id="正确方案"><a href="#正确方案" class="headerlink" title="正确方案"></a>正确方案</h2><p>这个限流需求中存在一个滑动时间窗口，想想 zset 数据结构的 score 值，是不是可以通过 score 来圈出这个时间窗口来。而且我们只需要保留这个时间窗口，窗口之外的数据都可以砍掉。那这个 zset 的 value 填什么比较合适呢？它只需要保证唯一性即可，用 uuid 会比较浪费空间，那就改用毫秒时间戳吧。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g64rsbdgrgj30jr0cv3yj.jpg" alt></p><p>如图所示，用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个 key 保存下来。同一个用户同一种行为用一个 zset 记录。</p><p>为节省内存，我们只需要保留时间窗口内的行为记录，同时如果用户是冷用户，滑动时间窗口内的行为是空记录，那么这个 zset 就可以从内存中移除，不再占用空间。</p><p>通过统计滑动窗口内的行为数量与阈值 max_count 进行比较就可以得出当前的行为是否允许。用代码表示如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRateLimiter</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId    用户 user_id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionKey 某个行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period    特定的时间内，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount  最大允许的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActionAllowed</span><span class="params">(String userId, String actionKey, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        String key = String.format(<span class="string">"hist:%s:%s"</span>, userId, actionKey);</span><br><span class="line">        <span class="comment">// 毫秒时间戳</span></span><br><span class="line">        <span class="keyword">long</span> nowTs = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用了multi，也就是事务，能保证一系列指令的原子顺序执行</span></span><br><span class="line">        pipe.multi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放数据，value 和 score 都使用毫秒时间戳</span></span><br><span class="line">        pipe.zadd(key, nowTs, <span class="string">""</span> + nowTs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zremrangebyscore key min max 命令用于移除有序集中，指定分数（score）区间内的所有成员</span></span><br><span class="line">        <span class="comment">// 移除时间窗口之前的数据，剩下的都是时间窗口之内的</span></span><br><span class="line">        Response&lt;Long&gt; longResponse = pipe.zremrangeByScore(key, <span class="number">0</span>, nowTs - period * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于 count()，获取时间窗口内的行为数量</span></span><br><span class="line">        Response&lt;Long&gt; count = pipe.zcard(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 zset 过期时间，避免冷用户持续占用内存</span></span><br><span class="line">        <span class="comment">// 过期时间应该等于时间窗口的长度，再多宽限 1s</span></span><br><span class="line">        pipe.expire(key, period + <span class="number">1</span>);</span><br><span class="line">        pipe.exec();</span><br><span class="line">        pipe.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较数量是否超标</span></span><br><span class="line">        <span class="keyword">return</span> count.get() &lt;= maxCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">        SimpleRateLimiter limiter = <span class="keyword">new</span> SimpleRateLimiter(jedis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(limiter.isActionAllowed(<span class="string">"xiaoming"</span>, <span class="string">"publish"</span>, <span class="number">5</span> * <span class="number">60</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>因为它要记录时间窗口内所有的行为记录，如果这个量很大，比如限定 60s 内操作不得超过 100w 次这样的参数，它是不适合做这样的限流的，因为会消耗大量的存储空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。&lt;/p&gt;
&lt;h1 id=&quot;如何使
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 深度历险：核心原理与应用实践</title>
    <link href="https://yapengren.github.io/wiki/Redis-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>https://yapengren.github.io/wiki/Redis-深度历险：核心原理与应用实践/</id>
    <published>2019-08-18T03:26:40.000Z</published>
    <updated>2019-08-18T04:55:34.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础：万丈高楼平地起-——-Redis-基础数据结构"><a href="#基础：万丈高楼平地起-——-Redis-基础数据结构" class="headerlink" title="基础：万丈高楼平地起 —— Redis 基础数据结构"></a>基础：万丈高楼平地起 —— Redis 基础数据结构</h1><p>千里之行，始于足下。本节我们的学习目标是：快速理解并掌握 Redis 的基础知识。</p><p>由于本节内容是 Redis 最简单最容易掌握的知识，如果读者已经很熟悉 Redis 的基础数据结构，从珍惜生命的角度出发，你可以略过本节内容，跳到下一节继续阅读。如果你觉得本节的动画有点晃眼，阅读起来不那么舒服，可以看看作者的另一篇文章<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16" target="_blank" rel="noopener">《Redis 数据结构基础教程》</a>。</p><p>要体验 Redis，我们先从 Redis 安装说起。</p><h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><p>体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：</p><ol><li>使用 Docker 安装。</li><li>通过 Github 源码编译。</li><li>直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。</li><li>如果读者懒于安装操作，也可以使用网页版的 <a href="https://link.juejin.im/?target=https%3A%2F%2Ftry.redis.io%2F" target="_blank" rel="noopener">Web Redis</a> 直接体验。</li></ol><p>具体操作如下：</p><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a><strong>Docker 方式</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 拉取 redis 镜像</span><br><span class="line">&gt; docker pull redis</span><br><span class="line"># 运行 redis 容器</span><br><span class="line">&gt; docker run --name myredis -d -p6379:6379 redis</span><br><span class="line"># 执行容器中的 redis-cli，可以直接使用命令行操作 redis</span><br><span class="line">&gt; docker exec -it myredis redis-cli</span><br></pre></td></tr></table></figure><h3 id="Github-源码编译方式"><a href="#Github-源码编译方式" class="headerlink" title="Github 源码编译方式"></a><strong>Github 源码编译方式</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载源码</span><br><span class="line">&gt; git clone --branch 2.8 --depth 1 git@github.com:antirez/redis.git</span><br><span class="line">&gt; cd redis</span><br><span class="line"># 编译</span><br><span class="line">&gt; make</span><br><span class="line">&gt; cd src</span><br><span class="line"># 运行服务器，daemonize表示在后台运行</span><br><span class="line">&gt; ./redis-server --daemonize yes</span><br><span class="line"># 运行命令行</span><br><span class="line">&gt; ./redis-cli</span><br></pre></td></tr></table></figure><h3 id="直接安装方式"><a href="#直接安装方式" class="headerlink" title="直接安装方式"></a><strong>直接安装方式</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mac</span><br><span class="line">&gt; brew install redis</span><br><span class="line"># ubuntu</span><br><span class="line">&gt; apt-get install redis</span><br><span class="line"># redhat</span><br><span class="line">&gt; yum install redis</span><br><span class="line"># 运行客户端</span><br><span class="line">&gt; redis-cli</span><br></pre></td></tr></table></figure><h2 id="Redis-基础数据结构"><a href="#Redis-基础数据结构" class="headerlink" title="Redis 基础数据结构"></a>Redis 基础数据结构</h2><p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。熟练掌握这 5 种基本数据结构的使用是 Redis 知识最基础也最重要的部分，它也是在 Redis 面试题中问到最多的内容。</p><p>本节将带领 Redis 初学者快速通关这 5 种基本数据结构。考虑到 Redis 的命令非常多，这里只选取那些最常见的指令进行讲解，如果有遗漏常见指令，读者可以在评论去留言。</p><h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string (字符串)"></a>string (字符串)</h3><p>字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63ohr8b7dg30b402iq2v.gif" alt="img"></p><p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63orqaky9j30fw04pglg.jpg" alt></p><p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><p><strong>键值对</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">OK</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; exists name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>批量键值对</strong></p><p>可以批量对多个字符串进行读写，节省网络耗时开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set name1 codehole</span><br><span class="line">OK</span><br><span class="line">&gt; set name2 holycoder</span><br><span class="line">OK</span><br><span class="line">&gt; mget name1 name2 name3 # 返回一个列表</span><br><span class="line">1) &quot;codehole&quot;</span><br><span class="line">2) &quot;holycoder&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">&gt; mset name1 boy name2 girl name3 unknown</span><br><span class="line">&gt; mget name1 name2 name3</span><br><span class="line">1) &quot;boy&quot;</span><br><span class="line">2) &quot;girl&quot;</span><br><span class="line">3) &quot;unknown&quot;</span><br></pre></td></tr></table></figure><p><strong>过期和 set 命令扩展</strong></p><p>可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间。不过这个「自动删除」的机制是比较复杂的，如果你感兴趣，可以继续深入阅读第 26 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b4c42405188251b3950d251" target="_blank" rel="noopener">《朝生暮死——过期策略》</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; expire name 5  # 5s 后过期</span><br><span class="line">...  # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setex name 5 codehole  # 5s 后过期，等价于 set+expire</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">... # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setnx name codehole  # 如果 name 不存在就执行 set 创建</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; setnx name holycoder</span><br><span class="line">(integer) 0  # 因为 name 已经存在，所以 set 创建不成功</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;  # 没有改变</span><br></pre></td></tr></table></figure><p><strong>计数</strong></p><p>如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set age 30</span><br><span class="line">OK</span><br><span class="line">&gt; incr age</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; incrby age 5</span><br><span class="line">(integer) 36</span><br><span class="line">&gt; incrby age -5</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; set codehole 9223372036854775807  # Long.Max</span><br><span class="line">OK</span><br><span class="line">&gt; incr codehole</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure><p>字符串是由多个字节组成，每个字节又是由 8 个 bit 组成，如此便可以将一个字符串看成很多 bit 的组合，这便是 bitmap「位图」数据结构，位图的具体使用会放到后面的章节来讲。</p><p>关于字符串的内部结构实现，请阅读第 32 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5af9d96fb9a04f83465ada" target="_blank" rel="noopener">《极度深寒 —— 探索「字符串」内部》</a></p><h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list (列表)"></a>list (列表)</h3><p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。</p><p>当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63ohr0h84g30dg03ctbr.gif" alt="img"></p><p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p><p><strong>右边进左边出：队列</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>右边进右边出：栈</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>慢操作</strong></p><p>lindex 相当于 Java 链表的<code>get(int index)</code>方法，它需要对链表进行遍历，性能随着参数<code>index</code>增大而变差。</p><p>ltrim 和字面上的含义不太一样，个人觉得它叫 lretain(保留) 更合适一些，因为 ltrim 跟的两个参数<code>start_index</code>和<code>end_index</code>定义了一个区间，在这个区间内的值，ltrim 要保留，区间之外统统砍掉。我们可以通过ltrim来实现一个定长的链表，这一点非常有用。</p><p>index 可以为负数，<code>index=-1</code>表示倒数第一个元素，同样<code>index=-2</code>表示倒数第二个元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex books 1  # O(n) 慎用</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange books 0 -1  # 获取所有元素，O(n) 慎用</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 -1 # O(n) 慎用</span><br><span class="line">OK</span><br><span class="line">&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负</span><br><span class="line">OK</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>快速列表</strong></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g63ow88g0aj30zk03dmx3.jpg" alt></p><p>如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 <code>linkedlist</code>，而是称之为快速链表 <code>quicklist</code> 的一个结构。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <code>ziplist</code>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 <code>quicklist</code>。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 <code>int</code> 类型的数据，结构上还需要两个额外的指针 <code>prev</code> 和 <code>next</code> 。所以 Redis 将链表和 <code>ziplist</code> 结合起来组成了 <code>quicklist</code>。也就是将多个 <code>ziplist</code> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p>关于列表的内部结构实现，请阅读第 34 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5c95226fb9a04fa42fc3f6" target="_blank" rel="noopener">《极度深寒 —— 探索「压缩列表」内部》</a>和第 35 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5c963be51d45199154e82e" target="_blank" rel="noopener">《极度深寒 —— 探索「快速列表」内部》</a></p><h3 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash (字典)"></a>hash (字典)</h3><p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63owu2opfj30g307pa9x.jpg" alt></p><p>不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g63ox5vprqj30zk09rt8u.jpg" alt></p><p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。</p><p>当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g63ohrt97jg30ci04gtb5.gif" alt="img"></p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</p><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hset books java &quot;think in java&quot;  # 命令行的字符串如果包含空格，要用引号括起来</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books golang &quot;concurrency in go&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books python &quot;python cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hgetall books  # entries()，key 和 value 间隔出现</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;concurrency in go&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;python cookbook&quot;</span><br><span class="line">&gt; hlen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; hget books java</span><br><span class="line">&quot;think in java&quot;</span><br><span class="line">&gt; hset books golang &quot;learning go programming&quot;  # 因为是更新操作，所以返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; hget books golang</span><br><span class="line">&quot;learning go programming&quot;</span><br><span class="line">&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot;  # 批量 set</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>同字符串对象一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 <code>hincrby</code>，和 <code>incr</code>使用基本一样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 老钱又老了一岁</span><br><span class="line">&gt; hincrby user-laoqian age 1</span><br><span class="line">(integer) 30</span><br></pre></td></tr></table></figure><p>关于字典的内部结构实现，请阅读第 33 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5bdbbd5188251ac22b5bf7" target="_blank" rel="noopener">《极度深寒 —— 探索「字典」内部》</a>。</p><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set (集合)"></a>set (集合)</h3><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值<code>NULL</code>。</p><p>当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g63ohqudedg30dg05kn0c.gif" alt="img"></p><p>set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sadd books python</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd books python  #  重复</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sadd books java golang</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; smembers books  # 注意顺序，和插入的并不一致，因为 set 是无序的</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; sismember books java  # 查询某个 value 是否存在，相当于 contains(o)</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember books rust</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; scard books  # 获取长度相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; spop books  # 弹出一个</span><br><span class="line">&quot;java&quot;</span><br></pre></td></tr></table></figure><h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset (有序集合)"></a>zset (有序集合)</h3><p>zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。</p><p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g63ohss9pag30b404g0ub.gif" alt="img"></p><p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。</p><p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; zadd books 9.0 &quot;think in java&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.9 &quot;java concurrency&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.6 &quot;java cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1  # 按 score 排序列出，参数区间为排名范围</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;think in java&quot;</span><br><span class="line">&gt; zrevrange books 0 -1  # 按 score 逆序列出，参数区间为排名范围</span><br><span class="line">1) &quot;think in java&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;java cookbook&quot;</span><br><span class="line">&gt; zcard books  # 相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zscore books &quot;java concurrency&quot;  # 获取指定 value 的 score</span><br><span class="line">&quot;8.9000000000000004&quot;  # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line">&gt; zrank books &quot;java concurrency&quot;  # 排名</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrangebyscore books 0 8.91  # 根据分值区间遍历 zset</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;8.5999999999999996&quot;</span><br><span class="line">3) &quot;java concurrency&quot;</span><br><span class="line">4) &quot;8.9000000000000004&quot;</span><br><span class="line">&gt; zrem books &quot;java concurrency&quot;  # 删除 value</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br></pre></td></tr></table></figure><p><strong>跳跃列表</strong></p><p>zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。</p><p>因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g63oycwdpwj30zk0323yh.jpg" alt></p><p>我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p><p>想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。</p><p>跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。</p><p>想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g63oymhg7mj30vz069weo.jpg" alt></p><p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。</p><p>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？</p><p>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。</p><p>首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p><p>这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。</p><p>关于跳跃列表的内部结构实现，请阅读第 36 节<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c" target="_blank" rel="noopener">《极度深寒 —— 探索「跳跃列表」内部结构》</a></p><h2 id="容器型数据结构的通用规则"><a href="#容器型数据结构的通用规则" class="headerlink" title="容器型数据结构的通用规则"></a>容器型数据结构的通用规则</h2><p>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：</p><ol><li><p>create if not exists</p><p>如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。</p></li><li><p>drop if no elements</p><p>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。</p></li></ol><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。</p><p>还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set codehole yoyo</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire codehole 600</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl codehole</span><br><span class="line">(integer) 597</span><br><span class="line">127.0.0.1:6379&gt; set codehole yoyo</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl codehole</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ol><li>如果你是 Java 用户，请定义一个用户信息结构体，然后使用 <code>fastjson</code> 对用户信息对象进行序列化和反序列化，再使用 Jedis 对 Redis 缓存的用户信息进行存和取。</li><li>如果你是 Python 用户，使用内置的 JSON 包就可以了。然后通过 redis-py 来对 Redis 缓存的用户信息进行存和取。</li><li>想想如果要改成用 hash 结构来缓存用户信息，你该如何封装比较合适？</li><li>想想平时还有哪些指令你平时用过而本小节没有提到的？</li><li>回想一下掘金社区的功能模块中分别会使用到哪些数据结构？</li></ol><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F16375188%2Fredis-strings-vs-redis-hashes-to-represent-json-efficiency" target="_blank" rel="noopener">《存结构体信息到底该使用 hash 还是 string？》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础：万丈高楼平地起-——-Redis-基础数据结构&quot;&gt;&lt;a href=&quot;#基础：万丈高楼平地起-——-Redis-基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;基础：万丈高楼平地起 —— Redis 基础数据结构&quot;&gt;&lt;/a&gt;基础：万丈高楼平
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/redis/"/>
    
    
      <category term="redis" scheme="https://yapengren.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码分析</title>
    <link href="https://yapengren.github.io/wiki/HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yapengren.github.io/wiki/HashMap-源码分析/</id>
    <published>2019-08-17T05:45:12.000Z</published>
    <updated>2019-08-18T03:35:27.905Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g62mklbo1uj30u40cg0tc.jpg" alt="image-20190817134639787"></p><p>在 Java 中，HashMap 的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。</p><p>在添加元素时，会根据 hash 值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p><p>当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。</p><p>数组的查询效率为 O(1)，链表的查询效率是 O(k)，红黑树的查询效率是 O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量为 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量为 2 的 30 次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个桶中的元素 ≥ 8 时进行树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个桶中的元素 ≤ 6 时把树转换成链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当桶的个数达到 64 的时候进行树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组，又叫做桶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为 enterSet() 的缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改次数，用于在迭代的时候执行快速失败策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h4 id="put-K-key-V-value-方法"><a href="#put-K-key-V-value-方法" class="headerlink" title="put(K key, V value) 方法"></a>put(K key, V value) 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 hash(key) 计算出 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，则 hash 值为0，否则调用 key 的 hashCode() 方法</span></span><br><span class="line">    <span class="comment">// 并让高 16 位与整个 hash 异或，这样做是为了使计算出的 hash 更分散</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果桶的数量为 0，则初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 resize() 初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n-1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="comment">// 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 新建一个节点放在桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果桶中已经有元素存在了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果桶中第一个元素的 key 与待插入元素的 key 相同，保存到 e 中用于后续修改 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果第一个元素是树节点，则调用树节点的 putTreeVal 插入元素</span></span><br><span class="line">            e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历这个桶对应的链表，binCount 用于存储链表中元素的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果链表遍历完了都没有找到相同 key 的元素，则 key 对应的元素不存在，则在链表最后插入一个新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入新节点后链表长度 &gt; 8，则判断是否需要树化，因为第一个元素没有加到 binCount 中，所以 -1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果待插入的 key 在链表中找到了，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了对应 key 的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 记录下旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 替换旧值为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里了说明没有找到元素</span></span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 元素数量 +1，判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 没有找到元素返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>计算 key 的 hash 值；</li><li>如果桶（数组）数量为 0，则初始化桶；</li><li>如果 key 所在的桶没有元素，则直接插入；</li><li>如果 key 所在的桶中的第一个元素的 key 与待插入的key相同，说明找到了元素，转后续流程（9）处理；</li><li>如果第一个元素是树节点，则调用树节点的 putTreeVal() 寻找元素或插入树节点；</li><li>如果不是以上三种情况，则遍历桶对应的链表查找 key 是否存在于链表中；</li><li>如果找到了对应 key 的元素，则转后续流程（9）处理；</li><li>如果没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化；</li><li>如果找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值；</li><li>如果插入了元素，则数量加 1 并判断是否需要扩容；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;继承体系&quot;&gt;&lt;a href=&quot;#继承体系&quot; class=&quot;headerlink&quot; title=&quot;继承体系&quot;&gt;&lt;/a&gt;继承体系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g62mklbo1uj30
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList 源码分析</title>
    <link href="https://yapengren.github.io/wiki/ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yapengren.github.io/wiki/ArrayList-源码分析/</id>
    <published>2019-08-17T02:28:42.000Z</published>
    <updated>2019-08-18T03:34:30.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g62gwty9i8j311i0jk0u2.jpg" alt="image-20190817103049755"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量为10，也就是通过 new ArrayList() 创建时的默认容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组</span></span><br><span class="line"><span class="comment"> * 这种是通过 new ArrayList(0) 创建时用的空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组</span></span><br><span class="line"><span class="comment"> * 这种是通过 new ArrayList() 创建时用的空数组</span></span><br><span class="line"><span class="comment"> * 与 EMPTY_ELEMENTDATA 的区别是在添加第一个元素时使用这个空数组会初始化为 DEFAULT_CAPACITY（10）个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存放元素的地方</span></span><br><span class="line"><span class="comment"> * 使用 transient 关键字能不序列化这个字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存放元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h4 id="ArrayList-int-initialCapacity-构造方法"><a href="#ArrayList-int-initialCapacity-构造方法" class="headerlink" title="ArrayList(int initialCapacity) 构造方法"></a>ArrayList(int initialCapacity) 构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量 &gt; 0，新建一个数组存储元素</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量 = 0，使用空数组 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量 &lt; 0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e) 方法"></a>add(E e) 方法</h4><p>添加元素到末尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将元素插入到最后一位</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小 10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的 1.5 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新容量发现比需要的容量还小，则以需要的容量为准</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量已经超过最大容量了，则使用最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 以新容量拷贝出来一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查是否需要扩容；</li><li>如果 elementData 等于 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则初始化容量大小为 DEFAULT_CAPACITY；</li><li>新容量是老容量的1.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为；</li><li>创建新容量的数组并把老数组拷贝到新数组；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;继承体系&quot;&gt;&lt;a href=&quot;#继承体系&quot; class=&quot;headerlink&quot; title=&quot;继承体系&quot;&gt;&lt;/a&gt;继承体系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g62gwty9i8j31
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 知识点</title>
    <link href="https://yapengren.github.io/wiki/Dubbo-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Dubbo-知识点/</id>
    <published>2019-08-15T08:54:12.000Z</published>
    <updated>2019-08-18T03:35:04.396Z</updated>
    
    <content type="html"><![CDATA[<p>302</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;302&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="dubbo" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://yapengren.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis 知识点</title>
    <link href="https://yapengren.github.io/wiki/Mybatis-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Mybatis-知识点/</id>
    <published>2019-08-14T09:20:15.000Z</published>
    <updated>2019-08-18T03:36:17.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MyBatis-中-resultType-和-resultMap-的区别"><a href="#MyBatis-中-resultType-和-resultMap-的区别" class="headerlink" title="MyBatis 中 resultType 和 resultMap 的区别"></a><a href="https://www.cnblogs.com/coder-lzh/p/8960928.html" target="_blank" rel="noopener">MyBatis 中 resultType 和 resultMap 的区别</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MyBatis-中-resultType-和-resultMap-的区别&quot;&gt;&lt;a href=&quot;#MyBatis-中-resultType-和-resultMap-的区别&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 中 resultType
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="mybatis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/mybatis/"/>
    
    
      <category term="mybatis" scheme="https://yapengren.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说说</title>
    <link href="https://yapengren.github.io/wiki/synchronized-%E5%92%8C-lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%94%A8%E6%96%B0%E7%9A%84lock%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E8%AF%B4/"/>
    <id>https://yapengren.github.io/wiki/synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说说/</id>
    <published>2019-08-04T06:32:36.000Z</published>
    <updated>2019-08-18T03:37:04.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原始构成"><a href="#原始构成" class="headerlink" title="原始构成"></a>原始构成</h3><ul><li><p>synchronized 是关键字，属于JVM层面</p><ul><li><p>monitorenter（底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象只有在同步块或者方法中才能调用 wait/notify 等方法）</p></li><li><p>monitorexit</p></li></ul></li><li><p>Lock 是具体类（java.util.concurrent.locks.lock）是api层面的锁</p></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li><p>synchronized 不需要用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。</p></li><li><p>ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象。需要 lock() 和unlock() 方法配合 try/finally 语句块来完成。</p></li></ul><h3 id="等待是否可中断"><a href="#等待是否可中断" class="headerlink" title="等待是否可中断"></a>等待是否可中断</h3><ul><li><p>synchronized 不可中断，除非抛出异常或者正常运行完成。</p></li><li><p>ReentrantLock可中断</p><ul><li>1.设置超时方法 tryLock(long timeout,TimeUnit unit)</li><li>2.lockInterruptibly()放代码块中，调用interrupt()方法可中断</li></ul></li></ul><h3 id="加锁是否公平"><a href="#加锁是否公平" class="headerlink" title="加锁是否公平"></a>加锁是否公平</h3><ul><li><p>synchronized 非公平锁</p></li><li><p>ReentrantLock 两者都可以，默认非公平锁，构造方法可以传入 boolean 值，true为公平锁，false为非公平锁</p></li></ul><h3 id="锁绑定多个条件-Condition"><a href="#锁绑定多个条件-Condition" class="headerlink" title="锁绑定多个条件 Condition"></a>锁绑定多个条件 Condition</h3><ul><li>synchronized 没有</li></ul><ul><li>ReentrantLock 用来实现分组唤醒需要唤醒的线程，可以<strong>精确唤醒</strong>，而不是像 synchronized 要么随机唤醒一个要么唤醒全部线程。</li></ul><h3 id="举例：锁绑定多个条件-Condition"><a href="#举例：锁绑定多个条件-Condition" class="headerlink" title="举例：锁绑定多个条件 Condition"></a>举例：锁绑定多个条件 Condition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * A打印5次，B打印10次，C打印15次</span></span><br><span class="line"><span class="comment"> * 紧接着</span></span><br><span class="line"><span class="comment"> * A打印5次，B打印10次，C打印15次</span></span><br><span class="line"><span class="comment"> * 打印10轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockdemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原始构成&quot;&gt;&lt;a href=&quot;#原始构成&quot; class=&quot;headerlink&quot; title=&quot;原始构成&quot;&gt;&lt;/a&gt;原始构成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;synchronized 是关键字，属于JVM层面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;monitorente
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="https://yapengren.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java hash 原理</title>
    <link href="https://yapengren.github.io/wiki/java-hash-%E5%8E%9F%E7%90%86/"/>
    <id>https://yapengren.github.io/wiki/java-hash-原理/</id>
    <published>2019-08-04T05:23:50.000Z</published>
    <updated>2019-08-18T03:35:48.544Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5nkvcllvaj318c0mqt9z.jpg" alt="88FE31C1-3E38-4DC9-A207-96016AA72F1F"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5nkvcllvaj318c0mqt9z.jpg&quot; alt=&quot;88FE31C1-3E38-4DC9-A207-96016AA72F1F&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>让我们同步进阶</title>
    <link href="https://yapengren.github.io/wiki/%E8%AE%A9%E6%88%91%E4%BB%AC%E5%90%8C%E6%AD%A5%E8%BF%9B%E9%98%B6/"/>
    <id>https://yapengren.github.io/wiki/让我们同步进阶/</id>
    <published>2019-08-04T05:18:18.000Z</published>
    <updated>2019-08-06T07:51:19.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h3><p><a href="http://cmsblogs.com/" target="_blank" rel="noopener">Java技术驿站</a></p><p><a href="https://cyc2018.github.io/CS-Notes/" target="_blank" rel="noopener">CS-Notes</a></p><p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></p><h3 id="架构知识点"><a href="#架构知识点" class="headerlink" title="架构知识点"></a>架构知识点</h3><p><a href="https://doocs.github.io/advanced-java" target="_blank" rel="noopener">互联网 java 工程师进阶知识完全扫盲</a></p><h3 id="spring-boot-amp-cloud"><a href="#spring-boot-amp-cloud" class="headerlink" title="spring boot &amp; cloud"></a>spring boot &amp; cloud</h3><p><a href="http://blog.didispace.com/spring-cloud-learning/" target="_blank" rel="noopener">Spring Cloud 程序猿DD</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识点&quot;&gt;&lt;a href=&quot;#基础知识点&quot; class=&quot;headerlink&quot; title=&quot;基础知识点&quot;&gt;&lt;/a&gt;基础知识点&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://cmsblogs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis 知识点</title>
    <link href="https://yapengren.github.io/wiki/redis-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/redis-知识点/</id>
    <published>2019-08-04T05:12:21.000Z</published>
    <updated>2019-08-18T03:36:36.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis用过哪些数据数据，以及Redis底层怎么实现"><a href="#Redis用过哪些数据数据，以及Redis底层怎么实现" class="headerlink" title="Redis用过哪些数据数据，以及Redis底层怎么实现"></a>Redis用过哪些数据数据，以及Redis底层怎么实现</h3><p>string, hash, list, set, zset</p><h3 id="Redis缓存穿透，缓存雪崩"><a href="#Redis缓存穿透，缓存雪崩" class="headerlink" title="Redis缓存穿透，缓存雪崩"></a><a href="https://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">Redis缓存穿透，缓存雪崩</a></h3><h3 id="如何使用Redis来实现分布式锁"><a href="#如何使用Redis来实现分布式锁" class="headerlink" title="如何使用Redis来实现分布式锁"></a><a href="https://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">如何使用Redis来实现分布式锁</a></h3><h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决"></a><a href="https://blog.csdn.net/hjm4702192/article/details/80518856" target="_blank" rel="noopener">Redis的并发竞争问题如何解决</a></h3><h3 id="Redis持久化的几种方式，优缺点是什么，怎么实现的"><a href="#Redis持久化的几种方式，优缺点是什么，怎么实现的" class="headerlink" title="Redis持久化的几种方式，优缺点是什么，怎么实现的"></a><a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">Redis持久化的几种方式，优缺点是什么，怎么实现的</a></h3><h3 id="aof-文件太大会怎么样"><a href="#aof-文件太大会怎么样" class="headerlink" title="aof 文件太大会怎么样"></a><a href="https://www.cnblogs.com/xingzc/p/6384677.html" target="_blank" rel="noopener">aof 文件太大会怎么样</a></h3><h3 id="Redis的缓存失效策略-amp-最大缓存策略"><a href="#Redis的缓存失效策略-amp-最大缓存策略" class="headerlink" title="Redis的缓存失效策略 &amp; 最大缓存策略"></a><a href="https://www.cnblogs.com/moonandstar08/p/5686498.html" target="_blank" rel="noopener">Redis的缓存失效策略 &amp; 最大缓存策略</a></h3><h3 id="Redis集群，高可用，原理"><a href="#Redis集群，高可用，原理" class="headerlink" title="Redis集群，高可用，原理"></a>Redis集群，高可用，原理</h3><h3 id="Redis缓存分片"><a href="#Redis缓存分片" class="headerlink" title="Redis缓存分片"></a><a href="https://www.cnblogs.com/shiw27/p/8360485.html" target="_blank" rel="noopener">Redis缓存分片</a></h3><h3 id="Redis的数据淘汰策略"><a href="#Redis的数据淘汰策略" class="headerlink" title="Redis的数据淘汰策略"></a><a href="https://blog.csdn.net/yangtuogege/article/details/77970896" target="_blank" rel="noopener">Redis的数据淘汰策略</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis用过哪些数据数据，以及Redis底层怎么实现&quot;&gt;&lt;a href=&quot;#Redis用过哪些数据数据，以及Redis底层怎么实现&quot; class=&quot;headerlink&quot; title=&quot;Redis用过哪些数据数据，以及Redis底层怎么实现&quot;&gt;&lt;/a&gt;Redis
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/redis/"/>
    
    
      <category term="redis" scheme="https://yapengren.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring 知识点</title>
    <link href="https://yapengren.github.io/wiki/Spring-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Spring-知识点/</id>
    <published>2019-08-04T05:01:51.000Z</published>
    <updated>2019-08-18T03:36:51.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BeanFactory-和-FactoryBean？"><a href="#BeanFactory-和-FactoryBean？" class="headerlink" title="BeanFactory 和 FactoryBean？"></a><a href="https://blog.csdn.net/qiesheng/article/details/72875315" target="_blank" rel="noopener">BeanFactory 和 FactoryBean？</a></h3><h3 id="Spring-IOC-的理解，其初始化过程？"><a href="#Spring-IOC-的理解，其初始化过程？" class="headerlink" title="Spring IOC 的理解，其初始化过程？"></a><a href="https://www.cnblogs.com/chenjunjie12321/p/6124649.html" target="_blank" rel="noopener">Spring IOC 的理解，其初始化过程？</a></h3><h3 id="BeanFactory-和-ApplicationContext？"><a href="#BeanFactory-和-ApplicationContext？" class="headerlink" title="BeanFactory 和 ApplicationContext？"></a><a href="https://blog.csdn.net/qq_32651225/article/details/78323527" target="_blank" rel="noopener">BeanFactory 和 ApplicationContext？</a></h3><h3 id="Spring-Bean-的生命周期，如何被管理的？"><a href="#Spring-Bean-的生命周期，如何被管理的？" class="headerlink" title="Spring Bean 的生命周期，如何被管理的？"></a><a href="https://www.cnblogs.com/kenshinobiy/p/4652008.html" target="_blank" rel="noopener">Spring Bean 的生命周期，如何被管理的？</a></h3><h3 id="Spring-Bean-的加载过程是怎样的？"><a href="#Spring-Bean-的加载过程是怎样的？" class="headerlink" title="Spring Bean 的加载过程是怎样的？"></a><a href="https://www.cnblogs.com/xrq730/p/6285358.html" target="_blank" rel="noopener">Spring Bean 的加载过程是怎样的？</a></h3><h3 id="如果要你实现Spring-AOP，请问怎么实现？"><a href="#如果要你实现Spring-AOP，请问怎么实现？" class="headerlink" title="如果要你实现Spring AOP，请问怎么实现？"></a>如果要你实现Spring AOP，请问怎么实现？</h3><h3 id="如果要你实现Spring-IOC，你会注意哪些问题？"><a href="#如果要你实现Spring-IOC，你会注意哪些问题？" class="headerlink" title="如果要你实现Spring IOC，你会注意哪些问题？"></a>如果要你实现Spring IOC，你会注意哪些问题？</h3><h3 id="Spring-是如何管理事务的，事务管理机制？"><a href="#Spring-是如何管理事务的，事务管理机制？" class="headerlink" title="Spring 是如何管理事务的，事务管理机制？"></a><a href="https://www.cnblogs.com/dongfangshenhua/p/6949521.html" target="_blank" rel="noopener">Spring 是如何管理事务的，事务管理机制？</a></h3><h3 id="Spring-的不同事务传播行为有哪些，干什么用的？"><a href="#Spring-的不同事务传播行为有哪些，干什么用的？" class="headerlink" title="Spring 的不同事务传播行为有哪些，干什么用的？"></a><a href="https://www.cnblogs.com/dongfangshenhua/p/6949521.html" target="_blank" rel="noopener">Spring 的不同事务传播行为有哪些，干什么用的？</a></h3><h3 id="Spring-中用到了那些设计模式？"><a href="#Spring-中用到了那些设计模式？" class="headerlink" title="Spring 中用到了那些设计模式？"></a><a href="https://www.cnblogs.com/baizhanshi/p/6187537.html" target="_blank" rel="noopener">Spring 中用到了那些设计模式？</a></h3><h3 id="Spring-MVC-的工作原理？"><a href="#Spring-MVC-的工作原理？" class="headerlink" title="Spring MVC 的工作原理？"></a><a href="https://www.cnblogs.com/xiaoxi/p/6164383.html" target="_blank" rel="noopener">Spring MVC 的工作原理？</a></h3><h3 id="Spring-循环注入的原理？"><a href="#Spring-循环注入的原理？" class="headerlink" title="Spring 循环注入的原理？"></a>Spring 循环注入的原理？</h3><h3 id="Spring-AOP的理解，各个术语，他们是怎么相互工作的？"><a href="#Spring-AOP的理解，各个术语，他们是怎么相互工作的？" class="headerlink" title="Spring AOP的理解，各个术语，他们是怎么相互工作的？"></a><a href="https://www.jianshu.com/p/5015f212e4e4" target="_blank" rel="noopener">Spring AOP的理解，各个术语，他们是怎么相互工作的？</a></h3><h3 id="Spring-如何保证-Controller-并发的安全？"><a href="#Spring-如何保证-Controller-并发的安全？" class="headerlink" title="Spring 如何保证 Controller 并发的安全？"></a><a href="https://www.cnblogs.com/tiancai/p/9627109.html" target="_blank" rel="noopener">Spring 如何保证 Controller 并发的安全？</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BeanFactory-和-FactoryBean？&quot;&gt;&lt;a href=&quot;#BeanFactory-和-FactoryBean？&quot; class=&quot;headerlink&quot; title=&quot;BeanFactory 和 FactoryBean？&quot;&gt;&lt;/a&gt;&lt;a href=
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS 流程图</title>
    <link href="https://yapengren.github.io/wiki/FastDFS-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/FastDFS-流程图/</id>
    <published>2019-08-04T03:34:10.000Z</published>
    <updated>2019-08-18T03:35:19.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastDFS-执行流程"><a href="#FastDFS-执行流程" class="headerlink" title="FastDFS 执行流程"></a>FastDFS 执行流程</h3><p>FastDFS 服务端有三个角色：跟踪服务器（Tracker Server）、存储服务器（Storage Server）和客户端（Client）。 </p><ul><li><p>Tracker Server：跟踪服务器，主要做调度工作，起负载均衡的作用。在内存记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽。相比 GFS 中的 Master 更为精简，不记录文件索引信息，占用的内存量很少。 </p></li><li><p>Storage Server：存储服务器（又称存储节点或数据服务器），文件和文件属性（Meta Data）都保存到存储服务器上。Storage Server 直接利用 OS 的文件系统调用管理文件。 </p></li><li><p>Client：客户端，作为业务请求的发起方，通过专有接口，使用 TCP/IP 协议与跟踪器服务器或存储节点进行数据交互。FastDFS 向使用者提供基本文件访问接口，如 upload、download、append、delete 等，以客户端库的方式提供给用户使用。 </p></li></ul><p>通过一张图来看一下 FastDFS 的运行机制： </p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5nhqjznlqj30ie0gdjw7.jpg" alt="9F8CC1B1-7DF4-42E5-A387-2FA00924B117"></p><p>Tracker 相当于 FastDFS 的大脑，不论是上传还是下载都是通过 Tracker 来分配资源；客户端一般可以使用 Ngnix 等静态服务器来调用或者做一部分的缓存；存储服务器内部分为卷（或者叫做组），卷与卷之间是平行的关系，可以根据资源的使用情况随时增加，卷内服务器文件相互同步备份，以达到容灾的目的。</p><h3 id="上传机制"><a href="#上传机制" class="headerlink" title="上传机制"></a>上传机制</h3><p>首先客户端请求 Tracker 服务获取到存储服务器的 IP 地址和端口，然后客户端根据返回的 IP 地址和端口号请求上传文件，存储服务器接收到请求后生产文件，并且将文件内容写入磁盘并返回给客户端 file_id、路径信息、文件名等信息，客户端保存相关信息上传完毕。 </p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5nhr79buzj30p10d6wfu.jpg" alt="1"></p><h3 id="下载机制"><a href="#下载机制" class="headerlink" title="下载机制"></a>下载机制</h3><p>客户端带上文件名信息请求 Tracker 服务获取到存储服务器的 IP 地址和端口，然后客户端根据返回的 IP 地址和端口号请求下载文件，存储服务器接收到请求后返回文件给客户端。 </p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5nhriqa0dj30om0bdjtg.jpg" alt="6542D65C-57D6-4B08-A3D5-CA1578F3091D"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastDFS-执行流程&quot;&gt;&lt;a href=&quot;#FastDFS-执行流程&quot; class=&quot;headerlink&quot; title=&quot;FastDFS 执行流程&quot;&gt;&lt;/a&gt;FastDFS 执行流程&lt;/h3&gt;&lt;p&gt;FastDFS 服务端有三个角色：跟踪服务器（Tracker
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="文件存储" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="FastDFS" scheme="https://yapengren.github.io/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>springMVC 流程图</title>
    <link href="https://yapengren.github.io/wiki/springMVC-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/springMVC-流程图/</id>
    <published>2019-08-04T03:30:24.000Z</published>
    <updated>2019-08-18T03:36:57.405Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5nhlgldvpj30ha0asdgj.jpg" alt="1"></p><h3 id="springMVC执行流程"><a href="#springMVC执行流程" class="headerlink" title="springMVC执行流程"></a>springMVC执行流程</h3><ol><li><p>用户发送请求至前端控制器 <code>DispatcherServlet</code></p></li><li><p>前端控制器 <code>DispatcherServlet</code> 收到请求调用处理器映射器<code>HandlerMapping</code>。 </p></li><li><p>处理器映射器 <code>HandlerMapping</code> 根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器一并返回给前端控制器<code>DispatcherServlet</code>。 </p></li><li><p>前端控制器 <code>DispatcherServlet</code> 通过处理器适配器 <code>HandlerAdapter</code> 调用处理器 </p></li><li><p>执行处理器，执行业务逻辑(Controller，也叫后端控制器)。 </p></li><li><p><code>Controller</code> 执行完成返回 <code>ModelAndView</code> </p></li><li><p>处理器适配器 <code>HandlerAdapter</code> 将 controller 执行结果 <code>ModelAndView</code> 返回给前端控制器 <code>DispatcherServlet</code> </p></li><li><p>前端控制器 <code>DispatcherServlet</code> 将 <code>ModelAndView</code> 传给视图解析器  <code>ViewResolver</code> </p></li><li><p>视图解析器 <code>ViewResolver</code> 解析后返回具体 View </p></li><li><p><code>DispatcherServlet</code> 对 View 进行渲染视图（即将模型数据填充至视图中）。 </p></li><li><p><code>DispatcherServlet</code> 响应用户 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5nhlgldvpj30ha0asdgj.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;springMVC执行流程&quot;&gt;&lt;a href=&quot;#springMVC执行流程&quot; 
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>shiro 流程图</title>
    <link href="https://yapengren.github.io/wiki/shiro-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/shiro-流程图/</id>
    <published>2019-08-04T03:28:49.000Z</published>
    <updated>2019-08-18T03:36:43.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5nhjbbi30j30se0g1glz.jpg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5nhjbbi30j30se0g1glz.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="权限认证" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="shiro" scheme="https://yapengren.github.io/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis 架构图</title>
    <link href="https://yapengren.github.io/wiki/Mybatis-%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    <id>https://yapengren.github.io/wiki/Mybatis-架构图/</id>
    <published>2019-08-04T03:21:42.000Z</published>
    <updated>2019-08-18T03:36:07.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5nheb2f59j30lu0k6754.jpg" alt="1"></p><ol><li>mybatis配置    </li></ol><p><code>SqlMapConfig.xml</code>，此文件作为 mybatis 的全局配置文件，配置了 mybatis 的运行环境等信息。 </p><p><code>mapper.xml</code> 文件即sql映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 <code>SqlMapConfig.xml</code> 中加载。 </p><ol start="2"><li><p>通过 mybatis 环境等配置信息构造 <code>SqlSessionFactory</code> 即会话工厂 </p></li><li><p>由会话工厂创建 sqlSession 即会话，操作数据库需要通过 sqlSession 进行。 </p></li><li><p>mybatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。 </p></li><li><p><code>Mapped Statement</code> 也是 mybatis 一个底层封装对象，它包装了 mybatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 <code>Mapped Statement</code> 对象，sql 的 id 即是 Mapped statement 的id。 </p></li><li><p>Mapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql前将输入的 java 对象映射至 sql 中，输入参数映射就是 jdbc 编程中对preparedStatement 设置参数。 </p></li><li><p>Mapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql 后将输出结果映射至 java 对象中，输出结果映射过程相当于 jdbc 编程中对结果的解析处理过程。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5nheb2f59j30lu0k6754.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mybatis配置    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;SqlMa
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="mybatis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/mybatis/"/>
    
    
      <category term="mybatis" scheme="https://yapengren.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 架构</title>
    <link href="https://yapengren.github.io/wiki/Dubbo-%E6%9E%B6%E6%9E%84/"/>
    <id>https://yapengren.github.io/wiki/Dubbo-架构/</id>
    <published>2019-08-04T03:15:00.000Z</published>
    <updated>2019-08-18T03:34:46.655Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"></p><h3 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h3><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的服务提供方</td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的服务消费方</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td><code>Container</code></td><td>服务运行容器</td></tr></tbody></table><h3 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h3><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg&quot; alt=&quot;dubbo-architucture&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;节点角色说明&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="dubbo" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://yapengren.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础知识点</title>
    <link href="https://yapengren.github.io/wiki/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/Java-基础知识点/</id>
    <published>2019-08-03T10:01:30.000Z</published>
    <updated>2019-08-18T03:35:42.895Z</updated>
    
    <content type="html"><![CDATA[<h4 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a><a href="https://www.cnblogs.com/IvesHe/p/6108933.html" target="_blank" rel="noopener">List 和 Set 的区别</a></h4><h4 id="HashSet-是如何保证不重复的"><a href="#HashSet-是如何保证不重复的" class="headerlink" title="HashSet 是如何保证不重复的"></a><a href="https://blog.csdn.net/u010698072/article/details/52802179" target="_blank" rel="noopener">HashSet 是如何保证不重复的</a></h4><h4 id="HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"></a>HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）</h4><h4 id="HashMap-的扩容过程"><a href="#HashMap-的扩容过程" class="headerlink" title="HashMap 的扩容过程"></a><a href="https://www.cnblogs.com/KingIceMou/p/6976574.html" target="_blank" rel="noopener">HashMap 的扩容过程</a></h4><h4 id="HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</a></h4><h4 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final finally finalize"></a><a href="https://www.cnblogs.com/smart-hwt/p/8257330.html" target="_blank" rel="noopener">final finally finalize</a></h4><h4 id="强引用-、软引用、-弱引用、虚引用"><a href="#强引用-、软引用、-弱引用、虚引用" class="headerlink" title="强引用 、软引用、 弱引用、虚引用"></a><a href="https://www.cnblogs.com/yw-ah/p/5830458.html" target="_blank" rel="noopener">强引用 、软引用、 弱引用、虚引用</a></h4><h4 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h4><h4 id="Arrays-sort-实现原理和-Collection-实现原理"><a href="#Arrays-sort-实现原理和-Collection-实现原理" class="headerlink" title="Arrays.sort 实现原理和 Collection 实现原理"></a><a href="https://www.baidu.com/link?url=tFFtzrDujnsZH0r1y1MZalWy6NmEAsBEz6vglax_eysgtZFiTwK9ObeHWDTChqttMgr4EGAdu37jSmtyJfTx4Zts21A8ThRRzS9IWGPl5MS&wd=&eqid=9d74567f00035750000000025c417222" target="_blank" rel="noopener">Arrays.sort 实现原理和 Collection 实现原理</a></h4><h4 id="LinkedHashMap的应用"><a href="#LinkedHashMap的应用" class="headerlink" title="LinkedHashMap的应用"></a><a href="https://www.cnblogs.com/xiaoxi/p/6170590.html" target="_blank" rel="noopener">LinkedHashMap的应用</a></h4><h4 id="cloneable接口实现原理"><a href="#cloneable接口实现原理" class="headerlink" title="cloneable接口实现原理"></a>cloneable接口实现原理</h4><h4 id="异常分类以及处理机制"><a href="#异常分类以及处理机制" class="headerlink" title="异常分类以及处理机制"></a><a href="https://blog.csdn.net/hguisu/article/details/6155636#t0" target="_blank" rel="noopener">异常分类以及处理机制</a></h4><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><a href="https://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html" target="_blank" rel="noopener">wait和sleep的区别</a></h4><h4 id="数组在内存中如何分配"><a href="#数组在内存中如何分配" class="headerlink" title="数组在内存中如何分配"></a><a href="https://www.cnblogs.com/chenpi/p/5489732.html" target="_blank" rel="noopener">数组在内存中如何分配</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;List-和-Set-的区别&quot;&gt;&lt;a href=&quot;#List-和-Set-的区别&quot; class=&quot;headerlink&quot; title=&quot;List 和 Set 的区别&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/IvesHe/p/61
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 知识点</title>
    <link href="https://yapengren.github.io/wiki/MySQL-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/MySQL-知识点/</id>
    <published>2019-08-03T09:36:37.000Z</published>
    <updated>2019-08-18T08:22:54.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="MySQL-索引类型"><a href="#MySQL-索引类型" class="headerlink" title="MySQL 索引类型"></a><a href="https://www.cnblogs.com/luyucheng/p/6289714.html" target="_blank" rel="noopener">MySQL 索引类型</a></h4><h4 id="sql-优化的几种方式"><a href="#sql-优化的几种方式" class="headerlink" title="sql 优化的几种方式"></a><a href="https://blog.csdn.net/jie_liang/article/details/77340905" target="_blank" rel="noopener">sql 优化的几种方式</a></h4><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><h4 id="数据库事务的-4-种隔离级别"><a href="#数据库事务的-4-种隔离级别" class="headerlink" title="数据库事务的 4 种隔离级别"></a><a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">数据库事务的 4 种隔离级别</a></h4><h4 id="数据库事务的-4-个基本特性"><a href="#数据库事务的-4-个基本特性" class="headerlink" title="数据库事务的 4 个基本特性"></a><a href="https://blog.csdn.net/mfl0315/article/details/51981792" target="_blank" rel="noopener">数据库事务的 4 个基本特性</a></h4><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="MySQL-中FIND-IN-SET-和IN区别简析"><a href="#MySQL-中FIND-IN-SET-和IN区别简析" class="headerlink" title="MySQL 中FIND_IN_SET()和IN区别简析"></a><a href="https://www.jb51.net/article/125744.htm" target="_blank" rel="noopener">MySQL 中FIND_IN_SET()和IN区别简析</a></h4><h4 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html" target="_blank" rel="noopener">MySQL Explain详解</a></h4><h4 id="MySQL中concat以及group-concat的使用"><a href="#MySQL中concat以及group-concat的使用" class="headerlink" title="MySQL中concat以及group_concat的使用"></a><a href="https://blog.csdn.net/mary19920410/article/details/76545053" target="_blank" rel="noopener">MySQL中concat以及group_concat的使用</a></h4><h4 id="MySQL中order-by语句对null字段的排序"><a href="#MySQL中order-by语句对null字段的排序" class="headerlink" title="MySQL中order by语句对null字段的排序"></a><a href="https://www.cnblogs.com/Wcy100/p/5376399.html" target="_blank" rel="noopener">MySQL中order by语句对null字段的排序</a></h4><h3 id="SQL练习"><a href="#SQL练习" class="headerlink" title="SQL练习"></a>SQL练习</h3><h4 id="MySQL经典练习题及答案，常用SQL语句练习50题"><a href="#MySQL经典练习题及答案，常用SQL语句练习50题" class="headerlink" title="MySQL经典练习题及答案，常用SQL语句练习50题"></a><a href="https://blog.csdn.net/qq_41936662/article/details/80393172" target="_blank" rel="noopener">MySQL经典练习题及答案，常用SQL语句练习50题</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h3&gt;&lt;h4 id=&quot;MySQL-索引类型&quot;&gt;&lt;a href=&quot;#MySQL-索引类型&quot; class=&quot;headerlink&quot; title=&quot;M
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>intellij idea 修改记录</title>
    <link href="https://yapengren.github.io/wiki/intellij-idea-%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95/"/>
    <id>https://yapengren.github.io/wiki/intellij-idea-修改记录/</id>
    <published>2019-08-02T10:13:00.000Z</published>
    <updated>2019-08-04T03:50:15.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤文件"><a href="#过滤文件" class="headerlink" title="过滤文件"></a>过滤文件</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5li1vj2waj31ak0u0199.jpg" alt="image-20190802181535850"></p><h3 id="显示多-Tabs"><a href="#显示多-Tabs" class="headerlink" title="显示多 Tabs"></a>显示多 Tabs</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5mm7u2b81j31au0u07ii.jpg" alt="image-20190803172518386"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;过滤文件&quot;&gt;&lt;a href=&quot;#过滤文件&quot; class=&quot;headerlink&quot; title=&quot;过滤文件&quot;&gt;&lt;/a&gt;过滤文件&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5li1vj2waj31
      
    
    </summary>
    
      <category term="开发工具" scheme="https://yapengren.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDE" scheme="https://yapengren.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDE/"/>
    
    
      <category term="util" scheme="https://yapengren.github.io/tags/util/"/>
    
  </entry>
  
  <entry>
    <title>mac brew 服务</title>
    <link href="https://yapengren.github.io/wiki/mac-brew-%E6%9C%8D%E5%8A%A1/"/>
    <id>https://yapengren.github.io/wiki/mac-brew-服务/</id>
    <published>2019-08-02T09:40:48.000Z</published>
    <updated>2019-08-02T10:01:21.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="brew-常用命令"><a href="#brew-常用命令" class="headerlink" title="brew 常用命令"></a>brew 常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew 搜索软件</span><br><span class="line">brew search nginx</span><br><span class="line"></span><br><span class="line">brew 安装软件</span><br><span class="line">brew install nginx</span><br><span class="line"></span><br><span class="line">brew 卸载软件</span><br><span class="line">brew uninstall nginx</span><br><span class="line"></span><br><span class="line">brew 升级</span><br><span class="line">sudo brew update</span><br><span class="line"></span><br><span class="line">查看安装信息</span><br><span class="line">sudo brew info nginx </span><br><span class="line"></span><br><span class="line">查看已安装软件</span><br><span class="line">brew list</span><br></pre></td></tr></table></figure><h3 id="brew-安装nginx"><a href="#brew-安装nginx" class="headerlink" title="brew 安装nginx"></a>brew 安装nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">sudo brew install nginx</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">sudo brew services start nginx</span><br><span class="line"></span><br><span class="line">重启</span><br><span class="line">sudo brew services restart nginx</span><br><span class="line"></span><br><span class="line">停止</span><br><span class="line">sudo brew services stop nginx</span><br><span class="line"></span><br><span class="line">查看</span><br><span class="line">cat /usr/local/etc/nginx/nignx.conf</span><br></pre></td></tr></table></figure><h3 id="brew-redis"><a href="#brew-redis" class="headerlink" title="brew redis"></a>brew redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动</span><br><span class="line">redis-server /usr/local/etc/redis-6379.conf</span><br><span class="line"></span><br><span class="line">停止</span><br><span class="line">redis-cli -p 6379 shutdown</span><br></pre></td></tr></table></figure><h3 id="brew-安装-activemq"><a href="#brew-安装-activemq" class="headerlink" title="brew 安装 activemq"></a>brew 安装 activemq</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">brew install activemq</span><br><span class="line"></span><br><span class="line">查看版本</span><br><span class="line">activemq —version</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">activemq start</span><br><span class="line"></span><br><span class="line">地址</span><br><span class="line">http://localhost:8161    admin   admin</span><br></pre></td></tr></table></figure><h3 id="brew-安装-rabbitmq"><a href="#brew-安装-rabbitmq" class="headerlink" title="brew 安装 rabbitmq"></a>brew 安装 rabbitmq</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">brew install rabbitmq</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">brew services start rabbitmq</span><br><span class="line"></span><br><span class="line">地址</span><br><span class="line">http://localhost:15672    guest    guest</span><br></pre></td></tr></table></figure><h3 id="brew-安装-mongodb"><a href="#brew-安装-mongodb" class="headerlink" title="brew 安装 mongodb"></a>brew 安装 mongodb</h3><p>参考：<a href="https://blog.csdn.net/ligh_sqh/article/details/81112428" target="_blank" rel="noopener">https://blog.csdn.net/ligh_sqh/article/details/81112428</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line"></span><br><span class="line">启动 mongodb 客户端</span><br><span class="line">cd ~/software/adminmongo</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line">客户端地址    http://localhost:1234</span><br></pre></td></tr></table></figure><h3 id="nacos-启动命令"><a href="#nacos-启动命令" class="headerlink" title="nacos 启动命令"></a>nacos 启动命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh ～/software/nacos/bin/startup.sh -m standalone</span><br></pre></td></tr></table></figure><h3 id="elasticsearch-head-安装和启动-elasticsearch-GUI客户端"><a href="#elasticsearch-head-安装和启动-elasticsearch-GUI客户端" class="headerlink" title="elasticsearch-head 安装和启动 -elasticsearch GUI客户端"></a>elasticsearch-head 安装和启动 -elasticsearch GUI客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br><span class="line">npm run start</span><br><span class="line"></span><br><span class="line">http://localhost:9100</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;brew-常用命令&quot;&gt;&lt;a href=&quot;#brew-常用命令&quot; class=&quot;headerlink&quot; title=&quot;brew 常用命令&quot;&gt;&lt;/a&gt;brew 常用命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="系统方面" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2/"/>
    
      <category term="mac" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2/mac/"/>
    
    
      <category term="mac" scheme="https://yapengren.github.io/tags/mac/"/>
    
  </entry>
  
</feed>

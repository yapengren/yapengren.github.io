<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yp_ren Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yapengren.github.io/"/>
  <updated>2019-12-22T09:21:29.782Z</updated>
  <id>https://yapengren.github.io/</id>
  
  <author>
    <name>renyapeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录盲盒项目SQL错误的事故</title>
    <link href="https://yapengren.github.io/wiki/%E8%AE%B0%E5%BD%95%E7%9B%B2%E7%9B%92%E9%A1%B9%E7%9B%AESQL%E9%94%99%E8%AF%AF%E7%9A%84%E4%BA%8B%E6%95%85/"/>
    <id>https://yapengren.github.io/wiki/记录盲盒项目SQL错误的事故/</id>
    <published>2019-12-22T09:15:33.000Z</published>
    <updated>2019-12-22T09:21:29.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  记录盲盒抽奖项目因为SQL错误</p><p>  导致表中数据被批量修改的问题</p></blockquote><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>需要根据 <code>is_big_prize</code> 是否大奖字段，修改删除状态。</p><p>如果<code>is_big_prize = ‘1’</code> 则修改所有大奖商品<code>delete_status=1</code> ，</p><p>如果 <code>is_big_prize</code> <strong>不等于</strong> 1，则修改所有小奖商品<code>delete_status=1</code></p><h1 id="错误mapper-xml"><a href="#错误mapper-xml" class="headerlink" title="错误mapper.xml"></a>错误mapper.xml</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"deleteBySkuId"</span> <span class="attr">parameterType</span>=<span class="string">"com.jd.jr.bcs.domain.entity.eggMachine.LdEggmachineProduct"</span>&gt;</span></span><br><span class="line">    UPDATE ld_eggmachine_product</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        modified_user = #&#123;modifiedUser,jdbcType=VARCHAR&#125;,</span><br><span class="line">        modified_date = #&#123;modifiedDate,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"deleteStatus != null"</span>&gt;</span></span><br><span class="line">            delete_status = #&#123;deleteStatus,jdbcType=INTEGER&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where</span><br><span class="line">    delete_status = 0</span><br><span class="line">    and sku_id = #&#123;skuId,jdbcType=VARCHAR&#125;</span><br><span class="line">    and activity_id = #&#123;activityId,jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"isBigPrize !=null and isBigPrize == 1"</span>&gt;</span></span><br><span class="line">            and is_big_prize = '1'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and is_big_prize is null or is_big_prize != '1'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="解析错误SQL"><a href="#解析错误SQL" class="headerlink" title="解析错误SQL"></a>解析错误SQL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from ld_eggmachine_product</span><br><span class="line">where delete_status = 1</span><br><span class="line">    and sku_id = &apos;5309709&apos;</span><br><span class="line">    and activity_id = 6</span><br><span class="line">    and is_big_prize is null</span><br><span class="line">    or is_big_prize != &apos;1&apos;;</span><br></pre></td></tr></table></figure><p><code>or</code> 导致<code>ld_eggmachine_product</code>表中<code>is_big_prize</code>字段<code>!=&#39;1&#39;</code>的数据都被修改</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>is_big_prize != &#39;1&#39;</code>查询不出为 NULL 的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from ld_eggmachine_product</span><br><span class="line">where is_big_prize != &apos;1&apos;;</span><br></pre></td></tr></table></figure><br><p>查询<code>is_big_prize</code>不等于1的正确写法，可以查询出 != ‘1’ 和 != null 的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from ld_eggmachine_product</span><br><span class="line">where delete_status = 1</span><br><span class="line">    and sku_id = &apos;5309709&apos;</span><br><span class="line">    and activity_id = 6</span><br><span class="line">    and ifnull(is_big_prize, &apos;&apos;) != &apos;1&apos;;</span><br></pre></td></tr></table></figure><h1 id="MySQL-IFNULL"><a href="#MySQL-IFNULL" class="headerlink" title="MySQL IFNULL()"></a>MySQL IFNULL()</h1><p>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IFNULL(expression, alt_value)</span><br></pre></td></tr></table></figure><p>如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;  记录盲盒抽奖项目因为SQL错误&lt;/p&gt;
&lt;p&gt;  导致表中数据被批量修改的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;上下文&quot;&gt;&lt;a href=&quot;#上下文&quot; class=&quot;headerlink&quot; title=&quot;上下文&quot;&gt;&lt;/a&gt;上
      
    
    </summary>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://yapengren.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL字段类型介绍</title>
    <link href="https://yapengren.github.io/wiki/MySQL%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://yapengren.github.io/wiki/MySQL字段类型介绍/</id>
    <published>2019-12-14T09:23:12.000Z</published>
    <updated>2019-12-14T09:37:41.155Z</updated>
    
    <content type="html"><![CDATA[<p>注意点：</p><ul><li>数值类型：注意字段范围的选择。</li><li>日期和时间类型：注意 DATETIME 和 TIMESTAMP 的区别。</li><li>字符串类型：用的最多的是 CHAR 和 VARCHAR 类型，注意两者的区别，其他类型在互联网业务中不建议使用。</li></ul><h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>大小</strong></th><th align="center"><strong>范围（有符号）</strong></th><th align="center"><strong>范围（无符号）</strong></th><th align="center"><strong>用途</strong></th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">1 字节</td><td align="center">(-128，127)</td><td align="center">(0，255)</td><td align="center">小整数值</td></tr><tr><td align="center">SMALLINT</td><td align="center">2 字节</td><td align="center">(-32 768，32 767)</td><td align="center">(0，65 535)</td><td align="center">大整数值</td></tr><tr><td align="center">MEDIUMINT</td><td align="center">3 字节</td><td align="center">(-8 388 608，8 388 607)</td><td align="center">(0，16 777 215)</td><td align="center">大整数值</td></tr><tr><td align="center">INT或INTEGER</td><td align="center">4 字节</td><td align="center">(-2 147 483 648，2 147 483 647)</td><td align="center">(0，4 294 967 295)</td><td align="center">大整数值</td></tr><tr><td align="center">BIGINT</td><td align="center">8 字节</td><td align="center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="center">(0，18 446 744 073 709 551 615)</td><td align="center">极大整数值</td></tr><tr><td align="center">FLOAT</td><td align="center">4 字节</td><td align="center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="center">单精度<br>浮点数值</td></tr><tr><td align="center">DOUBLE</td><td align="center">8 字节</td><td align="center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="center">双精度<br>浮点数值</td></tr><tr><td align="center">DECIMAL</td><td align="center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="center">依赖于M和D的值</td><td align="center">依赖于M和D的值</td><td align="center">小数值</td></tr></tbody></table><h1 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h1><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>大小</strong></th><th align="center"><strong>范围</strong></th><th align="center"><strong>格式</strong></th><th align="center"><strong>用途</strong></th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3 字节</td><td align="center">1000-01-01/9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="center">TIME</td><td align="center">3 字节</td><td align="center">‘-838:59:59’/‘838:59:59’</td><td align="center">HH:MM:SS</td><td align="center">时间值或持续时间</td></tr><tr><td align="center">YEAR</td><td align="center">1 字节</td><td align="center">1901/2155</td><td align="center">YYYY</td><td align="center">年份值</td></tr><tr><td align="center">DATETIME</td><td align="center">8 字节</td><td align="center">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4 字节</td><td align="center">1970-01-01 00:00:00/2038<br>结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="center">YYYYMMDD HHMMSS</td><td align="center">混合日期和时间值，时间戳</td></tr></tbody></table><h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>大小</strong></th><th align="center"><strong>用途</strong></th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="center">0-255字节</td><td align="center">定长字符串</td></tr><tr><td align="center">VARCHAR</td><td align="center">0-65535 字节</td><td align="center">变长字符串</td></tr><tr><td align="center">TINYBLOB</td><td align="center">0-255字节</td><td align="center">不超过 255 个字符的二进制字符串</td></tr><tr><td align="center">TINYTEXT</td><td align="center">0-255字节</td><td align="center">短文本字符串</td></tr><tr><td align="center">BLOB</td><td align="center">0-65 535字节</td><td align="center">二进制形式的长文本数据</td></tr><tr><td align="center">TEXT</td><td align="center">0-65 535字节</td><td align="center">长文本数据</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">0-16 777 215字节</td><td align="center">二进制形式的中等长度文本数据</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">0-16 777 215字节</td><td align="center">中等长度文本数据</td></tr><tr><td align="center">LONGBLOB</td><td align="center">0-4 294 967 295字节</td><td align="center">二进制形式的极大文本数据</td></tr><tr><td align="center">LONGTEXT</td><td align="center">0-4 294 967 295字节</td><td align="center">极大文本数据</td></tr></tbody></table><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.yuque.com/yinjianwei/vyrvkf/ta5a63" target="_blank" rel="noopener">https://www.yuque.com/yinjianwei/vyrvkf/ta5a63</a></p><p>  感谢原作者</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值类型：注意字段范围的选择。&lt;/li&gt;
&lt;li&gt;日期和时间类型：注意 DATETIME 和 TIMESTAMP 的区别。&lt;/li&gt;
&lt;li&gt;字符串类型：用的最多的是 CHAR 和 VARCHAR 类型，注意两者的区别，其他类型在互联网业
      
    
    </summary>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://yapengren.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>进制转换</title>
    <link href="https://yapengren.github.io/wiki/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>https://yapengren.github.io/wiki/进制转换/</id>
    <published>2019-12-13T02:49:43.000Z</published>
    <updated>2019-12-13T03:00:31.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h1><p>方法：把二进制数按权展开，相加即得十进制数。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwq85qxcj30dc08w40w.jpg" alt="image.png"></p><h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>方法：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwqqxu8zj30ge0bagr0.jpg" alt="image.png"></p><h1 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h1><p>方法：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwrgt9fwj30ge0b3tdb.jpg" alt="image.png"></p><h1 id="八进制转成二进制"><a href="#八进制转成二进制" class="headerlink" title="八进制转成二进制"></a>八进制转成二进制</h1><p>方法：八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwrx9vv7j30gh0azn1y.jpg" alt="image.png"></p><h1 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h1><p>方法：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwshasdbj30gh0azn2u.jpg" alt="image.png"></p><h1 id="十六进制转二进制"><a href="#十六进制转二进制" class="headerlink" title="十六进制转二进制"></a>十六进制转二进制</h1><p>方法：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwsuhuv9j30gf0brn26.jpg" alt="image.png"></p><h1 id="十进制转八进制或者十六进制"><a href="#十进制转八进制或者十六进制" class="headerlink" title="十进制转八进制或者十六进制"></a>十进制转八进制或者十六进制</h1><p>方法一：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。</p><p>方法二：直接法—把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwtk7xxxj30gh0azq83.jpg" alt="image.png"></p><h1 id="八进制或者十六进制转成十进制"><a href="#八进制或者十六进制转成十进制" class="headerlink" title="八进制或者十六进制转成十进制"></a>八进制或者十六进制转成十进制</h1><p>方法：把八进制、十六进制数按权展开、相加即得十进制数。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9uwug87bij30gh0azn0j.jpg" alt="image.png"></p><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.yuque.com/yinjianwei/vyrvkf/vidbk6" target="_blank" rel="noopener">https://www.yuque.com/yinjianwei/vyrvkf/vidbk6</a></p><p>  感谢原作者</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二进制转十进制&quot;&gt;&lt;a href=&quot;#二进制转十进制&quot; class=&quot;headerlink&quot; title=&quot;二进制转十进制&quot;&gt;&lt;/a&gt;二进制转十进制&lt;/h1&gt;&lt;p&gt;方法：把二进制数按权展开，相加即得十进制数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tv
      
    
    </summary>
    
      <category term="java" scheme="https://yapengren.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://yapengren.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java线程知识点</title>
    <link href="https://yapengren.github.io/wiki/java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/java线程知识点/</id>
    <published>2019-12-08T06:25:11.000Z</published>
    <updated>2019-12-08T06:27:31.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9parh1xttj30vz0ptn0r.jpg" alt="线程的6个状态" style="zoom:60%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程的生命周期&quot;&gt;&lt;a href=&quot;#线程的生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的生命周期&quot;&gt;&lt;/a&gt;线程的生命周期&lt;/h1&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1g9
      
    
    </summary>
    
      <category term="java" scheme="https://yapengren.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://yapengren.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java8总结</title>
    <link href="https://yapengren.github.io/wiki/java8%E6%80%BB%E7%BB%93/"/>
    <id>https://yapengren.github.io/wiki/java8总结/</id>
    <published>2019-11-24T09:26:28.000Z</published>
    <updated>2019-12-08T06:24:38.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8总结"><a href="#Java8总结" class="headerlink" title="Java8总结"></a>Java8总结</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8常见操作总结</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleEmployee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Employee&gt; employeeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        employeeList.add(Employee.builder().name(<span class="string">"zhangsan"</span>).salary(<span class="number">3000</span>).office(<span class="string">"beijing"</span>).build());</span><br><span class="line">        employeeList.add(Employee.builder().name(<span class="string">"lisi"</span>).salary(<span class="number">6000</span>).office(<span class="string">"shanghai"</span>).build());</span><br><span class="line">        employeeList.add(Employee.builder().name(<span class="string">"wangwu"</span>).salary(<span class="number">20000</span>).office(<span class="string">"guangzhou"</span>).build());</span><br><span class="line">        employeeList.add(Employee.builder().name(<span class="string">"zhaoliu"</span>).salary(<span class="number">8000</span>).office(<span class="string">"shenzhen"</span>).build());</span><br><span class="line">        employeeList.add(Employee.builder().name(<span class="string">"qiangqi"</span>).salary(<span class="number">8000</span>).office(<span class="string">"beijing"</span>).build());</span><br><span class="line">        employeeList.add(Employee.builder().name(<span class="string">"renba"</span>).salary(<span class="number">21000</span>).office(<span class="string">"beijing"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// employeeList 是否包含 office="shanghai"</span></span><br><span class="line">        <span class="keyword">boolean</span> isMatch = employeeList.stream()</span><br><span class="line">                .anyMatch(employee -&gt; <span class="string">"shanghai"</span>.equals(employee.getOffice()));</span><br><span class="line">        System.out.println(isMatch);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// employeeList 的所有 salary 都大于4000</span></span><br><span class="line">        <span class="keyword">boolean</span> matched = employeeList.stream()</span><br><span class="line">                .allMatch(employee -&gt; employee.getSalary() &gt; <span class="number">4000</span>);</span><br><span class="line">        System.out.println(matched);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工资最高</span></span><br><span class="line">        Optional&lt;Employee&gt; hightSalary = employeeList.stream()</span><br><span class="line">                .max((e1, e2) -&gt; Integer.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">        System.out.println(hightSalary);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Employee&gt; hightSalary2 = employeeList.stream()</span><br><span class="line">                .max(Comparator.comparingInt(Employee::getSalary));</span><br><span class="line">        System.out.println(hightSalary2);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回姓名集合</span></span><br><span class="line">        List&lt;String&gt; names = employeeList.stream()</span><br><span class="line">                .map(Employee::getName)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List 转 Map</span></span><br><span class="line">        Map&lt;String, Employee&gt; employeeMap = employeeList.stream()</span><br><span class="line">                .collect(Collectors.toMap(Employee::getName, value -&gt; value));</span><br><span class="line">        employeeMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key + <span class="string">" : "</span> + value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计 office 是 beijing 的个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employeeList.stream()</span><br><span class="line">                .filter(employee -&gt; <span class="string">"beijing"</span>.equals(employee.getOffice()))</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List 转换为 Set</span></span><br><span class="line">        Set&lt;String&gt; officeSet = employeeList.stream()</span><br><span class="line">                .map(Employee::getOffice)</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        System.out.println(officeSet);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找 office 是 beijing 的员工</span></span><br><span class="line">        Optional&lt;Employee&gt; allMatchedEmployees = employeeList.stream()</span><br><span class="line">                .filter(employee -&gt; <span class="string">"beijing"</span>.equals(employee.getOffice()))</span><br><span class="line">                .findAny();</span><br><span class="line">        System.out.println(allMatchedEmployees);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照工资的降序来列出员工信息</span></span><br><span class="line">        List&lt;Employee&gt; descEmployeeList = employeeList.stream()</span><br><span class="line">                .sorted((e1, e2) -&gt; Integer.compare(e2.getSalary(), e1.getSalary()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(descEmployeeList);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照名字的升序列出员工信息</span></span><br><span class="line">        List&lt;Employee&gt; sortEmployeeByName = employeeList.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Employee::getName))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(sortEmployeeByName);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取工资最高的前两名员工信息</span></span><br><span class="line">        List&lt;Employee&gt; top2EmployeeList = employeeList.stream()</span><br><span class="line">                .sorted((e1, e2) -&gt; Integer.compare(e2.getSalary(), e1.getSalary()))</span><br><span class="line">                .limit(<span class="number">2</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(top2EmployeeList);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取平均工资</span></span><br><span class="line">        OptionalDouble averageSalary = employeeList.stream()</span><br><span class="line">                .mapToInt(Employee::getSalary)</span><br><span class="line">                .average();</span><br><span class="line">        System.out.println(averageSalary);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// beijing 办公室平均工资</span></span><br><span class="line">        OptionalDouble averageSalaryByOffice = employeeList.stream()</span><br><span class="line">                .filter(employee -&gt; <span class="string">"beijing"</span>.equals(employee.getOffice()))</span><br><span class="line">                .mapToInt(Employee::getSalary)</span><br><span class="line">                .average();</span><br><span class="line">        System.out.println(averageSalaryByOffice);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java8 分组操作</span></span><br><span class="line">        Map&lt;String, List&lt;Employee&gt;&gt; groupMap = employeeList.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getOffice));</span><br><span class="line">        System.out.println(groupMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java8总结&quot;&gt;&lt;a href=&quot;#Java8总结&quot; class=&quot;headerlink&quot; title=&quot;Java8总结&quot;&gt;&lt;/a&gt;Java8总结&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="java" scheme="https://yapengren.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://yapengren.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务</title>
    <link href="https://yapengren.github.io/wiki/Spring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://yapengren.github.io/wiki/Spring事务/</id>
    <published>2019-11-02T01:50:11.000Z</published>
    <updated>2019-12-08T06:33:25.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-事务管理-API-分析"><a href="#Spring-事务管理-API-分析" class="headerlink" title="Spring 事务管理 API 分析"></a>Spring 事务管理 API 分析</h2><p>Spring 框架中，涉及到事务管理的 API 大约有100个左右，其中最重要的有三个：<strong>PlatformTransactionManager</strong>、<strong>TransactionDefinition</strong>、<strong>TransactionStatus</strong>。</p><p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</p><p>“按照……来执行提交或者回滚操作”便是用 PlatformTransactionManager 来表示，</p><p>“给定的事务规则“就是用 TransactionDefinition 表示的，</p><p>TransactionStatus 用于表示一个运行着的事务的状态。</p><p>打一个不恰当的比喻，TransactionDefinition 与 TransactionStatus 的关系就像程序和进程的关系。</p><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><p>Spring 并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给 Hibernate 或者 JTA 等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： <strong>org.springframework.transaction.PlatformTransactionManager</strong> ，通过这个接口，Spring 为各个平台如 JDBC、Hibernate 等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><h3 id="PlatformTransactionManager接口代码"><a href="#PlatformTransactionManager接口代码" class="headerlink" title="PlatformTransactionManager接口代码"></a>PlatformTransactionManager接口代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据指定的传播行为，返回当前活动的事务或创建一个新事务</span></span><br><span class="line"><span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用事务目前的状态提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对执行的事务进行回滚</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们在使用 JDBC 或者 MyBatis 进行数据持久化操作时，xml配置文件通常如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">    &lt;!-- 数据源 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><p>事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，传参是 TransactionDefinition 类 ，该类包含与事务属性有关的方法。</p><h3 id="TransactionDefinition-接口代码"><a href="#TransactionDefinition-接口代码" class="headerlink" title="TransactionDefinition 接口代码"></a>TransactionDefinition 接口代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回事务的传播行为</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回事务的超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回是否优化为只读事务</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回事务的名字</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么接口只提供了获取属性的方法，而没有提供相关设置属性的方法。其实道理很简单，事务属性的设置完全是程序员控制的，因此程序员可以自定义任何设置属性的方法，而且保存属性的字段也没有任何要求。</p><p>唯一的要求的是，Spring 进行事务操作的时候，通过调用以上接口提供的方法必须能够返回事务相关的属性取值。</p><h3 id="事务属性包含了5个方面："><a href="#事务属性包含了5个方面：" class="headerlink" title="事务属性包含了5个方面："></a>事务属性包含了5个方面：</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8fzgbu6d3j30k60mu0v0.jpg" alt="spring事务属性" style="zoom:33%;"><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 定义了五个表示隔离级别的常量：</p><ol><li><strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：这是默认值，表示使用底层数据库的默认隔离级别。</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ol><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务方法的执行行为。在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：</p><ol><li><strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ol><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 PROPAGATION_NESTED 是 Spring 所特有的。以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</p><h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p><h4 id="事务的只读属性"><a href="#事务的只读属性" class="headerlink" title="事务的只读属性"></a>事务的只读属性</h4><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p><h4 id="事务的回滚规则"><a href="#事务的回滚规则" class="headerlink" title="事务的回滚规则"></a>事务的回滚规则</h4><p>通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务。这通常也是大多数开发者希望的处理方式，也是 EJB 中的默认处理方式。但是，我们可以根据需要人为控制事务在抛出某些未检查异常时任然提交事务，或者在抛出某些已检查异常时回滚事务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动回滚事务</span></span><br><span class="line">TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br></pre></td></tr></table></figure><h2 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h2><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。TransactionStatus 接口提供了一个简单的控制事务执行和查询事务状态的方法。</p><h3 id="TransactionStatus-接口代码"><a href="#TransactionStatus-接口代码" class="headerlink" title="TransactionStatus 接口代码"></a>TransactionStatus 接口代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 是否是新的事务</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否有恢复点</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置为只回滚</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否为只回滚</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否已完成</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p>通过 Spring 提供的事务管理 API，我们可以在代码中灵活控制事务的执行。在底层，Spring 仍然将事务操作委托给底层的持久化框架来执行。</p><h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><h3 id="基于-Transactional-的声明式事务管理"><a href="#基于-Transactional-的声明式事务管理" class="headerlink" title="基于 @Transactional 的声明式事务管理"></a>基于 @Transactional 的声明式事务管理</h3><p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p><p>Spring 使用 BeanPostProcessor 来处理 Bean 中的标注，因此我们需要在配置文件中作如下声明来激活该后处理 Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span>/&gt;</span><br></pre></td></tr></table></figure><p>transaction-manager 属性的默认值是 transactionManager，如果事务管理器 Bean 的名字即为该值，则可以省略该属性。</p><p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 小组建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p><h3 id="基于-lt-tx-gt-和基于-Transactional-各有优缺点："><a href="#基于-lt-tx-gt-和基于-Transactional-各有优缺点：" class="headerlink" title="基于 &lt;tx&gt; 和基于 @Transactional 各有优缺点："></a>基于 <code>&lt;tx&gt;</code> 和基于 @Transactional 各有优缺点：</h3><p>基于 <code>&lt;tx&gt;</code> 的方式，其优点是与切点表达式结合，功能强大。利用切点表达式，一个配置可以匹配多个方法；</p><p>而基于 @Transactional 的方式必须在每一个需要使用事务的方法或者类上用 @Transactional 标注，尽管可能大多数事务的规则是一致的，但是对 @Transactional 而言，也无法重用，必须逐个指定。另一方面，基于 @Transactional 的方式使用起来非常简单明了。</p><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-事务管理-API-分析&quot;&gt;&lt;a href=&quot;#Spring-事务管理-API-分析&quot; class=&quot;headerlink&quot; title=&quot;Spring 事务管理 API 分析&quot;&gt;&lt;/a&gt;Spring 事务管理 API 分析&lt;/h2&gt;&lt;p&gt;Spring
      
    
    </summary>
    
      <category term="框架" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Redis过期策略</title>
    <link href="https://yapengren.github.io/wiki/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/"/>
    <id>https://yapengren.github.io/wiki/Redis过期策略/</id>
    <published>2019-10-28T08:38:14.000Z</published>
    <updated>2019-12-14T03:12:14.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-过期策略"><a href="#Redis-过期策略" class="headerlink" title="Redis 过期策略"></a>Redis 过期策略</h2><p>Redis 过期策略是：定期删除 + 惰性删除。</p><p>所谓定期删除，指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p><p>假设 Redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存快耗尽了，怎么办？</p><p>答案是：走内存淘汰机制。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>Redis 内存淘汰机制有以下几个：</p><ul><li><strong>noeviction</strong> 不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。</li><li><strong>volatile-lru</strong> 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。</li><li><strong>volatile-lfu</strong> 尝试淘汰设置了过期时间的 key，按最近的访问频率进行淘汰。</li><li><strong>volatile-ttl</strong> 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。</li><li><strong>volatile-random</strong> 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。</li><li><strong>allkeys-lru</strong> 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰（常用）</li><li><strong>allkeys-lfu</strong> 区别于 volatile-lfu，这个策略要淘汰的 key 对象是全体的 key 集合，按最近的访问频率进行淘汰（常用）</li><li><strong>allkeys-random</strong> 跟上面一样，不过淘汰的策略是随机的 key。</li></ul><p>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。</p><p>如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。</p><p>如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。</p><h2 id="LRU-vs-LFU"><a href="#LRU-vs-LFU" class="headerlink" title="LRU vs LFU"></a>LRU vs LFU</h2><p>LFU 的全称是<code>Least Frequently Used</code>，表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。</p><blockquote><p>  Frequently    [/‘friːkw(ə)ntlɪ/]    adv.频繁地，屡次地</p></blockquote><p>如果一个 key 长时间不被访问，只是刚刚偶然被用户访问了一下，那么在使用 LRU 算法下它是不容易被淘汰的，因为 LRU 算法认为当前这个 key 是很热的。而 LFU 是需要追踪最近一段时间的访问频率，如果某个 key 只是偶然被访问一次是不足以变得很热的，它需要在近期一段时间内被访问很多次才有机会被认为很热。</p><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LinkedHashMap 默认的元素顺序是 put 的顺序，但是如果使用带参数的构造函数，那么 LinkedHashMap 会根据访问顺序来调整内部顺序。 LinkedHashMap 的 get() 方法除了返回元素之外还可以把被访问的元素放到链表的底端，这样一来每次顶端的元素就是 remove 的元素。</p><h2 id="LRU代码"><a href="#LRU代码" class="headerlink" title="LRU代码"></a>LRU代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最近最少使用算法，linkedHashMap实现，主要是针对缓存过期策略实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renyapeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存数据容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认装载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带参数构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> initialCapacity 容量</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> DEFAULT_LOAD_FACTOR 默认装载因子</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accessOrder 是否使用lru算法</span></span><br><span class="line"><span class="comment">         *                    true：使用（基于访问顺序，get一个元素后，这个元素被加到最后，使用了LRU最近最少被使用的调度算法）</span></span><br><span class="line"><span class="comment">         *                    false：不使用（基于插入顺序）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 传入指定的缓存最大容量</span></span><br><span class="line">        <span class="keyword">this</span>.capacity = initialCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现LRU的关键方法，如果map里面的元素个数大于了缓存最大容量，则删除链表的顶端元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  《Redis 深度历险：核心原理与应用实践》 作者：钱文品</p><p>  <a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/redis-expiration-policies-and-lru" target="_blank" rel="noopener">互联网 Java 工程师进阶知识完全扫盲</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-过期策略&quot;&gt;&lt;a href=&quot;#Redis-过期策略&quot; class=&quot;headerlink&quot; title=&quot;Redis 过期策略&quot;&gt;&lt;/a&gt;Redis 过期策略&lt;/h2&gt;&lt;p&gt;Redis 过期策略是：定期删除 + 惰性删除。&lt;/p&gt;
&lt;p&gt;所谓定期删除
      
    
    </summary>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
      <category term="Redis" scheme="https://yapengren.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全防范</title>
    <link href="https://yapengren.github.io/wiki/Redis%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/"/>
    <id>https://yapengren.github.io/wiki/Redis安全防范/</id>
    <published>2019-10-28T08:33:17.000Z</published>
    <updated>2019-12-14T03:12:08.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令安全"><a href="#指令安全" class="headerlink" title="指令安全"></a>指令安全</h2><p>Redis 有一些非常危险的指令，这些指令会对 Redis 的稳定以及数据安全造成非常严重的影响。比如 <code>keys</code> 指令会导致 Redis 卡顿，<code>flushdb</code> 和 <code>flushall</code> 会让 Redis 的所有数据全部清空。如何避免人为操作失误导致这些灾难性的后果也是运维人员特别需要注意的风险点之一。</p><p>Redis 在配置文件中提供了 <code>rename-command</code> 指令用于将某些危险的指令修改成特别的名称，用来避免人为误操作。比如在配置文件的 security 块增加下面的内容:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rename-command keys abckeysabc</span><br></pre></td></tr></table></figure><p>如果还想执行 keys 方法，那就不能直接敲 <code>keys</code> 命令了，而需要键入<code>abckeysabc</code>。 如果想完全封杀某条指令，可以将指令 <code>rename</code> 成空串，就无法通过任何字符串指令来执行这条指令了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rename-command flushall ""</span><br></pre></td></tr></table></figure><h2 id="端口安全"><a href="#端口安全" class="headerlink" title="端口安全"></a>端口安全</h2><p>Redis 默认会监听 <code>*:6379</code>，如果当前的服务器主机有外网地址，Redis 的服务将会直接暴露在公网上，任何一个初级黑客使用适当的工具对 IP 地址进行端口扫描就可以探测出来。</p><p> Redis 的服务地址一旦可以被外网直接访问，内部的数据就彻底丧失了安全性。高级一点的黑客们可以通过 Redis 执行 Lua 脚本拿到服务器权限，恶意的竞争对手们甚至会直接清空你的 Redis 数据库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind 10.100.20.13</span><br></pre></td></tr></table></figure><p>所以，运维人员务必在 Redis 的配置文件中指定监听的 IP 地址，避免这样的惨剧发生。更进一步，还可以增加 Redis 的密码访问限制，客户端必须使用 <code>auth</code> 指令传入正确的密码才可以访问 Redis，这样即使地址暴露出去了，普通黑客也无法对 Redis 进行任何指令操作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">requirepass yoursecurepasswordhereplease</span><br></pre></td></tr></table></figure><p>密码控制也会影响到从库复制，从库必须在配置文件里使用 masterauth 指令配置相应的密码才可以进行复制操作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">masterauth yoursecurepasswordhereplease</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;指令安全&quot;&gt;&lt;a href=&quot;#指令安全&quot; class=&quot;headerlink&quot; title=&quot;指令安全&quot;&gt;&lt;/a&gt;指令安全&lt;/h2&gt;&lt;p&gt;Redis 有一些非常危险的指令，这些指令会对 Redis 的稳定以及数据安全造成非常严重的影响。比如 &lt;code&gt;keys
      
    
    </summary>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>java小技巧</title>
    <link href="https://yapengren.github.io/wiki/java%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://yapengren.github.io/wiki/java小技巧/</id>
    <published>2019-10-24T07:29:46.000Z</published>
    <updated>2019-12-31T05:36:06.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java判断对象中属性值是否全为空"><a href="#java判断对象中属性值是否全为空" class="headerlink" title="java判断对象中属性值是否全为空"></a>java判断对象中属性值是否全为空</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断对象中属性值是否全为空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkObjAllFieldsIsNull</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == object) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field f : object.getClass().getDeclaredFields()) &#123;</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (f.get(object) != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(f.get(object).toString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java判断字符串是否为数字-包括浮点类型"><a href="#Java判断字符串是否为数字-包括浮点类型" class="headerlink" title="Java判断字符串是否为数字(包括浮点类型)"></a>Java判断字符串是否为数字(包括浮点类型)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">String reg = <span class="string">"^[0-9]+(.[0-9]+)?$"</span>;</span><br><span class="line"><span class="keyword">return</span> str.matches(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java判断对象中属性值是否全为空&quot;&gt;&lt;a href=&quot;#java判断对象中属性值是否全为空&quot; class=&quot;headerlink&quot; title=&quot;java判断对象中属性值是否全为空&quot;&gt;&lt;/a&gt;java判断对象中属性值是否全为空&lt;/h1&gt;&lt;figure class
      
    
    </summary>
    
      <category term="java" scheme="https://yapengren.github.io/categories/java/"/>
    
      <category term="方案" scheme="https://yapengren.github.io/categories/java/%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中间件</title>
    <link href="https://yapengren.github.io/wiki/SpringBoot%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://yapengren.github.io/wiki/SpringBoot中间件/</id>
    <published>2019-10-23T06:40:41.000Z</published>
    <updated>2019-10-28T02:40:26.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-和-Redis-常用操作"><a href="#Spring-Boot-和-Redis-常用操作" class="headerlink" title="Spring Boot 和 Redis 常用操作"></a>Spring Boot 和 Redis 常用操作</h1><h2 id="spring-boot-starter-data-redis"><a href="#spring-boot-starter-data-redis" class="headerlink" title="spring-boot-starter-data-redis"></a>spring-boot-starter-data-redis</h2><p>Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redis，它依赖于 spring-data-redis 和 lettuce。Spring Boot 1.0 默认使⽤的是 Jedis 客户端，2.0 替换成了 Lettuce，但如果你从 Spring Boot 1.5.X 切换过来，⼏乎感受不⼤差异，这是因为 spring-boot-starter-data-redis 为我们隔离了其中的差异性。</p><ul><li>Lettuce：是⼀个可伸缩线程安全的 Redis 客户端，多个线程可以共享同⼀个 RedisConnection，它利⽤优秀 Netty NIO 框架来⾼效地管理多个连接。</li><li>Spring Data：是 Spring 框架中的⼀个主要项⽬，⽬的是为了简化构建基于 Spring 框架应⽤的数据访问，包括⾮关系数据库、Map-Reduce 框架、云数据服务等，另外也包含对关系数据库的访问⽀持。</li><li>Spring Data Redis：是 Spring Data 项⽬中的⼀个主要模块，实现了对 Redis 客户端 API 的⾼度封装，使对 Redis 的操作更加便捷。</li></ul><p>可以⽤以下⽅式来表达它们之间的关系：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Lettuce ➡️ Spring Data Redis ➡️ Spring Data ➡️ spring-boot-starter-data-redis</span><br></pre></td></tr></table></figure><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Lettuce 需要使⽤ commons-pool <span class="number">2</span> 创建 Redis 连接池--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="application-配置"><a href="#application-配置" class="headerlink" title="application 配置"></a>application 配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Redis 数据库索引（默认为 0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"><span class="meta">#</span> Redis 服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"><span class="meta">#</span> Redis 服务器连接端⼝</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"><span class="meta">#</span> Redis 服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"><span class="meta">#</span> 连接池最⼤连接数（使⽤负值表示没有限制） 默认 8</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line"><span class="meta">#</span> 连接池最⼤阻塞等待时间（使⽤负值表示没有限制） 默认 -1</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1</span><br><span class="line"><span class="meta">#</span> 连接池中的最⼤空闲连接 默认 8</span><br><span class="line">spring.redis.lettuce.pool.max-idle=8</span><br><span class="line"><span class="meta">#</span> 连接池中的最⼩空闲连接 默认 0</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br></pre></td></tr></table></figure><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>在这⾥可以为 Redis 设置⼀些全局配置，⽐如配置主键的⽣产策略 KeyGenerator，如不配置会默认使⽤参数名作为主键。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="comment">//@EnableCaching 来开启缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"name"</span>, <span class="string">"renyapeng"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot-和-Redis-常用操作&quot;&gt;&lt;a href=&quot;#Spring-Boot-和-Redis-常用操作&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 和 Redis 常用操作&quot;&gt;&lt;/a&gt;Spring Boot 和 
      
    
    </summary>
    
      <category term="框架" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="springBoot" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/springBoot/"/>
    
    
      <category term="springBoot" scheme="https://yapengren.github.io/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>mac系统快捷键</title>
    <link href="https://yapengren.github.io/wiki/mac%E7%B3%BB%E7%BB%9F%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://yapengren.github.io/wiki/mac系统快捷键/</id>
    <published>2019-10-05T02:58:45.000Z</published>
    <updated>2020-01-04T09:34:38.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>⌃A    Home</p><p>⌃E    End</p><p>⌃H    ⌫</p><p>⌃D    Delete</p><p>⌃K    删除到结尾</p><p>⌃P    (Previous)  ↑</p><p>⌃N    (Next)  ↓</p><p>⌃B    (Backward)  ←</p><p>⌃F    (Forward)  →</p><p>⌃⌘F    全屏显示</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;p&gt;⌃A    Home&lt;/p&gt;
&lt;p&gt;⌃E    End&lt;/p&gt;
&lt;p&gt;⌃H    ⌫&lt;/p&gt;
&lt;p&gt;⌃D    Delete&lt;/p&gt;
      
    
    </summary>
    
      <category term="系统" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="mac" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F/mac/"/>
    
    
      <category term="mac" scheme="https://yapengren.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>vim</title>
    <link href="https://yapengren.github.io/wiki/vim/"/>
    <id>https://yapengren.github.io/wiki/vim/</id>
    <published>2019-09-22T05:57:38.000Z</published>
    <updated>2019-12-06T06:01:17.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim工作模式"><a href="#vim工作模式" class="headerlink" title="vim工作模式"></a>vim工作模式</h1><img src="https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png" alt="vim工作模式" style="zoom:50%;"><h1 id="vim键盘图"><a href="#vim键盘图" class="headerlink" title="vim键盘图"></a>vim键盘图</h1><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt="vim键盘图" style="zoom:67%;"><h1 id="vim使用案例"><a href="#vim使用案例" class="headerlink" title="vim使用案例"></a>vim使用案例</h1><h2 id="特殊字符转义"><a href="#特殊字符转义" class="headerlink" title="特殊字符转义"></a>特殊字符转义</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/   -&gt;   \/</span><br><span class="line">\   -&gt;   \\n</span><br></pre></td></tr></table></figure><h2 id="在每行行首添加相同的内容"><a href="#在每行行首添加相同的内容" class="headerlink" title="在每行行首添加相同的内容"></a>在每行行首添加相同的内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:%s/^/要添加的内容</span><br></pre></td></tr></table></figure><h2 id="在每行行尾添加相同的内容"><a href="#在每行行尾添加相同的内容" class="headerlink" title="在每行行尾添加相同的内容"></a>在每行行尾添加相同的内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:%s/$/要添加的内容</span><br></pre></td></tr></table></figure><h2 id="删除包含指定字符的行"><a href="#删除包含指定字符的行" class="headerlink" title="删除包含指定字符的行"></a>删除包含指定字符的行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">: g/指定字符/d</span><br><span class="line"></span><br><span class="line">例如，需要删除文件中，含有字符串“content-length”的行：</span><br><span class="line">: g/content-length/d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim工作模式&quot;&gt;&lt;a href=&quot;#vim工作模式&quot; class=&quot;headerlink&quot; title=&quot;vim工作模式&quot;&gt;&lt;/a&gt;vim工作模式&lt;/h1&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2
      
    
    </summary>
    
      <category term="系统" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
      <category term="linux" scheme="https://yapengren.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基本命令</title>
    <link href="https://yapengren.github.io/wiki/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://yapengren.github.io/wiki/linux基本命令/</id>
    <published>2019-09-22T05:57:36.000Z</published>
    <updated>2019-12-22T09:55:08.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可以使用 man 命令来查看各个命令的使用文档，如：man cp</p><h2 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h2><p>Linux中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ll</span><br><span class="line">total 2184</span><br><span class="line">-rw-r--r--    1 renyapeng  staff   846K  9 22 16:08 db.json</span><br><span class="line">drwxr-xr-x  315 renyapeng  staff   9.8K  8 12 14:07 node_modules</span><br><span class="line">drwxr-xr-x   21 renyapeng  staff   672B  9 22 15:28 public</span><br></pre></td></tr></table></figure><p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）</p><img src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="文件基本属性" style="zoom: 50%;"><p>10位字符表示：</p><ul><li><p>0位：确定文件类型</p></li><li><p>1-3位：确定该文件的所有者对文件的权限 <strong>owner</strong></p></li><li><p>4-6位：确定所有者的同组用户拥有该文件的权限 <strong>group</strong></p></li><li><p>7-9位：确定其他用户拥有该文件的权限 <strong>others</strong></p></li></ul><p>第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等</p><ul><li><p><strong>[</strong> <strong>d</strong> <strong>]</strong> 目录</p></li><li><p><strong>[</strong> <strong>-</strong> <strong>]</strong> 文件</p></li><li><p><strong>[</strong> <strong>l</strong>  <strong>]</strong> 链接文档（link file）</p></li><li><p><strong>[</strong> <strong>b</strong> <strong>]</strong> 可供储存的接口设备(可随机存取装置)</p></li><li><p><strong>[</strong> <strong>c</strong> <strong>]</strong> 串行端口设备，例如键盘、鼠标（一次性读取装置）</p></li></ul><p>接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变</p><ul><li><p><strong>[ r ]</strong> 代表可读（read）</p></li><li><p><strong>[ w ]</strong> 代表可写（write）</p></li><li><p><strong>[ x ]</strong> 代表可执行（execute）</p></li><li><p><strong>[ - ]</strong> 没有权限</p></li></ul><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h3><p>mkdir (make directory)</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [-p] 目录名称</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-m ：配置文件的权限</span><br><span class="line">-p ：将所需要的目录（包含上一级目录）递归创建起来</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir test    // 创建新目录</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: test1/test2/test3: No such file or directory    // 不能创建多层目录</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> mkdir -p test1/test2/test3/test4    // 添加-p参数，可以创建多层目录</span><br></pre></td></tr></table></figure><h3 id="cp-复制文件或文件夹"><a href="#cp-复制文件或文件夹" class="headerlink" title="cp 复制文件或文件夹"></a>cp 复制文件或文件夹</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [-adfilprsu] 来源档（source）目标档（destination）</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a ：相当于 -pdr 的意思，至于 pdr 请参考下列说明（常用）</span><br><span class="line">-d ：若来源档为连结档的属性（link file），则复制连结档属性而非文件本身</span><br><span class="line">-f ：为强制（force）的意思，若目标文件已经存在且无法开启，则移除后再尝试一次</span><br><span class="line">-i ：若目标档（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</span><br><span class="line">-l ：进行硬式连结（hard link）的连结档创建，而非复制文件本身</span><br><span class="line">-p ：连同文件的属性一起复制过去，而非使用默认属性（备份常用）</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为（常用）</span><br><span class="line">-s ：复制成为符号连结档（symbolic link），亦即「捷径」文件</span><br><span class="line">-u ：若 destination 比 source 旧才升级 destination</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cp -r test1 bashrc    // 复制文件夹并重命名</span><br></pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm 移除文件或目录"></a>rm 移除文件或目录</h3><p>rm (remove)</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息</span><br><span class="line">-i ：互动模式，在删除前会询问使用者是否动作</span><br><span class="line">-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rm -ir test1    // 删除之前询问使用者是否动作</span><br><span class="line">examine files in directory test1? y</span><br></pre></td></tr></table></figure><h3 id="mv-移动文件与目录或重命名"><a href="#mv-移动文件与目录或重命名" class="headerlink" title="mv 移动文件与目录或重命名"></a>mv 移动文件与目录或重命名</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [-fiu] source destination</span><br><span class="line">mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件（destination）已经存在时，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且 source 比较新，才会升级（update）</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> mv test1 test2</span><br></pre></td></tr></table></figure><h3 id="touch-新建文件"><a href="#touch-新建文件" class="headerlink" title="touch 新建文件"></a>touch 新建文件</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> touch file    // 创建一个名为“file”的新空白文件</span><br></pre></td></tr></table></figure><h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><p>Linux 系统中使用以下命令来查看文件的内容：</p><ul><li>cat  由第一行开始显示文件内容</li><li>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写</li><li>nl  显示的时候，顺道输出行号</li><li>more  一页一页的显示文件内容</li><li>less 与 more 类似，但是可以往前翻页</li><li>head  只看头几行</li><li>tail  只看尾几行</li></ul><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>process</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> kill 12345    // 杀死进程</span><br><span class="line"><span class="meta">$</span> kill -KILL 123456    // 强制杀死进程</span><br><span class="line"><span class="meta">$</span> kill -9 123456    // 彻底杀死进程</span><br></pre></td></tr></table></figure><h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><h3 id="nohup-不挂断进程"><a href="#nohup-不挂断进程" class="headerlink" title="nohup 不挂断进程"></a>nohup 不挂断进程</h3><p>nohup (no hang up)</p><p>如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。</p><p>在缺省情况下该作业的所有输出都被重定向到一个名为<code>nohup.out</code>的文件中。</p><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> nohup java -jar ~/software/rocketmq-console-ng-1.0.1.jar &amp;    // 启动 java jar</span><br><span class="line"><span class="meta">$</span> nohup sh ~/software/rocketmq-4.6.0/bin/mqbroker -n localhost:9876 &amp;    // 启动rocketmq bocker</span><br></pre></td></tr></table></figure><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>搜索指定文件|文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 路径 -name 名称</span><br></pre></td></tr></table></figure><p>删除空文件|空文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 路径 -type d -empty|xargs -n 1 rm -rf</span><br></pre></td></tr></table></figure><h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><h2 id="备份压缩"><a href="#备份压缩" class="headerlink" title="备份压缩"></a>备份压缩</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.runoob.com/linux/linux-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-tutorial.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;可以使用 man 命令来查看各个命令的使用文档，如：man cp&lt;/p&gt;
&lt;h2 id=&quot;文件基本属性&quot;&gt;&lt;a href=&quot;#文件基本属性&quot;
      
    
    </summary>
    
      <category term="系统" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
      <category term="linux" scheme="https://yapengren.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java.util.ConcurrentModificationException 异常详解</title>
    <link href="https://yapengren.github.io/wiki/java-util-ConcurrentModificationException-%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yapengren.github.io/wiki/java-util-ConcurrentModificationException-异常详解/</id>
    <published>2019-09-20T02:11:57.000Z</published>
    <updated>2019-10-28T02:37:04.094Z</updated>
    
    <content type="html"><![CDATA[<p>环境：JDK 1.8.0</p><p>使用 iterator 遍历集合的同时对集合进行修改会报错 <code>java.util.ConcurrentModificationException</code></p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>抛异常代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Integer next = it.next();</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="number">5</span>) &#123;</span><br><span class="line">            list.remove(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>使用 Iterator 遍历 ArrayList， 抛出异常的是 iterator.next()，查看 ArrayList 的 Iterator 实现源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 next() 方法中有一个 checkForComodification() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 checkForComodification 方法是用来判断集合的修改次数是否合法。</p><p>modCount 字段用于记录集合被修改的次数，ArrayList 增删改 (add, remove, set) 时都会自增 modCount 属性。</p><p>在创建 Iterator 的时候会将 modCount 赋值给 expectedModCount，同样记录当前集合修改的次数，初始化为集合的 modCount 值。</p><p>抛异常代码中 ArrayList 添加了 10 次所以 modCount = 10；创建 Iterator 时候 expectedModCount = 10；遍历到 next == 5 时执行了 list.remove(next)，此时 modCount = 11, expectedModCount = 10;</p><p>在执行 next 方法时，判断 modCount != expectedModCount ，导致抛出异常 java.util.ConcurrentModificationException。</p><p>为什么要这么做呢？引用一段解释</p><blockquote><p>  Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。</p><p>  　　所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用 Iterator 本身的方法 remove() 来删除对象</p><p>正确代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test02() &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 1; i &lt; 11; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Integer next = it.next();</span><br><span class="line">        if (next == 5) &#123;</span><br><span class="line">            // 使用 Iterator 本身的方法 remove() 来删除对象</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.cnblogs.com/xujian2014/p/5846128.html" target="_blank" rel="noopener">https://www.cnblogs.com/xujian2014/p/5846128.html</a></p><p>  <a href="https://www.cnblogs.com/snowater/p/8024776.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowater/p/8024776.html</a></p><p>  <a href="https://www.iteye.com/blog/lz12366-675016" target="_blank" rel="noopener">https://www.iteye.com/blog/lz12366-675016</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：JDK 1.8.0&lt;/p&gt;
&lt;p&gt;使用 iterator 遍历集合的同时对集合进行修改会报错 &lt;code&gt;java.util.ConcurrentModificationException&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现
      
    
    </summary>
    
      <category term="java" scheme="https://yapengren.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://yapengren.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis foreach 批量操作</title>
    <link href="https://yapengren.github.io/wiki/Mybatis%20foreach%20%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    <id>https://yapengren.github.io/wiki/Mybatis foreach 批量操作/</id>
    <published>2019-09-16T07:10:48.000Z</published>
    <updated>2019-12-12T09:05:50.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-foreach-遍历传递进来的集合"><a href="#mybatis-foreach-遍历传递进来的集合" class="headerlink" title="mybatis foreach 遍历传递进来的集合"></a>mybatis foreach 遍历传递进来的集合</h1><h2 id="mapper-接口"><a href="#mapper-接口" class="headerlink" title="mapper 接口"></a>mapper 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">getEmpsByConditions</span><span class="params">(@Param(<span class="string">"list"</span>)</span> List&lt;Integer&gt; idList)</span>;</span><br></pre></td></tr></table></figure><h2 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意返回的数据类型是集合中保存的数据类型 Employee--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditions"</span> <span class="attr">resultType</span>=<span class="string">"com.jas.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">SELECT * FROM t_employee WHERE id IN </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">collection：指定要遍历的集合</span></span><br><span class="line"><span class="comment">item:取出当前集合中元素，赋给 item 中的值</span></span><br><span class="line"><span class="comment">    separator：遍历出的多个元素之间用什么分隔符分隔开</span></span><br><span class="line"><span class="comment">    open：遍历集合前用什么字符进行拼接</span></span><br><span class="line"><span class="comment">    close：遍历集合后用什么字符进行拼接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在 foreach 标签中还有一个属性 index，</span></span><br><span class="line"><span class="comment">    遍历集合的时候 index 表示的是当前元素的索引，item 对应索引中的值</span></span><br><span class="line"><span class="comment">    遍历 map 的时候 index 表示的是当前 map 中的 key，item 是 key 对应的 value</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">#&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="foreach-批量插入数据"><a href="#foreach-批量插入数据" class="headerlink" title="foreach 批量插入数据"></a>foreach 批量插入数据</h1><h2 id="mapper-接口-1"><a href="#mapper-接口-1" class="headerlink" title="mapper 接口"></a>mapper 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">addEmpsByList</span><span class="params">(@Param(<span class="string">"list"</span>)</span> List&lt;Employee&gt; list)</span>;</span><br></pre></td></tr></table></figure><h2 id="mapper-xml-1"><a href="#mapper-xml-1" class="headerlink" title="mapper.xml"></a>mapper.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmpsByList"</span> <span class="attr">parameterType</span>=<span class="string">"com.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">INSERT INTO t_employee(username, gender, email) VALUES </span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">(#&#123;item.username&#125;, #&#123;item.gender&#125;, #&#123;item.email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="执行多条-SQL-批量插入数据"><a href="#执行多条-SQL-批量插入数据" class="headerlink" title="执行多条 SQL 批量插入数据"></a>执行多条 SQL 批量插入数据</h1><h2 id="mapper-xml-2"><a href="#mapper-xml-2" class="headerlink" title="mapper.xml"></a>mapper.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmpsByList"</span> <span class="attr">parameterType</span>=<span class="string">"com.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">每插入一条数据就执行一次 SQL，中间用";"分隔开 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">INSERT INTO t_employee(username, gender, email) VALUES </span><br><span class="line">(#&#123;item.username&#125;, #&#123;item.gender&#125;, #&#123;item.email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MySql 默认的情况下是不支持使用<code>;</code>分隔开多条 SQL 进行执行的，程序会报错<code>org.springframework.jdbc.BadSqlGrammarException</code>，Mybatic 批量操作必须加上参数 <code>&amp;allowMultiQueries=true</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">community.jdbc.url=jdbc:mysql://172.25.28.8:3306/jr_community?createDatabaseIfNotExist=true&amp;amp;characterEncoding=utf-8&amp;amp;useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true</span><br><span class="line">community.jdbc.username=</span><br><span class="line">community.jdbc.password=</span><br></pre></td></tr></table></figure><p>参数意思是允许多查询</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis-foreach-遍历传递进来的集合&quot;&gt;&lt;a href=&quot;#mybatis-foreach-遍历传递进来的集合&quot; class=&quot;headerlink&quot; title=&quot;mybatis foreach 遍历传递进来的集合&quot;&gt;&lt;/a&gt;mybatis for
      
    
    </summary>
    
      <category term="框架" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Mybatis" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="https://yapengren.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>lombok使用方法</title>
    <link href="https://yapengren.github.io/wiki/lombok%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://yapengren.github.io/wiki/lombok使用方法/</id>
    <published>2019-09-07T08:24:59.000Z</published>
    <updated>2019-12-08T06:32:37.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>注解在类上，提供类所有属性的 getter 和 setter 方法，此外还提供了equals、canEqual、hashCode、toString 方法、无参构造方法；</p><h3 id="Accessors-chain-true"><a href="#Accessors-chain-true" class="headerlink" title="@Accessors(chain = true)"></a>@Accessors(chain = true)</h3><p>注解在类上，使用链式设置属性；</p><h3 id="Setter"><a href="#Setter" class="headerlink" title="@Setter"></a>@Setter</h3><p>注解在属性上，为单个属性提供 setter 方法、无参构造方法；</p><p>注解在类上，为该类所有的属性提供 setter 方法、无参构造方法；</p><h3 id="Getter"><a href="#Getter" class="headerlink" title="@Getter"></a>@Getter</h3><p>注解在属性上，为单个属性提供 getter 方法、无参构造方法；</p><p>注解在类上，为该类所有的属性提供 getter 方法、无参构造方法；</p><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="@Log4j"></a>@Log4j</h3><p>注解在类上，为类提供一个 属性名为 log 的 log4j 日志对象，提供无参构造方法；</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>注解在类上，为类提供一个全参构造方法，加了这个注解后，类中不提供无参构造方法；</p><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>注解在类上，为类提供一个无参构造方法；</p><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>注解在类上，可以生成 equals、canEqual、hashCode 方法；</p><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><p>注解在属性上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个无参构造方法；</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>注解在类上，可以生成所有参数的 toString 方法，还会无参构造方法；</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>注解在类上，会生成全参构造方法，getter 方法，此外还提供了equals、hashCode、toString 方法；</p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h3><p>这个注解用在类方法或者实例方法上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 class 对象和 this 对象，而 @Synchronized 的锁对象分别是 私有静态 final 对象 lock 和 私有 final 对象 lock，当然，也可以自己指定锁对象，此外也提供无参构造方法；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Data&quot;&gt;&lt;a href=&quot;#Data&quot; class=&quot;headerlink&quot; title=&quot;@Data&quot;&gt;&lt;/a&gt;@Data&lt;/h3&gt;&lt;p&gt;注解在类上，提供类所有属性的 getter 和 setter 方法，此外还提供了equals、canEqual、hash
      
    
    </summary>
    
      <category term="框架" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://yapengren.github.io/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://yapengren.github.io/wiki/冒泡排序/</id>
    <published>2019-09-03T06:34:04.000Z</published>
    <updated>2019-10-28T02:51:49.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>冒泡排序（Bubble Sort）需要重复的走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，使值较大的元素逐渐从前移向后边。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6mbx8snqyg30my075wqv.gif" alt="冒泡排序 Bubble Sort"></p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤 1 ～ 3，直到没有任何一对数字需要比较</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>  <a href="http://cmsblogs.com/?p=4697" target="_blank" rel="noopener">http://cmsblogs.com/?p=4697</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;冒泡排序（Bubble Sort）需要重复的走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，使值较大
      
    
    </summary>
    
      <category term="算法" scheme="https://yapengren.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://yapengren.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="https://yapengren.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组sparsearray</title>
    <link href="https://yapengren.github.io/wiki/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84sparsearray/"/>
    <id>https://yapengren.github.io/wiki/稀疏数组sparsearray/</id>
    <published>2019-09-01T06:37:41.000Z</published>
    <updated>2019-10-28T02:51:25.267Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>编写的五子棋程序中，有存盘退出和续上盘的功能。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jtgf40z1j30zw0fcgp7.jpg" alt="稀疏数组需求" style="zoom:50%;"><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据</p><h3 id="稀疏数组基本介绍"><a href="#稀疏数组基本介绍" class="headerlink" title="稀疏数组基本介绍"></a>稀疏数组基本介绍</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><h3 id="稀疏数组处理方法"><a href="#稀疏数组处理方法" class="headerlink" title="稀疏数组处理方法"></a>稀疏数组处理方法</h3><ol><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ol><h3 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jthducssj30r20k0q7p.jpg" alt="稀疏数组举例说明" style="zoom:50%;"><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><ol><li>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</li><li>把稀疏数组存盘，并且可以重新恢复原来的二维数组数</li></ol><h3 id="整体思路分析"><a href="#整体思路分析" class="headerlink" title="整体思路分析"></a>整体思路分析</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jtib2spsj31gi0e2n21.jpg" alt="稀疏数组整体思路分析" style="zoom:50%;"><p>原始的二维数组 –&gt; 稀疏数组的思路</p><ol><li><p>遍历原始的二维数组，得到有效数据的个数 sum</p></li><li><p>根据 sum 可以创建稀疏数组 <code>sparseArr int[sum + 1][3]</code></p></li><li><p>将二维数组的有效数据存入到稀疏数组</p></li></ol><p>稀疏数组 –&gt; 原始的二维数组的思路</p><ol><li><p>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如 <code>int[][] chessArr = new int[11][11]</code></p></li><li><p>在读取稀疏数组后几行的数据，并赋给原始的二维数组</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">// 0表示没有棋子，1表示黑棋，2表示蓝棋</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">"原始的二维数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始的二维数组 --&gt; 稀疏数组的思路</span></span><br><span class="line">        <span class="comment">// 1、遍历二维数组，得到非 0 数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">// 3、遍历二维数组，将非 0 数据存入 sparseArr</span></span><br><span class="line">        <span class="comment">// count 用于记录是第几个非 0 数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"稀疏数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稀疏数组 --&gt; 原始的二维数组的思路</span></span><br><span class="line">        <span class="comment">// 1.  先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如 int[][] chessArr = new int[11][11]</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 2.  在读取稀疏数组后几行的数据，并赋给原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;编写的五子棋程序中，有存盘退出和续上盘的功能。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00
      
    
    </summary>
    
      <category term="算法" scheme="https://yapengren.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://yapengren.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="https://yapengren.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础题</title>
    <link href="https://yapengren.github.io/wiki/java%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>https://yapengren.github.io/wiki/java基础题/</id>
    <published>2019-09-01T01:38:39.000Z</published>
    <updated>2019-12-13T02:36:58.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">    System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">    System.out.println(<span class="string">"j="</span> + j);</span><br><span class="line">    System.out.println(<span class="string">"k="</span> + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i=4</span><br><span class="line">j=1</span><br><span class="line">k=11</span><br></pre></td></tr></table></figure><p>i++：先使用再 +1</p><p>++i：先 +1 再使用</p><h1 id="初始化和实例初始化"><a href="#初始化和实例初始化" class="headerlink" title="初始化和实例初始化"></a>初始化和实例初始化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Father 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Father 实例代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father 普通方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father 静态方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 实例代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 普通方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 静态方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Father 静态方法</span><br><span class="line">Father 静态代码块</span><br><span class="line">Son 静态方法</span><br><span class="line">Son 静态代码块</span><br><span class="line">Son 普通方法</span><br><span class="line">Father 实例代码块</span><br><span class="line">Father 构造方法</span><br><span class="line">Son 普通方法</span><br><span class="line">Son 实例代码块</span><br><span class="line">Son 构造方法</span><br><span class="line">-----</span><br><span class="line">Son 普通方法</span><br><span class="line">Father 实例代码块</span><br><span class="line">Father 构造方法</span><br><span class="line">Son 普通方法</span><br><span class="line">Son 实例代码块</span><br><span class="line">Son 构造方法</span><br></pre></td></tr></table></figure><h1 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Integer num = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"i=  "</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"str=  "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"num=  "</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"arr=  "</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">"my.a=  "</span> + my.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a, MyData m)</span> </span>&#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">"world"</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i=  1</span><br><span class="line">str=  hello</span><br><span class="line">num=  200</span><br><span class="line">arr=  [2, 2, 3, 4, 5]</span><br><span class="line">my.a=  11</span><br></pre></td></tr></table></figure><h1 id="List-分批代码"><a href="#List-分批代码" class="headerlink" title="List 分批代码"></a>List 分批代码</h1><p>当 List 集合数据量比较大时，需要对集合分组，分批处理数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        list.add(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分组长度</span></span><br><span class="line">    <span class="keyword">int</span> groupSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">int</span> count = size % groupSize == <span class="number">0</span> ? size / groupSize : size / groupSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fromIndex = i * groupSize;</span><br><span class="line">        <span class="keyword">int</span> toIndex = (i + <span class="number">1</span>) * groupSize &gt; size ? size : (i + <span class="number">1</span>) * groupSize;</span><br><span class="line">        List&lt;String&gt; subList = list.subList(fromIndex, toIndex);</span><br><span class="line">        System.out.println(subList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自增变量&quot;&gt;&lt;a href=&quot;#自增变量&quot; class=&quot;headerlink&quot; title=&quot;自增变量&quot;&gt;&lt;/a&gt;自增变量&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://yapengren.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://yapengren.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库三范式</title>
    <link href="https://yapengren.github.io/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
    <id>https://yapengren.github.io/wiki/数据库三范式/</id>
    <published>2019-08-27T09:58:46.000Z</published>
    <updated>2019-12-14T09:24:55.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><h3 id="第一范式-1st-NF－列都是不可再分"><a href="#第一范式-1st-NF－列都是不可再分" class="headerlink" title="第一范式(1st NF－列都是不可再分)"></a>第一范式(1st NF－列都是不可再分)</h3><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fan9n4muj30op05sq4c.jpg" alt="数据库第一范式"></p><h3 id="第二范式-2nd-NF－每个表只描述一件事情"><a href="#第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="第二范式(2nd NF－每个表只描述一件事情)"></a>第二范式(2nd NF－每个表只描述一件事情)</h3><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fankw6t9j30jj07cq4d.jpg" alt="数据库第二范式"></p><h3 id="第三范式-3rd-NF－不存在对非主键列的传递依赖"><a href="#第三范式-3rd-NF－不存在对非主键列的传递依赖" class="headerlink" title="第三范式(3rd NF－不存在对非主键列的传递依赖)"></a>第三范式(3rd NF－不存在对非主键列的传递依赖)</h3><p>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fanpp7gcj30jp08ejsw.jpg" alt="数据库第三范式"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库三范式&quot;&gt;&lt;a href=&quot;#数据库三范式&quot; class=&quot;headerlink&quot; title=&quot;数据库三范式&quot;&gt;&lt;/a&gt;数据库三范式&lt;/h2&gt;&lt;h3 id=&quot;第一范式-1st-NF－列都是不可再分&quot;&gt;&lt;a href=&quot;#第一范式-1st-NF－列都是不可再
      
    
    </summary>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://yapengren.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://yapengren.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yp_ren Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yapengren.github.io/"/>
  <updated>2019-09-22T10:00:35.837Z</updated>
  <id>https://yapengren.github.io/</id>
  
  <author>
    <name>renyapeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux 基础命令</title>
    <link href="https://yapengren.github.io/wiki/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://yapengren.github.io/wiki/linux-基础命令/</id>
    <published>2019-09-22T05:57:36.000Z</published>
    <updated>2019-09-22T10:00:35.837Z</updated>
    
    <content type="html"><![CDATA[<p>未完待填坑</p><h2 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h2><p>Linux中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ll</span><br><span class="line">total 2184</span><br><span class="line">-rw-r--r--    1 renyapeng  staff   846K  9 22 16:08 db.json</span><br><span class="line">drwxr-xr-x  315 renyapeng  staff   9.8K  8 12 14:07 node_modules</span><br><span class="line">drwxr-xr-x   21 renyapeng  staff   672B  9 22 15:28 public</span><br></pre></td></tr></table></figure><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="文件基本属性"></p><p>10位字符表示：</p><ul><li><p>0位：确定文件类型</p></li><li><p>1-3位：确定该文件的所有者对文件的权限 <strong>owner</strong></p></li><li><p>4-6位：确定所有者的同组用户拥有该文件的权限 <strong>group</strong></p></li><li><p>7-9位：确定其他用户拥有该文件的权限 <strong>others</strong></p></li></ul><p>第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等</p><ul><li><p><strong>[</strong> <strong>d</strong> <strong>]</strong> 目录</p></li><li><p><strong>[</strong> <strong>-</strong> <strong>]</strong> 文件</p></li><li><p><strong>[</strong> <strong>l</strong>  <strong>]</strong> 链接文档(link file)</p></li><li><p><strong>[</strong> <strong>b</strong> <strong>]</strong> 可供储存的接口设备(可随机存取装置)</p></li><li><p><strong>[</strong> <strong>c</strong> <strong>]</strong> 串行端口设备，例如键盘、鼠标(一次性读取装置)</p></li></ul><p>接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变</p><ul><li><strong>[ r ]</strong> 代表可读(read)</li><li><strong>[ w ]</strong> 代表可写(write)</li><li><strong>[ x ]</strong> 代表可执行(execute)</li><li><strong>[ - ]</strong> 没有权限</li></ul><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h3><p>mkdir (make directory)</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</span><br><span class="line">-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir test    // 创建新目录</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: test1/test2/test3: No such file or directory    // 不能创建多层目录</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> mkdir -p test1/test2/test3/test4    // 添加-p参数，可以创建多层目录</span><br></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>该命令用于删除文件或目录，remove之间，它的常用参数如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f：就是force的意思，忽略不存在的文件，不会出现警告消息  </span><br><span class="line">-i：互动模式，在删除前会询问用户是否操作  </span><br><span class="line">-r：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux # 查看系统所有的进程数据  </span><br><span class="line">ps ax # 查看不与terminal有关的所有进程  </span><br><span class="line">ps -lA # 查看系统所有的进程数据  </span><br><span class="line">ps axjf # 查看连同一部分进程树状态</span><br></pre></td></tr></table></figure><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -signal PID</span><br></pre></td></tr></table></figure><h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">killall -signal PID</span><br></pre></td></tr></table></figure><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file filename  </span><br><span class="line">例如：  </span><br><span class="line">file ./test</span><br></pre></td></tr></table></figure><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat text | less # 查看text文件中的内容  </span><br><span class="line"></span><br><span class="line">这条命令也可以使用less text来代替</span><br></pre></td></tr></table></figure><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>搜索指定文件|文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 路径 -name 名称</span><br></pre></td></tr></table></figure><p>删除空文件|空文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 路径 -type d -empty|xargs -n 1 rm -rf</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.runoob.com/linux/linux-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-tutorial.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;未完待填坑&lt;/p&gt;
&lt;h2 id=&quot;文件基本属性&quot;&gt;&lt;a href=&quot;#文件基本属性&quot; class=&quot;headerlink&quot; title=&quot;文件基本属性&quot;&gt;&lt;/a&gt;文件基本属性&lt;/h2&gt;&lt;p&gt;Linux中我们可以使用 &lt;code&gt;ll&lt;/code&gt; 或者 &lt;code&gt;ls 
      
    
    </summary>
    
      <category term="系统知识" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="linux" scheme="https://yapengren.github.io/categories/%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/linux/"/>
    
    
      <category term="linux" scheme="https://yapengren.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java.util.ConcurrentModificationException 异常详解</title>
    <link href="https://yapengren.github.io/wiki/java-util-ConcurrentModificationException-%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yapengren.github.io/wiki/java-util-ConcurrentModificationException-异常详解/</id>
    <published>2019-09-20T02:11:57.000Z</published>
    <updated>2019-09-20T07:30:22.259Z</updated>
    
    <content type="html"><![CDATA[<p>环境：JDK 1.8.0</p><p>使用 iterator 遍历集合的同时对集合进行修改会报错 <code>java.util.ConcurrentModificationException</code></p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>抛异常代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Integer next = it.next();</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="number">5</span>) &#123;</span><br><span class="line">            list.remove(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>使用 Iterator 遍历 ArrayList， 抛出异常的是 iterator.next()，查看 ArrayList 的 Iterator 实现源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 next() 方法中有一个 checkForComodification() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 checkForComodification 方法是用来判断集合的修改次数是否合法。</p><p>modCount 字段用于记录集合被修改的次数，ArrayList 增删改 (add, remove, set) 时都会自增 modCount 属性。</p><p>在创建 Iterator 的时候会将 modCount 赋值给 expectedModCount，同样记录当前集合修改的次数，初始化为集合的 modCount 值。</p><p>抛异常代码中 ArrayList 添加了 10 次所以 modCount = 10；创建 Iterator 时候 expectedModCount = 10；遍历到 next == 5 时执行了 list.remove(next)，此时 modCount = 11, expectedModCount = 10;</p><p>在执行 next 方法时，判断 modCount != expectedModCount ，导致抛出异常 java.util.ConcurrentModificationException。</p><p>为什么要这么做呢？引用一段解释</p><blockquote><p>  Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。</p><p>  　　所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用 Iterator 本身的方法 remove() 来删除对象</p><p>正确代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test02() &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 1; i &lt; 11; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Integer next = it.next();</span><br><span class="line">        if (next == 5) &#123;</span><br><span class="line">            // 使用 Iterator 本身的方法 remove() 来删除对象</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.cnblogs.com/xujian2014/p/5846128.html" target="_blank" rel="noopener">https://www.cnblogs.com/xujian2014/p/5846128.html</a></p><p>  <a href="https://www.cnblogs.com/snowater/p/8024776.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowater/p/8024776.html</a></p><p>  <a href="https://www.iteye.com/blog/lz12366-675016" target="_blank" rel="noopener">https://www.iteye.com/blog/lz12366-675016</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：JDK 1.8.0&lt;/p&gt;
&lt;p&gt;使用 iterator 遍历集合的同时对集合进行修改会报错 &lt;code&gt;java.util.ConcurrentModificationException&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis 批量操作报错 BadSqlGrammarException</title>
    <link href="https://yapengren.github.io/wiki/Mybatis-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%8A%A5%E9%94%99-BadSqlGrammarException/"/>
    <id>https://yapengren.github.io/wiki/Mybatis-批量操作报错-BadSqlGrammarException/</id>
    <published>2019-09-16T07:10:48.000Z</published>
    <updated>2019-09-16T08:27:58.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Mybatis 使用<code>&lt;foreach&gt;</code>批量操作时，对应的 sql 文件为</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"testBatchUpd"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"dmsProdSkuStocks"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">        UPDATE dms_prod_sku_stock SET </span><br><span class="line">        STOCK = #&#123;item.stock&#125; </span><br><span class="line">        WHERE SKU_RELATE_ID = #&#123;item.skuRelateId&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用接口执行的时候，程序就会报错</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">org.springframework.jdbc.BadSqlGrammarException</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>用 Mybatic 批量操作必须加上参数 <code>&amp;allowMultiQueries=true</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>添加参数 <code>&amp;allowMultiQueries=true</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">community.jdbc.url=jdbc:mysql://172.25.28.8:3306/jr_community?createDatabaseIfNotExist=true&amp;amp;characterEncoding=utf-8&amp;amp;useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true</span><br><span class="line">community.jdbc.username=</span><br><span class="line">community.jdbc.password=</span><br></pre></td></tr></table></figure><p>参数意思是允许多查询</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;Mybatis 使用&lt;code&gt;&amp;lt;foreach&amp;gt;&lt;/code&gt;批量操作时，对应的 sql 文件为&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="mybatis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/mybatis/"/>
    
    
      <category term="mybatis" scheme="https://yapengren.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>lombok 使用方法</title>
    <link href="https://yapengren.github.io/wiki/lombok-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://yapengren.github.io/wiki/lombok-使用方法/</id>
    <published>2019-09-07T08:24:59.000Z</published>
    <updated>2019-09-07T09:02:56.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>注解在类上，提供类所有属性的 getter 和 setter 方法，此外还提供了equals、canEqual、hashCode、toString 方法、无参构造方法；</p><h3 id="Accessors-chain-true"><a href="#Accessors-chain-true" class="headerlink" title="@Accessors(chain = true)"></a>@Accessors(chain = true)</h3><p>注解在类上，使用链式设置属性；</p><h3 id="Setter"><a href="#Setter" class="headerlink" title="@Setter"></a>@Setter</h3><p>注解在属性上，为单个属性提供 setter 方法、无参构造方法；</p><p>注解在类上，为该类所有的属性提供 setter 方法、无参构造方法；</p><h3 id="Getter"><a href="#Getter" class="headerlink" title="@Getter"></a>@Getter</h3><p>注解在属性上，为单个属性提供 getter 方法、无参构造方法；</p><p>注解在类上，为该类所有的属性提供 getter 方法、无参构造方法；</p><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="@Log4j"></a>@Log4j</h3><p>注解在类上，为类提供一个 属性名为 log 的 log4j 日志对象，提供无参构造方法；</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>注解在类上，为类提供一个全参构造方法，加了这个注解后，类中不提供无参构造方法；</p><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>注解在类上，为类提供一个无参构造方法；</p><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>注解在类上，可以生成 equals、canEqual、hashCode 方法；</p><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><p>注解在属性上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个无参构造方法；</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>注解在类上，可以生成所有参数的 toString 方法，还会无参构造方法；</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>注解在类上，会生成全参构造方法，getter 方法，此外还提供了equals、hashCode、toString 方法；</p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h3><p>这个注解用在类方法或者实例方法上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 class 对象和 this 对象，而 @Synchronized 的锁对象分别是 私有静态 final 对象 lock 和 私有 final 对象 lock，当然，也可以自己指定锁对象，此外也提供无参构造方法；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Data&quot;&gt;&lt;a href=&quot;#Data&quot; class=&quot;headerlink&quot; title=&quot;@Data&quot;&gt;&lt;/a&gt;@Data&lt;/h3&gt;&lt;p&gt;注解在类上，提供类所有属性的 getter 和 setter 方法，此外还提供了equals、canEqual、hash
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="spring" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/spring/"/>
    
    
      <category term="spring" scheme="https://yapengren.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://yapengren.github.io/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://yapengren.github.io/wiki/冒泡排序/</id>
    <published>2019-09-03T06:34:04.000Z</published>
    <updated>2019-09-03T07:08:48.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>冒泡排序（Bubble Sort）需要重复的走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，使值较大的元素逐渐从前移向后边。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6mbx8snqyg30my075wqv.gif" alt="冒泡排序 Bubble Sort"></p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤 1 ～ 3，直到没有任何一对数字需要比较</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>  <a href="http://cmsblogs.com/?p=4697" target="_blank" rel="noopener">http://cmsblogs.com/?p=4697</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;冒泡排序（Bubble Sort）需要重复的走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，使值较大
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="算法" scheme="https://yapengren.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组 sparsearray</title>
    <link href="https://yapengren.github.io/wiki/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84-sparsearray/"/>
    <id>https://yapengren.github.io/wiki/稀疏数组-sparsearray/</id>
    <published>2019-09-01T06:37:41.000Z</published>
    <updated>2019-09-03T10:28:07.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>编写的五子棋程序中，有存盘退出和续上盘的功能。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jtgf40z1j30zw0fcgp7.jpg" alt="稀疏数组需求"></p><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据</p><h3 id="稀疏数组基本介绍"><a href="#稀疏数组基本介绍" class="headerlink" title="稀疏数组基本介绍"></a>稀疏数组基本介绍</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><h3 id="稀疏数组处理方法"><a href="#稀疏数组处理方法" class="headerlink" title="稀疏数组处理方法"></a>稀疏数组处理方法</h3><ol><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ol><h3 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jthducssj30r20k0q7p.jpg" alt="稀疏数组举例说明"></p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><ol><li>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</li><li>把稀疏数组存盘，并且可以重新恢复原来的二维数组数</li></ol><h3 id="整体思路分析"><a href="#整体思路分析" class="headerlink" title="整体思路分析"></a>整体思路分析</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jtib2spsj31gi0e2n21.jpg" alt="稀疏数组整体思路分析"></p><p>原始的二维数组 –&gt; 稀疏数组的思路</p><ol><li><p>遍历原始的二维数组，得到有效数据的个数 sum</p></li><li><p>根据 sum 可以创建稀疏数组 <code>sparseArr int[sum + 1][3]</code></p></li><li><p>将二维数组的有效数据存入到稀疏数组</p></li></ol><p>稀疏数组 –&gt; 原始的二维数组的思路</p><ol><li><p>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如 <code>int[][] chessArr = new int[11][11]</code></p></li><li><p>在读取稀疏数组后几行的数据，并赋给原始的二维数组</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">// 0表示没有棋子，1表示黑棋，2表示蓝棋</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">"原始的二维数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始的二维数组 --&gt; 稀疏数组的思路</span></span><br><span class="line">        <span class="comment">// 1、遍历二维数组，得到非 0 数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">// 3、遍历二维数组，将非 0 数据存入 sparseArr</span></span><br><span class="line">        <span class="comment">// count 用于记录是第几个非 0 数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"稀疏数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稀疏数组 --&gt; 原始的二维数组的思路</span></span><br><span class="line">        <span class="comment">// 1.  先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如 int[][] chessArr = new int[11][11]</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 2.  在读取稀疏数组后几行的数据，并赋给原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;编写的五子棋程序中，有存盘退出和续上盘的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="数据结构" scheme="https://yapengren.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java 基础题</title>
    <link href="https://yapengren.github.io/wiki/java-%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>https://yapengren.github.io/wiki/java-基础题/</id>
    <published>2019-09-01T01:38:39.000Z</published>
    <updated>2019-09-01T01:39:49.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">    System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">    System.out.println(<span class="string">"j="</span> + j);</span><br><span class="line">    System.out.println(<span class="string">"k="</span> + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i=4</span><br><span class="line">j=1</span><br><span class="line">k=11</span><br></pre></td></tr></table></figure><p>i++：先使用再 +1</p><p>++i：先 +1 再使用</p><h3 id="初始化和实例初始化"><a href="#初始化和实例初始化" class="headerlink" title="初始化和实例初始化"></a>初始化和实例初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 实例代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 普通方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facther 静态方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 实例代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 普通方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son 静态方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Facther 静态方法</span><br><span class="line">Facther 静态代码块</span><br><span class="line">Son 静态方法</span><br><span class="line">Son 静态代码块</span><br><span class="line">Son 普通方法</span><br><span class="line">Facther 实例代码块</span><br><span class="line">Facther 构造方法</span><br><span class="line">Son 普通方法</span><br><span class="line">Son 实例代码块</span><br><span class="line">Son 构造方法</span><br><span class="line">-----</span><br><span class="line">Son 普通方法</span><br><span class="line">Facther 实例代码块</span><br><span class="line">Facther 构造方法</span><br><span class="line">Son 普通方法</span><br><span class="line">Son 实例代码块</span><br><span class="line">Son 构造方法</span><br></pre></td></tr></table></figure><h3 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Integer num = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"i=  "</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"str=  "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"num=  "</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"arr=  "</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">"my.a=  "</span> + my.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a, MyData m)</span> </span>&#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">"world"</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i=  1</span><br><span class="line">str=  hello</span><br><span class="line">num=  200</span><br><span class="line">arr=  [2, 2, 3, 4, 5]</span><br><span class="line">my.a=  11</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;自增变量&quot;&gt;&lt;a href=&quot;#自增变量&quot; class=&quot;headerlink&quot; title=&quot;自增变量&quot;&gt;&lt;/a&gt;自增变量&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库知识点</title>
    <link href="https://yapengren.github.io/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/数据库知识点/</id>
    <published>2019-08-27T09:58:46.000Z</published>
    <updated>2019-09-05T01:08:10.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><h3 id="第一范式-1st-NF－列都是不可再分"><a href="#第一范式-1st-NF－列都是不可再分" class="headerlink" title="第一范式(1st NF－列都是不可再分)"></a>第一范式(1st NF－列都是不可再分)</h3><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fan9n4muj30op05sq4c.jpg" alt="数据库第一范式"></p><h3 id="第二范式-2nd-NF－每个表只描述一件事情"><a href="#第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="第二范式(2nd NF－每个表只描述一件事情)"></a>第二范式(2nd NF－每个表只描述一件事情)</h3><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fankw6t9j30jj07cq4d.jpg" alt="数据库第二范式"></p><h3 id="第三范式-3rd-NF－不存在对非主键列的传递依赖"><a href="#第三范式-3rd-NF－不存在对非主键列的传递依赖" class="headerlink" title="第三范式(3rd NF－不存在对非主键列的传递依赖)"></a>第三范式(3rd NF－不存在对非主键列的传递依赖)</h3><p>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6fanpp7gcj30jp08ejsw.jpg" alt="数据库第三范式"></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="MySQL-中FIND-IN-SET-和IN区别简析"><a href="#MySQL-中FIND-IN-SET-和IN区别简析" class="headerlink" title="MySQL 中FIND_IN_SET()和IN区别简析"></a><a href="https://www.jb51.net/article/125744.htm" target="_blank" rel="noopener">MySQL 中FIND_IN_SET()和IN区别简析</a></h3><h3 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html" target="_blank" rel="noopener">MySQL Explain详解</a></h3><h3 id="MySQL中concat以及group-concat的使用"><a href="#MySQL中concat以及group-concat的使用" class="headerlink" title="MySQL中concat以及group_concat的使用"></a><a href="https://blog.csdn.net/mary19920410/article/details/76545053" target="_blank" rel="noopener">MySQL中concat以及group_concat的使用</a></h3><h3 id="MySQL中order-by语句对null字段的排序"><a href="#MySQL中order-by语句对null字段的排序" class="headerlink" title="MySQL中order by语句对null字段的排序"></a><a href="https://www.cnblogs.com/Wcy100/p/5376399.html" target="_blank" rel="noopener">MySQL中order by语句对null字段的排序</a></h3><h2 id="SQL练习"><a href="#SQL练习" class="headerlink" title="SQL练习"></a>SQL练习</h2><h3 id="MySQL经典练习题及答案，常用SQL语句练习50题"><a href="#MySQL经典练习题及答案，常用SQL语句练习50题" class="headerlink" title="MySQL经典练习题及答案，常用SQL语句练习50题"></a><a href="https://blog.csdn.net/qq_41936662/article/details/80393172" target="_blank" rel="noopener">MySQL经典练习题及答案，常用SQL语句练习50题</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库三范式&quot;&gt;&lt;a href=&quot;#数据库三范式&quot; class=&quot;headerlink&quot; title=&quot;数据库三范式&quot;&gt;&lt;/a&gt;数据库三范式&lt;/h2&gt;&lt;h3 id=&quot;第一范式-1st-NF－列都是不可再分&quot;&gt;&lt;a href=&quot;#第一范式-1st-NF－列都是不可再
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务知识点</title>
    <link href="https://yapengren.github.io/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/数据库事务知识点/</id>
    <published>2019-08-27T09:20:07.000Z</published>
    <updated>2019-09-05T01:49:47.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库事务概念"><a href="#数据库事务概念" class="headerlink" title="数据库事务概念"></a>数据库事务概念</h2><h3 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h3><p>事务（transaction）是指逻辑上对数据的一组操作， 这组操作要么全部成功，要么全部失败，是不可分割的一个工作单位。</p><h2 id="数据库事务的-4-个基本性质（ACID）"><a href="#数据库事务的-4-个基本性质（ACID）" class="headerlink" title="数据库事务的 4 个基本性质（ACID）"></a>数据库事务的 4 个基本性质（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务的原子性是指事务是一个不可分割的工作单位，这组操作要么全部成功，要么全部失败。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>在事务开始以前，被操作的数据的完整性处于一致性的状态，事务结束后，被操作的数据的完整性也必须处于一致性状态。</p><p>拿银行转账来说，一致性要求事务的执行不应改变A、B 两个账户的金额总和。如果没有这种一致性要求，转账过程中就会发生钱无中生有，或者不翼而飞的现象。事务应该把数据库从一个一致性状态转换到另外一个一致性状态。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>事务隔离性要求系统必须保证事务不受其他并发执行的事务的影响，也即要达到这样一种效果：对于任何一对事务T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前已经结束，要么在 T1 完成之后才开始执行。这样，每个事务都感觉不到系统中有其他事务在并发地执行。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>一个事务一旦成功提交，它对数据库的改变必须是永久的，即便是数据库发生故障也应该不回对其产生任何影响。</p><h2 id="数据库事务的-4-种隔离级别"><a href="#数据库事务的-4-种隔离级别" class="headerlink" title="数据库事务的 4 种隔离级别"></a>数据库事务的 4 种隔离级别</h2><h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是 3.6 万/月。但是发工资时老板不小心按错了数字，按成 3.9 万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了 3 千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成 3.6 万再提交。</p><p>分析：实际程序员这个月的工资还是 3.6 万，但是程序员看到的是 3.9 万。他看到的是老板还没提交事务时的数据，这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有 3.6 万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有 3.6 万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新 UPDATE 操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有 3.6 万），当他埋单时（事务开启，不允许其他事务的 UPDATE 修改操作），收费系统事先检测到他的卡里有 3.6 万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即 UPDATE 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 INSERT 操作，而不是 UPDATE 操作。</p><p>什么时候会出现幻读？</p><p>事例：程序员某一天去消费，花了 2 千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了 2 千元，就在这个时候，程序员花了 1 万买了一部电脑，即新增 INSERT 了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://blog.csdn.net/mfl0315/article/details/51981792" target="_blank" rel="noopener">https://blog.csdn.net/mfl0315/article/details/51981792</a></p><p>  <a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">https://blog.csdn.net/qq_33290787/article/details/51924963</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库事务概念&quot;&gt;&lt;a href=&quot;#数据库事务概念&quot; class=&quot;headerlink&quot; title=&quot;数据库事务概念&quot;&gt;&lt;/a&gt;数据库事务概念&lt;/h2&gt;&lt;h3 id=&quot;什么是数据库事务&quot;&gt;&lt;a href=&quot;#什么是数据库事务&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引知识点</title>
    <link href="https://yapengren.github.io/wiki/MySQL-%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/MySQL-索引知识点/</id>
    <published>2019-08-25T03:44:17.000Z</published>
    <updated>2019-08-25T08:54:22.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><ol><li>全值匹配</li><li>最佳左前缀法则。如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列</li><li>不在索引列上做任何操作（计算、函数、「自动或者手动」类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引（只访问索引的查询「索引列和查询列一致」），减少 select *</li><li>MySQL 在使用 != 或者 &lt;&gt; 的时候无法使用索引会导致全表扫描</li><li>is null，is not null 无法使用索引</li><li>like 以通配符开头 (‘%abc…’) MySQL 索引失效会变成全表扫描的操作</li><li>字符串不加单引号索引失效</li><li>少用 or，用它来连接时会索引失效 </li></ol><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>假设 index(a, b, c)</p><table><thead><tr><th align="left">Where 语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td align="left">where a = 3</td><td>Y，使用到 a</td></tr><tr><td align="left">where a = 3 and b = 5</td><td>Y，使用到 a，b</td></tr><tr><td align="left">where a = 3 and b = 5 and c = 4</td><td>Y，使用到 a，b，c</td></tr><tr><td align="left">where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td><td>N</td></tr><tr><td align="left">where a = 3 and c = 5</td><td>使用到 a，但是 c 不可以，b 中间断了</td></tr><tr><td align="left">where a = 3 and b &gt; 4 and c = 5</td><td>使用到 a 和 b，c 不能用在范围之后，b 断了</td></tr><tr><td align="left">where a = 3 and b like ‘kk%’ and c = 4</td><td>Y，使用到 a，b，c</td></tr><tr><td align="left">where a = 3 and b like ‘%kk’ and c = 4</td><td>Y，只用到 a</td></tr><tr><td align="left">where a = 3 and b like ‘%kk%’ and c = 4</td><td>Y，只用到 a</td></tr><tr><td align="left">where a = 3 and b like ‘k%kk%’ and c = 4</td><td>Y，只用到 a，b，c</td></tr></tbody></table><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  创建表</span><br><span class="line">create table test03(</span><br><span class="line"> id int primary key not null auto_increment,</span><br><span class="line"> c1 char(10),</span><br><span class="line"> c2 char(10),</span><br><span class="line"> c3 char(10),</span><br><span class="line"> c4 char(10),</span><br><span class="line"> c5 char(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;a1&apos;,&apos;a2&apos;,&apos;a3&apos;,&apos;a4&apos;,&apos;a5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;b1&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;b4&apos;,&apos;b5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;,&apos;c5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;d1&apos;,&apos;d2&apos;,&apos;d3&apos;,&apos;d4&apos;,&apos;d5&apos;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5)values(&apos;e1&apos;,&apos;e2&apos;,&apos;e3&apos;,&apos;e4&apos;,&apos;e5&apos;);</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">create index idx_test03_c1234 on test03(c1,c2,c3,c4);</span><br></pre></td></tr></table></figure><p>问题：我们创建了复合索引idx_test03_c1234 ，根据以下SQL分析索引使用情况？</p><ol><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4=’a4’;<br>索引全部使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxein3zpj31v407y0wj.jpg" alt="image-20190825145131921"></p><ol start="2"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ and c3=’a3’;<br>索引全部使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxkebwxfj31v4088n11.jpg" alt="image-20190825145307176"></p><ol start="3"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3&gt;’a3’ and c4=’a4’;<br>索引 c1c2c3 使用，c4 未使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxjkp44uj31ua07w42g.jpg" alt="image-20190825145614418"></p><ol start="4"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4&gt;’a4’ and c3=’a3’;<br>索引全部使用 </li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxjyb630j31uo07yae1.jpg" alt="image-20190825145645207"></p><ol start="5"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c4=’a4’ order by c3;<br>索引 c1c2 使用，c3 作用在排序而不是查找，c4 不使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxlhdwq5j31wy08642j.jpg" alt="image-20190825145812889"></p><ol start="6"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ order by c3;<br>索引 c1c2 使用 c3 作用在排序而不是查找，和 5 题一样</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxm32cxcj31x6088n16.jpg" alt="image-20190825145848614"></p><ol start="7"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ order by c4;<br>索引 c1c2 使用 ，但出现 Using filesort</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxn1x2g4j323u08ctcz.jpg" alt="image-20190825145943711"></p><ol start="8"><li>explain select * from test03 where c1=’a1’ and c5=’a5’ order by c2,c3;<br>索引 c1 使用，但是 c2，c3用于排序，无 filesort</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxnorlcwj320408aq74.jpg" alt="image-20190825150020427"></p><p>explain select * from test03 where c1=’a1’ and c5=’a5’ order by c3,c2;<br>索引 c1 使用，出现 filesort，我们建立索引 1234，它没有按照顺序来，3 2 颠倒了 </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxo1umiyj327a08678m.jpg" alt="image-20190825150041613"></p><ol start="9"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ order by c2,c3;<br>索引 c1c2 使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxofl0uij31x8082djv.jpg" alt="image-20190825150103386"></p><ol start="10"><li>explain select * from test03 where c1=’a1’ and c2=’a2’ and c5=’a5’ order by c2,c3;<br>索引 c1c2 使用，但是 c2、c3 用于排序，无 filesort</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxp640boj322m084dk3.jpg" alt="image-20190825150145899"></p><p>explain select * from test03 where c1=’a1’ and c2=’a2’ and c5=’a5’ order by c3,c2;<br>本例有常量 c2 的情况，和 8.2 对比，无filesort</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxpei5n1j322w08242p.jpg" alt="image-20190825150159806"></p><ol start="11"><li>explain select * from test03 where c1=’a1’ and c4=’a4’ order by c2,c3;<br>索引 c1 使用</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxpmqucmj31uc084788.jpg" alt="image-20190825150212205"></p><ol start="12"><li>explain select * from test03 where c1=’a1’ and c4=’a4’ order by c3,c2;<br>索引 c1 使用, 出现了 Using where; Using temporary; Using filesort </li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bxpz58v2j321a07ygpp.jpg" alt="image-20190825150232699"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引优化&quot;&gt;&lt;a href=&quot;#索引优化&quot; class=&quot;headerlink&quot; title=&quot;索引优化&quot;&gt;&lt;/a&gt;索引优化&lt;/h2&gt;&lt;h3 id=&quot;索引失效案例&quot;&gt;&lt;a href=&quot;#索引失效案例&quot; class=&quot;headerlink&quot; title=&quot;索引失效案
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL 的各种 JOIN 用法</title>
    <link href="https://yapengren.github.io/wiki/SQL-%E7%9A%84%E5%90%84%E7%A7%8D-JOIN-%E7%94%A8%E6%B3%95/"/>
    <id>https://yapengren.github.io/wiki/SQL-的各种-JOIN-用法/</id>
    <published>2019-08-24T07:41:20.000Z</published>
    <updated>2019-09-03T10:31:33.133Z</updated>
    
    <content type="html"><![CDATA[<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8ss22yj30qu0l4q5w.jpg" alt="SQL JOINS"></p><h3 id="Inner-JOIN"><a href="#Inner-JOIN" class="headerlink" title="Inner JOIN"></a>Inner JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8r7xc7j307604umx4.jpg" alt="inner join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt; </span><br><span class="line">FROM Table_A A</span><br><span class="line">INNER JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Left-JOIN"><a href="#Left-JOIN" class="headerlink" title="Left JOIN"></a>Left JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8t2omcj307604ugll.jpg" alt="left join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Right-JOIN"><a href="#Right-JOIN" class="headerlink" title="Right JOIN"></a>Right JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8s6ylkj307604ugll.jpg" alt="right join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Left-Excluding-JOIN"><a href="#Left-Excluding-JOIN" class="headerlink" title="Left Excluding JOIN"></a>Left Excluding JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8qxu6hj307604u3yh.jpg" alt="left excluding join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt; </span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE B.Key IS NULL</span><br></pre></td></tr></table></figure><h3 id="Right-Excluding-JOIN"><a href="#Right-Excluding-JOIN" class="headerlink" title="Right Excluding JOIN"></a>Right Excluding JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8roxm7j307604u0sp.jpg" alt="right excluding join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL</span><br></pre></td></tr></table></figure><h3 id="Outer-JOIN"><a href="#Outer-JOIN" class="headerlink" title="Outer JOIN"></a>Outer JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8u43nrj307604u3yi.jpg" alt="outer join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># oracle</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">FULL OUTER JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line"></span><br><span class="line"># MySQL</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br></pre></td></tr></table></figure><h3 id="Outer-Excluding-JOIN"><a href="#Outer-Excluding-JOIN" class="headerlink" title="Outer Excluding JOIN"></a>Outer Excluding JOIN</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8tobxfj307604udfu.jpg" alt="outer excluding join"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># oracle</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">FULL OUTER JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL OR B.Key IS NULL</span><br><span class="line"></span><br><span class="line"># mysql</span><br><span class="line">SELECT &lt;select_list&gt; </span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE B.Key IS NULL</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt;</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL</span><br></pre></td></tr></table></figure><blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>  <a href="https://www.runoob.com/w3cnote/sql-join-image-explain.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/sql-join-image-explain.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g6at8ss22yj30qu0l4q
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL 执行顺序</title>
    <link href="https://yapengren.github.io/wiki/SQL-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://yapengren.github.io/wiki/SQL-执行顺序/</id>
    <published>2019-08-24T03:38:17.000Z</published>
    <updated>2019-09-03T10:32:02.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6amco99e5j32640jwagv.jpg" alt="SQL执行顺序"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL-执行顺序&quot;&gt;&lt;a href=&quot;#SQL-执行顺序&quot; class=&quot;headerlink&quot; title=&quot;SQL 执行顺序&quot;&gt;&lt;/a&gt;SQL 执行顺序&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8m
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB 那些事</title>
    <link href="https://yapengren.github.io/wiki/MySQL-InnoDB-%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://yapengren.github.io/wiki/MySQL-InnoDB-那些事/</id>
    <published>2019-08-24T01:48:26.000Z</published>
    <updated>2019-08-25T01:31:01.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-InnoDB-聚簇索引和非聚簇索引"><a href="#MySQL-InnoDB-聚簇索引和非聚簇索引" class="headerlink" title="MySQL InnoDB 聚簇索引和非聚簇索引"></a>MySQL InnoDB 聚簇索引和非聚簇索引</h1><p>每个 InnoDB 表都有一个称为 「 聚簇索引 」 的特殊索引，通常情况下，这个聚簇索引就是 「 主键 」 ( primary key ) 。Innodb 使用它存储表中每一行的数据。</p><p>如果想要从查询、插入和其它数据库操作中获得最佳性能，那么我们就必须了解 InnoDB 如何使用 「 聚簇索引 」 来优化每个表的最常见检索和 DML 操作方式</p><ul><li><p>当我们在一个 Innodb 表上定义了一个主键，InnoDB 会默认的使用它作为聚簇索引。</p><p>使用 InnoDB 存储引擎时，建议为每个表都添加一个主键。如果该表没有一个逻辑唯一且非空列或列集合，那么可以添加一个带有 AUTO_INCREMENT 约束的自增列作为主键，InnoDB 会自动填充该列。</p></li><li><p>如果某个 InnoDB 表并没有定义主键。那么 InnoDB 会查找第一个 「 唯一索引 」( UNIQUE Index ) ，因为唯一索引的所有键 ( key ) 都是 <code>NOT</code> ，因此可以用来作为聚簇索引。</p></li><li><p>如果某个 InnoDB 表既没有定义主键，也没有一个合适的唯一索引。InnoDB 会在内部生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐式的聚簇索引</p><p>该聚簇索引的键 ( key ) 会包含一个自动为行生成的 ID 值 ( 行号 ) 。</p><p>该表中的所有行会按 InnoDB 分配给此类表中的行的 ID 排序。</p><p>行 ID 是一个 <strong>6</strong> 字节的字段，在插入新行时会单调自增。</p><p>因此，可以认为物理上的行保存顺序就是该行 ID 排序的排序顺序</p></li></ul><h2 id="聚簇索引如何加快查询速度"><a href="#聚簇索引如何加快查询速度" class="headerlink" title="聚簇索引如何加快查询速度"></a>聚簇索引如何加快查询速度</h2><p>通过聚簇索引访问行很快，因为索引搜索直接指向包含所有行数据页 ( data page )。</p><p>如果表很大，与那种索引页与数据页分离的 MyISAM 存储引擎相比， 聚簇索引体系结构通常可以节省磁盘 I/O 操作。</p><h2 id="非聚簇索引和聚簇索引的关系"><a href="#非聚簇索引和聚簇索引的关系" class="headerlink" title="非聚簇索引和聚簇索引的关系"></a>非聚簇索引和聚簇索引的关系</h2><p>非聚簇索引，通常也称之为 「 二级索引 」 ( Secondary Indexes ) 或 「 辅助索引 」 ，一般是指聚簇索引之外的所有其它的索引。</p><p>在 InnoDB 中，每个辅助索引中的每条记录都会包含该行的主键列 ( 也就是聚簇索引的键 ) ，以及为辅助索引指定的列。InnoDB 使用此主键值来搜索聚簇索引中的行。</p><p>如果主键很长，那么辅助索引就会占用更多空间，因此使用短主键是有利的，也是我们所推荐的。</p><h2 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h2><ol><li><p>首先，我们要认识到聚簇索引和非聚簇索引的划分依据是什么？</p><p>答案就是 InnoDB 会使用聚簇索引来保存数据，而非聚簇索引的目的仅仅是加快查询速度</p></li><li><p>在第一点认知基础上，我们就可以知道</p><ul><li>聚簇索引是唯一的，一个 InnoDB 表只有一个聚簇索引，而且一定会有一个聚簇索引，如果不存在，Innodb 存储引擎会自动添加一个</li><li>非聚簇所以可以有多个，而且只能由用户自己添加，InnoDB 默认并不会创建任何非聚簇索引。</li></ul></li><li><p>非聚簇索引中一定包含了聚簇索引的列值，但反过来却不存在。</p><p>因此，使用非聚簇索引查询数据一定会用到聚簇索引，但反过来却不存在。</p></li></ol><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="http://cmsblogs.com/?p=5463" target="_blank" rel="noopener">http://cmsblogs.com/?p=5463</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-InnoDB-聚簇索引和非聚簇索引&quot;&gt;&lt;a href=&quot;#MySQL-InnoDB-聚簇索引和非聚簇索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL InnoDB 聚簇索引和非聚簇索引&quot;&gt;&lt;/a&gt;MySQL InnoDB 聚簇索引
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="数据库" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://yapengren.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis zset 实现简单限流</title>
    <link href="https://yapengren.github.io/wiki/Redis-zset-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%99%90%E6%B5%81/"/>
    <id>https://yapengren.github.io/wiki/Redis-zset-实现简单限流/</id>
    <published>2019-08-23T01:48:40.000Z</published>
    <updated>2019-09-03T10:32:54.475Z</updated>
    
    <content type="html"><![CDATA[<p>除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。</p><h1 id="如何使用-Redis-来实现简单限流策略？"><a href="#如何使用-Redis-来实现简单限流策略？" class="headerlink" title="如何使用 Redis 来实现简单限流策略？"></a>如何使用 Redis 来实现简单限流策略？</h1><p>首先我们来看一个常见的简单的限流策略。系统要限定用户的某个行为在指定的时间里只能允许发生 N 次，如何使用 Redis 的数据结构来实现这个限流的功能？</p><p>我们先定义这个接口，理解了这个接口的定义，读者就应该能明白我们期望达到的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定用户 user_id 的某个行为 action_key，在特定的时间内 period，只允许发生一定的次数 max_count</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActionAllowed</span><span class="params">(String userId, String actionKey, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个接口，5 分钟之内只能发帖 10 次</span></span><br><span class="line">limiter.isActionAllowed(<span class="string">"xiaoming"</span>, <span class="string">"publish"</span>, <span class="number">5</span> * <span class="number">60</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="错误方案"><a href="#错误方案" class="headerlink" title="错误方案"></a>错误方案</h2><blockquote><p>  将 userId 和 actionKey 拼成 key，在第一次请求时设置 value 为 1，设置过期时间 expire 为特定的时间 period</p><p>  每次请求的时候获取 value 值，若存在则 incr 自增 1，超过 maxCount 则做限制</p></blockquote><h3 id="问题模拟分析"><a href="#问题模拟分析" class="headerlink" title="问题模拟分析"></a>问题模拟分析</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g64rkjcypbj30ym0i80ti.jpg" alt="redis 问题模拟分析"></p><p>如上图：5 分钟之内只能发帖 10 次。</p><p>11:01 用户发帖 1 次，此时 redis 中存放数据 key 为 <code>userId:actionKey</code>，vlaue 为 1，过期时间 5 分钟；</p><p>11:05 用户发帖 8 次，发帖成功；</p><p>11:05 之后，key 过期时间到，被移除；</p><p>11:06 用户发帖，此时 redis 中 key 不存在，重新存放 key，发帖 8 次，发帖成功；</p><p>那么 11:05 -&gt; 11:06 时间段 2 分钟发帖 16 次，没有达到期望的功能；</p><h2 id="正确方案"><a href="#正确方案" class="headerlink" title="正确方案"></a>正确方案</h2><p>这个限流需求中存在一个滑动时间窗口，想想 zset 数据结构的 score 值，是不是可以通过 score 来圈出这个时间窗口来。而且我们只需要保留这个时间窗口，窗口之外的数据都可以砍掉。那这个 zset 的 value 填什么比较合适呢？它只需要保证唯一性即可，用 uuid 会比较浪费空间，那就改用毫秒时间戳吧。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g64rsbdgrgj30jr0cv3yj.jpg" alt="redis 滑动窗口"></p><p>如图所示，用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个 key 保存下来。同一个用户同一种行为用一个 zset 记录。</p><p>为节省内存，我们只需要保留时间窗口内的行为记录，同时如果用户是冷用户，滑动时间窗口内的行为是空记录，那么这个 zset 就可以从内存中移除，不再占用空间。</p><p>通过统计滑动窗口内的行为数量与阈值 max_count 进行比较就可以得出当前的行为是否允许。用代码表示如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRateLimiter</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId    用户 user_id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionKey 某个行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period    特定的时间内，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount  最大允许的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActionAllowed</span><span class="params">(String userId, String actionKey, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        String key = String.format(<span class="string">"hist:%s:%s"</span>, userId, actionKey);</span><br><span class="line">        <span class="comment">// 毫秒时间戳</span></span><br><span class="line">        <span class="keyword">long</span> nowTs = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用了multi，也就是事务，能保证一系列指令的原子顺序执行</span></span><br><span class="line">        pipe.multi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放数据，value 和 score 都使用毫秒时间戳</span></span><br><span class="line">        pipe.zadd(key, nowTs, <span class="string">""</span> + nowTs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zremrangebyscore key min max 命令用于移除有序集中，指定分数（score）区间内的所有成员</span></span><br><span class="line">        <span class="comment">// 移除时间窗口之前的数据，剩下的都是时间窗口之内的</span></span><br><span class="line">        Response&lt;Long&gt; longResponse = pipe.zremrangeByScore(key, <span class="number">0</span>, nowTs - period * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于 count()，获取时间窗口内的行为数量</span></span><br><span class="line">        Response&lt;Long&gt; count = pipe.zcard(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 zset 过期时间，避免冷用户持续占用内存</span></span><br><span class="line">        <span class="comment">// 过期时间应该等于时间窗口的长度，再多宽限 1s</span></span><br><span class="line">        pipe.expire(key, period + <span class="number">1</span>);</span><br><span class="line">        pipe.exec();</span><br><span class="line">        pipe.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较数量是否超标</span></span><br><span class="line">        <span class="keyword">return</span> count.get() &lt;= maxCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">        SimpleRateLimiter limiter = <span class="keyword">new</span> SimpleRateLimiter(jedis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(limiter.isActionAllowed(<span class="string">"xiaoming"</span>, <span class="string">"publish"</span>, <span class="number">5</span> * <span class="number">60</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>因为它要记录时间窗口内所有的行为记录，如果这个量很大，比如限定 60s 内操作不得超过 100w 次这样的参数，它是不适合做这样的限流的，因为会消耗大量的存储空间。</p><blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  《Redis 深度历险：核心原理与应用实践》   作者：钱文品</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。&lt;/p&gt;
&lt;h1 id=&quot;如何使
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="redis" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>java死锁编程及定位分析</title>
    <link href="https://yapengren.github.io/wiki/java%E6%AD%BB%E9%94%81%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/"/>
    <id>https://yapengren.github.io/wiki/java死锁编程及定位分析/</id>
    <published>2019-08-21T09:37:44.000Z</published>
    <updated>2019-08-21T09:40:26.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁编程及定位分析"><a href="#死锁编程及定位分析" class="headerlink" title="死锁编程及定位分析"></a>死锁编程及定位分析</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>死锁是指两个或者两个以上的进程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉它们将都无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性也就很低，否则就会因争夺有限的资源而陷入死锁。</p><h3 id="产生死锁的主要原因"><a href="#产生死锁的主要原因" class="headerlink" title="产生死锁的主要原因"></a>产生死锁的主要原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h3 id="代码：DeadLockDemo"><a href="#代码：DeadLockDemo" class="headerlink" title="代码：DeadLockDemo"></a>代码：DeadLockDemo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA, lockB), <span class="string">"ThreadAAA"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB, lockA), <span class="string">"ThreadBBB"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  自己持有：  "</span> + lockA + <span class="string">"  尝试获得：  "</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"  自己持有：  "</span> + lockB + <span class="string">"  尝试获得：  "</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li>jps 命令定位进程号</li><li>jstack 找到死锁查看</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;死锁编程及定位分析&quot;&gt;&lt;a href=&quot;#死锁编程及定位分析&quot; class=&quot;headerlink&quot; title=&quot;死锁编程及定位分析&quot;&gt;&lt;/a&gt;死锁编程及定位分析&lt;/h2&gt;&lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解？</title>
    <link href="https://yapengren.github.io/wiki/java-%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%80%92%E5%BD%92%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/"/>
    <id>https://yapengren.github.io/wiki/java-公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解？/</id>
    <published>2019-08-20T06:29:56.000Z</published>
    <updated>2019-08-20T06:41:21.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</p><p>非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象。</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>公平锁/非公平锁：并发包中 ReentrantLock 的创建可以指定构造函数的 boolean 类型来得到公平锁或非公平锁，默认是非公平锁。</p><p>关于两者区别：</p><p>公平锁，就是很公平，在并发情况下，每个线程在获取锁时会查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己。</p><p>非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采取类似公平锁那种方式。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p><p>对于 Synchronized 而言，也是一种非公平锁。</p><h2 id="可重入锁（又名递归锁）"><a href="#可重入锁（又名递归锁）" class="headerlink" title="可重入锁（又名递归锁）"></a>可重入锁（又名递归锁）</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>可重入锁（也就是递归锁）：指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p><p>也就是说，线程可以进入任何一个它已经拥有的锁所有同步着的代码块。</p><h3 id="ReentrantLock-Synchronized-就是一个典型的可重入锁"><a href="#ReentrantLock-Synchronized-就是一个典型的可重入锁" class="headerlink" title="ReentrantLock/Synchronized 就是一个典型的可重入锁"></a>ReentrantLock/Synchronized 就是一个典型的可重入锁</h3><h3 id="可重入锁最大的作用是避免死锁"><a href="#可重入锁最大的作用是避免死锁" class="headerlink" title="可重入锁最大的作用是避免死锁"></a>可重入锁最大的作用是避免死锁</h3><h2 id="独占锁-共享锁"><a href="#独占锁-共享锁" class="headerlink" title="独占锁/共享锁"></a>独占锁/共享锁</h2><p>独占锁：指该锁一次只能被一个线程所持有。对 ReentrantLock 和 Synchronized 而言都是独占锁。</p><p>共享锁：指该锁可被多个线程所持有。</p><p>对 ReentrantReadWriteLock，其读锁是共享锁，其写锁是独占锁。读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁：是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下切换的消耗，缺点是循环会消耗CPU。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁和非公平锁&quot;&gt;&lt;/a&gt;公平锁和非公平锁&lt;/h2&gt;&lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList 知识点</title>
    <link href="https://yapengren.github.io/wiki/CopyOnWriteArrayList-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yapengren.github.io/wiki/CopyOnWriteArrayList-知识点/</id>
    <published>2019-08-20T06:19:07.000Z</published>
    <updated>2019-08-25T01:55:55.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>CopyOnWrite 容器即写时复制的容器。<br>往一个容器添加元素的时候，不直接往当前容器 Object[] 添加，而是先将当前 object[] 进行 Copy，复制出一个新的容器 Object[] newElements，<br>然后新的容器 Object[] newElements 里添加元素，<br>添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements)<br>这样做的好处是可以对 copyonwrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>所以 copyonwrite容器也是一种读写分离的思想，读和写不同的容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写时复制&quot;&gt;&lt;a href=&quot;#写时复制&quot; class=&quot;headerlink&quot; title=&quot;写时复制&quot;&gt;&lt;/a&gt;写时复制&lt;/h2&gt;&lt;p&gt;CopyOnWrite 容器即写时复制的容器。&lt;br&gt;往一个容器添加元素的时候，不直接往当前容器 Object[] 添加，而
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java基础" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>原子类Atomiclnteger 的 ABA 问题谈谈？</title>
    <link href="https://yapengren.github.io/wiki/%E5%8E%9F%E5%AD%90%E7%B1%BBAtomiclnteger-%E7%9A%84-ABA-%E9%97%AE%E9%A2%98%E8%B0%88%E8%B0%88%EF%BC%9F/"/>
    <id>https://yapengren.github.io/wiki/原子类Atomiclnteger-的-ABA-问题谈谈？/</id>
    <published>2019-08-20T05:56:30.000Z</published>
    <updated>2019-08-20T06:17:01.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ABA问题怎么产生的"><a href="#ABA问题怎么产生的" class="headerlink" title="ABA问题怎么产生的"></a>ABA问题怎么产生的</h2><p>CAS会导致 ABA 问题</p><p>CAS 算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没问题的。</p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>解决ABA问题</p><h2 id="时间戳原子引用"><a href="#时间戳原子引用" class="headerlink" title="时间戳原子引用"></a>时间戳原子引用</h2><p>AtomicStampledReference<br>ABADemo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ABA问题怎么产生的&quot;&gt;&lt;a href=&quot;#ABA问题怎么产生的&quot; class=&quot;headerlink&quot; title=&quot;ABA问题怎么产生的&quot;&gt;&lt;/a&gt;ABA问题怎么产生的&lt;/h2&gt;&lt;p&gt;CAS会导致 ABA 问题&lt;/p&gt;
&lt;p&gt;CAS 算法实现一个重要前提需要取
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CAS 你知道吗？</title>
    <link href="https://yapengren.github.io/wiki/CAS-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/"/>
    <id>https://yapengren.github.io/wiki/CAS-你知道吗？/</id>
    <published>2019-08-20T05:49:03.000Z</published>
    <updated>2019-08-20T06:12:43.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h2><h2 id="CAS底层原理？如果知道，谈谈比对Unsafe的理解"><a href="#CAS底层原理？如果知道，谈谈比对Unsafe的理解" class="headerlink" title="CAS底层原理？如果知道，谈谈比对Unsafe的理解"></a>CAS底层原理？如果知道，谈谈比对Unsafe的理解</h2><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ol><li><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因为 Java 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p><p>注意 Unsafe 类中的所有方法都是 native 修饰的，也就是说 Unsafe 类中的方法都直接调用操作系统底层资源执行相应任务。</p></li><li><p>变量 valueOffset，表示该变量在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的。</p></li><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。</p></li></ol><h3 id="CAS-是什么"><a href="#CAS-是什么" class="headerlink" title="CAS 是什么"></a>CAS 是什么</h3><ol><li><p>unsafe.getAndAddInt</p><p>假设线程 A 和线程 B 两个线程同时执行 getAndAddInt 操作（分别跑在不同 CPU 上）</p><p>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 JMM 模型，线程 A 和线程 B 各自持有一份值为 3 的 value 的副本分别到各自的工作内存。</p><p>线程 A 通过 getIntVolatile（var1，var2）拿到 value 值 3，这是线程 A 被挂起。</p><p>线程 B 也通过 getIntVolatile（var1，var2）方法获得 value 值 3，此时刚好线程 B 没有被挂起并执行 compareAndSwap 方法比较内存值也为 3，成功修改内存值为 4，线程 B 打完收工，一切OK。</p><p>这是线程 A 回复，执行 compareAndSwapInt 方法比较，发现手里的值 3 与内存值 4 不一致，说明该值已经被其他线程抢险异步修改过了，那 A 线程本次修改失败，只能重新读取重新来一遍了。</p><p>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其他线程对它的修改，线程 A 总是能够看到，线程 A 继续执行 compareAndSwapInt 进行比较替换，直到成功。</p></li><li><p>底层汇编</p></li><li><p>简单版小总结<br>CAS（CompareAndSwap）<br>比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较知道主内存和工作内存中的值一致为止。</p></li></ol><p>CAS应用<br>CAS有 3 个操作数，内存值 V，旧的预期值 A，要修改的更新值 B。<br>当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p><h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><ol><li><p>循环时间长开销大<br>如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p></li><li><p>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们只能使用循环 CAS 的方式来保证原子操作，但是，对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p></li><li><p>引出来 ABA 问题？？？<br>通过原子引用解决 ABA 问题</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比较并交换&quot;&gt;&lt;a href=&quot;#比较并交换&quot; class=&quot;headerlink&quot; title=&quot;比较并交换&quot;&gt;&lt;/a&gt;比较并交换&lt;/h2&gt;&lt;h2 id=&quot;CAS底层原理？如果知道，谈谈比对Unsafe的理解&quot;&gt;&lt;a href=&quot;#CAS底层原理？如果知道，谈谈
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>谈谈你对 volatile 的理解</title>
    <link href="https://yapengren.github.io/wiki/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-volatile-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://yapengren.github.io/wiki/谈谈你对-volatile-的理解/</id>
    <published>2019-08-19T09:23:18.000Z</published>
    <updated>2019-08-19T09:33:51.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈你对-volatile-的理解"><a href="#谈谈你对-volatile-的理解" class="headerlink" title="谈谈你对 volatile 的理解"></a>谈谈你对 volatile 的理解</h2><p>volatile 是 Java 虚拟机提供的轻量级的同步机制</p><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回主内存中的。</p><p>这就可能存在一个线程 A 修改了共享变量 X 的值但还未写回主内存时，另一个线程 B 又对准内存中同一个共享变量 X 进行操作，但此时 A 线程工作内存中共享变量 X 对线程 B 来说并不是可见，这种工作内存与主内存同步存在延迟现象就造成了可见性问题。</p><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p>volatile 实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。</p><p>先了解一个概念，内存屏障又称内存栅栏，是一个CPU指令，它的作用有两个：<br>一是保证特定操作的执行顺序<br>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</p><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条 Memory Barrier 则告诉编译器和 CPU，不管什么指令都不能和这条 Memory Barrier 指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><h2 id="你在哪些地方用过volatile？"><a href="#你在哪些地方用过volatile？" class="headerlink" title="你在哪些地方用过volatile？"></a>你在哪些地方用过volatile？</h2><p>单例模式 DCL 代码<br>单例模式 volatile 分析</p><p>DCL（双端检锁）机制不一定线程安全，原因是有指令重排序的存在，加入 volatile 可以禁止指令重排。<br>原因在于某一个线程执行到第一个检测，读取到的 instance 不为 null 时，instance 的引用对象可能没有完成初始化。<br>指令重排只会保证串行语义的执行一致性（单线程），但并不会关心多线程间的语义一致性。<br>所以当一条线程访问 instance 不为 null 时，由于 instance 实例未必已初始化完成，也就造成了线程安全问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;谈谈你对-volatile-的理解&quot;&gt;&lt;a href=&quot;#谈谈你对-volatile-的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对 volatile 的理解&quot;&gt;&lt;/a&gt;谈谈你对 volatile 的理解&lt;/h2&gt;&lt;p&gt;volatile 是
      
    
    </summary>
    
      <category term="技术分享" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
      <category term="java并发" scheme="https://yapengren.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://yapengren.github.io/tags/java/"/>
    
  </entry>
  
</feed>

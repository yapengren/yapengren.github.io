{"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","path":"404.html","text":""},{"title":"分类","date":"2019-08-02T09:14:30.199Z","path":"categories/index.html","text":""},{"title":"关于","date":"2019-08-02T04:59:38.736Z","path":"about/index.html","text":""},{"title":"标签","date":"2019-08-02T05:00:35.984Z","path":"tags/index.html","text":""}],"posts":[{"title":"Java 基础知识点","date":"2019-08-03T10:01:30.000Z","path":"wiki/Java-基础知识点/","text":"List 和 Set 的区别HashSet 是如何保证不重复的HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）HashMap 的扩容过程HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？final finally finalize强引用 、软引用、 弱引用、虚引用Java反射Arrays.sort 实现原理和 Collection 实现原理LinkedHashMap的应用cloneable接口实现原理异常分类以及处理机制wait和sleep的区别数组在内存中如何分配","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"java基础","slug":"技术开发/java基础","permalink":"http://yoursite.com/categories/技术开发/java基础/"}]},{"title":"Mysql 知识点","date":"2019-08-03T09:36:37.000Z","path":"wiki/Mysql-知识点/","text":"数据库mysql 索引类型sql 优化的几种方式数据库事务数据库事务的 4 种隔离级别数据库事务的 4 个基本特性SQLMysql中FIND_IN_SET()和IN区别简析MySQL Explain详解MySQL中concat以及group_concat的使用MySQL中order by语句对null字段的排序SQL练习MySQL经典练习题及答案，常用SQL语句练习50题","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"数据库","slug":"技术开发/数据库","permalink":"http://yoursite.com/categories/技术开发/数据库/"}]},{"title":"intellij idea 修改记录","date":"2019-08-02T10:13:00.000Z","path":"wiki/intellij-idea-修改记录/","text":"过滤文件 显示多 Tabs","tags":[{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"}],"categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"},{"name":"IDE","slug":"开发工具/IDE","permalink":"http://yoursite.com/categories/开发工具/IDE/"}]},{"title":"mac brew 服务","date":"2019-08-02T09:40:48.000Z","path":"wiki/mac-brew-服务/","text":"brew 常用命令brew 搜索软件brew search nginxbrew 安装软件brew install nginxbrew 卸载软件brew uninstall nginxbrew 升级sudo brew update查看安装信息sudo brew info nginx 查看已安装软件brew list brew 安装nginx安装sudo brew install nginx启动sudo brew services start nginx重启sudo brew services restart nginx停止sudo brew services stop nginx查看cat /usr/local/etc/nginx/nignx.conf brew redis启动redis-server /usr/local/etc/redis-6379.conf停止redis-cli -p 6379 shutdown brew 安装 activemq安装brew install activemq查看版本activemq —version启动activemq start地址http://localhost:8161 admin admin brew 安装 rabbitmq安装brew install rabbitmq启动brew services start rabbitmq地址http://localhost:15672 guest guest brew 安装 mongodb参考：https://blog.csdn.net/ligh_sqh/article/details/81112428 mongo启动 mongodb 客户端cd ~/software/adminmongonpm start客户端地址 http://localhost:1234 nacos 启动命令sh ～/software/nacos/bin/startup.sh -m standalone elasticsearch-head 安装和启动 -elasticsearch GUI客户端git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run starthttp://localhost:9100","tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}],"categories":[{"name":"系统方面","slug":"系统方面","permalink":"http://yoursite.com/categories/系统方面/"},{"name":"mac","slug":"系统方面/mac","permalink":"http://yoursite.com/categories/系统方面/mac/"}]},{"title":"token 防表单重复提交","date":"2019-08-02T03:16:10.000Z","path":"wiki/token-防表单重复提交/","text":"加载页面时候调用 initToken() 方法，生成 token 存入页面隐藏域中&lt;%--隐藏域-防止表单的重复提交--%&gt;&lt;input type=\"hidden\" name=\"examToken\" id=\"examToken\"&gt;&lt;/input&gt; 表单提交的时候带上 tokenspringMVC 方法上添加注解 @TokenCheck(isCheckToken = true)自定义注解 TokenCheck.java// 注解会在class字节码文件中存在，在运行时可以通过反射获取到@Retention(RetentionPolicy.RUNTIME) // 定义注解的作用目标**作用范围字段、枚举的常量/方法@Target(&#123;ElementType.METHOD&#125;)// 说明该注解将被包含在javadoc中@Documentedpublic @interface TokenCheck &#123; /** * 是否需要校验 */ boolean isCheckToken() default false;&#125; springMVC 配置文件 spring-servlet.xml 添加 &lt;mvc:interceptors 拦截器&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.ycx.exam.web.comm.interceptor.TokenCheckDuplicateSubmitInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; TokenCheckDuplicateSubmitInterceptor.java 在拦截器中判断TokenCheck注解isCheckToken是否为 true，如果为 true，则执行缓存校验； 先从 redis 缓存中获取到 token 集合，再从缓存中查询 token； 如果存在，则属于重复提交，返回； 如果不存在，则属于首次提交，将此token压入token集合中并将token集合放回redis中； public class TokenCheckDuplicateSubmitInterceptor extends HandlerInterceptorAdapter &#123; private static final Logger log = Logger.getLogger(TokenCheckDuplicateSubmitInterceptor.class); @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; WebApplicationContext context = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext()); CacheService cacheService = (CacheService) context.getBean(\"cacheService\"); if (cacheService == null) &#123; log.warn(\"token拦截器校验重复提交，缓存service为空!\"); return true; &#125; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); TokenCheck annotation = method.getAnnotation(TokenCheck.class); if (annotation != null) &#123; boolean isCheckToken = annotation.isCheckToken(); if (isCheckToken) &#123; boolean isExist = true; boolean isgetLock = getLock(cacheService, \"examTokenLock\", 1); if (isgetLock) &#123; isExist = checkTokenExist(request, cacheService); if (!isExist) &#123; log.warn(\"token拦截重复提交校验\" + method.getName() + \"重复提交!\"); &#125; &#125; cacheService.releaseLock(\"examTokenLock\"); return isExist; &#125; &#125; &#125; else &#123; try &#123; return super.preHandle(request, response, handler); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; /** * @param cacheService * @param cacheKey * @param second 秒 * @return */ private boolean getLock(CacheService cacheService, String cacheKey, long second) &#123; boolean isgetLock = cacheService.getLock(cacheKey, \"1\", second); //如果没有获得锁，将默认进行三次锁的获取 if (!isgetLock) &#123; log.info(\"获得分布式锁失败，进入等待...........\"); for (int i = 0; i &lt;= 2; i++) &#123; isgetLock = cacheService.getLock(cacheKey, \"1\", second); try &#123; if (!isgetLock) &#123; Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (isgetLock) &#123; break; &#125; &#125; &#125; return isgetLock; &#125; /** * 缓存校验 * * @param request * @param cacheService * @return */ private boolean checkTokenExist(HttpServletRequest request, CacheService cacheService) &#123; String token = request.getParameter(\"examToken\"); if (StringUtils.isEmpty(token)) &#123; log.warn(\"token拦截器校验重复提交，页面提交过来token为空!\"); return true; &#125; token = token.trim(); LRULinkedHashMap&lt;String, String&gt; cmap = (LRULinkedHashMap&lt;String, String&gt;) cacheService.getCacheData(\"examTokenMap\"); if (cmap == null) &#123; int size = 131072; // 最近最少使用算法，linkedHashMap实现，主要是针对缓存过期策略实现 cmap = new LRULinkedHashMap&lt;String, String&gt;(size); &#125; else &#123; log.info(\"token缓存map存在，size=\" + cmap.size()); &#125; String ieExist = cmap.get(token); if (StringUtils.isEmpty(ieExist)) &#123; log.info(\"缓存不存在token=\" + token); String valu = cmap.put(token, \"1\"); cacheService.setCacheDataForType(\"examTokenMap\", cmap, 1, TimeUnit.HOURS); log.info(\"将token=\" + token + \"加入缓存成功!\"); return true; &#125; else &#123; log.info(\"将token=\" + token + \"已经存在，重复提交!\"); return false; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"解决方案","slug":"技术开发/解决方案","permalink":"http://yoursite.com/categories/技术开发/解决方案/"}]}]}
{"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","path":"404.html","text":""},{"title":"分类","date":"2019-08-02T09:14:30.199Z","path":"categories/index.html","text":""},{"title":"关于","date":"2019-08-04T05:28:20.200Z","path":"about/index.html","text":"Email : yp_ren@126.com"},{"title":"标签","date":"2019-08-02T05:00:35.984Z","path":"tags/index.html","text":""}],"posts":[{"title":"HashMap 源码分析","date":"2019-08-17T05:45:12.000Z","path":"wiki/HashMap-源码分析/","text":"继承体系 在 Java 中，HashMap 的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。 在添加元素时，会根据 hash 值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。 当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。 数组的查询效率为 O(1)，链表的查询效率是 O(k)，红黑树的查询效率是 O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。 源码分析属性/** * 默认初始容量为 16 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;/** * 最大容量为 2 的 30 次方 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认装载因子 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 当一个桶中的元素 ≥ 8 时进行树化 */static final int TREEIFY_THRESHOLD = 8;/** * 当一个桶中的元素 ≤ 6 时把树转换成链表 */static final int UNTREEIFY_THRESHOLD = 6;/** * 当桶的个数达到 64 的时候进行树化 */static final int MIN_TREEIFY_CAPACITY = 64;/** * 数组，又叫做桶 */transient Node&lt;K, V&gt;[] table;/** * 作为 enterSet() 的缓存 */transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;/** * 元素的数量 */transient int size;/** * 修改次数，用于在迭代的时候执行快速失败策略 */transient int modCount;/** * 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor */int threshold;/** * 装载因子 */final float loadFactor; put(K key, V value) 方法public V put(K key, V value) &#123; // 调用 hash(key) 计算出 key 的 hash 值 return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; int h; // 如果 key 为 null，则 hash 值为0，否则调用 key 的 hashCode() 方法 // 并让高 16 位与整个 hash 异或，这样做是为了使计算出的 hash 更分散 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果桶的数量为 0，则初始化 if ((tab = table) == null || (n = tab.length) == 0) // 调用 resize() 初始化 n = (tab = resize()).length; // (n-1) &amp; hash 计算元素在哪个桶中 // 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 新建一个节点放在桶中 tab[i] = newNode(hash, key, value, null); else &#123; // 如果桶中已经有元素存在了 Node&lt;K,V&gt; e; K k; // 如果桶中第一个元素的 key 与待插入元素的 key 相同，保存到 e 中用于后续修改 value 值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 如果第一个元素是树节点，则调用树节点的 putTreeVal 插入元素 e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 遍历这个桶对应的链表，binCount 用于存储链表中元素的个数 for (int binCount = 0; ; ++binCount) &#123; // 如果链表遍历完了都没有找到相同 key 的元素，则 key 对应的元素不存在，则在链表最后插入一个新节点 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果插入新节点后链表长度 &gt; 8，则判断是否需要树化，因为第一个元素没有加到 binCount 中，所以 -1 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; // 如果待插入的 key 在链表中找到了，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 如果找到了对应 key 的元素 if (e != null) &#123; // existing mapping for key // 记录下旧值 V oldValue = e.value; // 判断是否需要替换旧值 if (!onlyIfAbsent || oldValue == null) // 替换旧值为新值 e.value = value; afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 到这里了说明没有找到元素 // 修改次数 +1 ++modCount; // 元素数量 +1，判断是否需要扩容 if (++size &gt; threshold) // 扩容 resize(); afterNodeInsertion(evict); // 没有找到元素返回 null return null;&#125; 计算 key 的 hash 值； 如果桶（数组）数量为 0，则初始化桶； 如果 key 所在的桶没有元素，则直接插入； 如果 key 所在的桶中的第一个元素的 key 与待插入的key相同，说明找到了元素，转后续流程（9）处理； 如果第一个元素是树节点，则调用树节点的 putTreeVal() 寻找元素或插入树节点； 如果不是以上三种情况，则遍历桶对应的链表查找 key 是否存在于链表中； 如果找到了对应 key 的元素，则转后续流程（9）处理； 如果没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化； 如果找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值； 如果插入了元素，则数量加 1 并判断是否需要扩容；","tags":[{"name":"java","slug":"java","permalink":"https://yapengren.github.io/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"java基础","slug":"技术开发/java基础","permalink":"https://yapengren.github.io/categories/技术开发/java基础/"}]},{"title":"ArrayList 源码分析","date":"2019-08-17T02:28:42.000Z","path":"wiki/ArrayList-源码分析/","text":"继承体系 源码分析属性/** * 默认容量为10，也就是通过 new ArrayList() 创建时的默认容量 */private static final int DEFAULT_CAPACITY = 10;/** * 空数组 * 这种是通过 new ArrayList(0) 创建时用的空数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 空数组 * 这种是通过 new ArrayList() 创建时用的空数组 * 与 EMPTY_ELEMENTDATA 的区别是在添加第一个元素时使用这个空数组会初始化为 DEFAULT_CAPACITY（10）个元素 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 真正存放元素的地方 * 使用 transient 关键字能不序列化这个字段 */transient Object[] elementData; // non-private to simplify nested class access/** * 真正存放元素的个数 */private int size; ArrayList(int initialCapacity) 构造方法public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 如果传入的初始容量 &gt; 0，新建一个数组存储元素 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 如果传入的初始容量 = 0，使用空数组 EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 如果传入的初始容量 &lt; 0，抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; add(E e) 方法添加元素到末尾 public boolean add(E e) &#123; // 检查是否需要扩容 ensureCapacityInternal(size + 1); // 将元素插入到最后一位 elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // 如果是空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小 10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) // 扩容 grow(minCapacity);&#125;/** * 扩容 * */private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // 新容量为旧容量的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新容量发现比需要的容量还小，则以需要的容量为准 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量已经超过最大容量了，则使用最大容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 以新容量拷贝出来一个新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 检查是否需要扩容； 如果 elementData 等于 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则初始化容量大小为 DEFAULT_CAPACITY； 新容量是老容量的1.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为； 创建新容量的数组并把老数组拷贝到新数组；","tags":[{"name":"java","slug":"java","permalink":"https://yapengren.github.io/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"java基础","slug":"技术开发/java基础","permalink":"https://yapengren.github.io/categories/技术开发/java基础/"}]},{"title":"Dubbo 知识点","date":"2019-08-15T08:54:12.000Z","path":"wiki/Dubbo-知识点/","text":"302","tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://yapengren.github.io/tags/dubbo/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"Dubbo","slug":"技术开发/Dubbo","permalink":"https://yapengren.github.io/categories/技术开发/Dubbo/"}]},{"title":"Mybatis 知识点","date":"2019-08-14T09:20:15.000Z","path":"wiki/Mybatis-知识点/","text":"MyBatis 中 resultType 和 resultMap 的区别","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://yapengren.github.io/tags/mybatis/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"Mybatis","slug":"技术开发/Mybatis","permalink":"https://yapengren.github.io/categories/技术开发/Mybatis/"}]},{"title":"synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说说","date":"2019-08-04T06:32:36.000Z","path":"wiki/synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说说/","text":"原始构成 synchronized 是关键字，属于JVM层面 monitorenter（底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象只有在同步块或者方法中才能调用 wait/notify 等方法） monitorexit Lock 是具体类（java.util.concurrent.locks.lock）是api层面的锁 使用方法 synchronized 不需要用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。 ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象。需要 lock() 和unlock() 方法配合 try/finally 语句块来完成。 等待是否可中断 synchronized 不可中断，除非抛出异常或者正常运行完成。 ReentrantLock可中断 1.设置超时方法 tryLock(long timeout,TimeUnit unit) 2.lockInterruptibly()放代码块中，调用interrupt()方法可中断 加锁是否公平 synchronized 非公平锁 ReentrantLock 两者都可以，默认非公平锁，构造方法可以传入 boolean 值，true为公平锁，false为非公平锁 锁绑定多个条件 Condition synchronized 没有 ReentrantLock 用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像 synchronized 要么随机唤醒一个要么唤醒全部线程。 举例：锁绑定多个条件 Condition/** * * 题目：多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下： * A打印5次，B打印10次，C打印15次 * 紧接着 * A打印5次，B打印10次，C打印15次 * 打印10轮 */public class SyncAndReentrantLockdemo &#123; public static void main(String[] args) &#123; ShareResource shareResource = new ShareResource(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; shareResource.print5(); &#125; &#125;, \"A\").start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; shareResource.print10(); &#125; &#125;, \"B\").start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; shareResource.print15(); &#125; &#125;, \"C\").start(); &#125;&#125;class ShareResource &#123; private int number = 1; private Lock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); public void print5() &#123; lock.lock(); try &#123; // 1判断 while (number != 1) &#123; c1.await(); &#125; // 2干活 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; // 3通知 number = 2; c2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void print10() &#123; lock.lock(); try &#123; // 1判断 while (number != 2) &#123; c2.await(); &#125; // 2干活 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; // 3通知 number = 3; c3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void print15() &#123; lock.lock(); try &#123; // 1判断 while (number != 3) &#123; c3.await(); &#125; // 2干活 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; // 3通知 number = 1; c1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;","tags":[{"name":"java并发","slug":"java并发","permalink":"https://yapengren.github.io/tags/java并发/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"java并发","slug":"技术开发/java并发","permalink":"https://yapengren.github.io/categories/技术开发/java并发/"}]},{"title":"java hash 原理","date":"2019-08-04T05:23:50.000Z","path":"wiki/java-hash-原理/","text":"","tags":[{"name":"java","slug":"java","permalink":"https://yapengren.github.io/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"java基础","slug":"技术开发/java基础","permalink":"https://yapengren.github.io/categories/技术开发/java基础/"}]},{"title":"让我们同步进阶","date":"2019-08-04T05:18:18.000Z","path":"wiki/让我们同步进阶/","text":"基础知识点Java技术驿站 CS-Notes JavaGuide 架构知识点互联网 java 工程师进阶知识完全扫盲 spring boot &amp; cloudSpring Cloud 程序猿DD","tags":[],"categories":[]},{"title":"redis 知识点","date":"2019-08-04T05:12:21.000Z","path":"wiki/redis-知识点/","text":"Redis用过哪些数据数据，以及Redis底层怎么实现string, hash, list, set, zset Redis缓存穿透，缓存雪崩如何使用Redis来实现分布式锁Redis的并发竞争问题如何解决Redis持久化的几种方式，优缺点是什么，怎么实现的aof 文件太大会怎么样Redis的缓存失效策略 &amp; 最大缓存策略Redis集群，高可用，原理Redis缓存分片Redis的数据淘汰策略","tags":[{"name":"redis","slug":"redis","permalink":"https://yapengren.github.io/tags/redis/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"redis","slug":"技术开发/redis","permalink":"https://yapengren.github.io/categories/技术开发/redis/"}]},{"title":"Spring 知识点","date":"2019-08-04T05:01:51.000Z","path":"wiki/Spring-知识点/","text":"BeanFactory 和 FactoryBean？Spring IOC 的理解，其初始化过程？BeanFactory 和 ApplicationContext？Spring Bean 的生命周期，如何被管理的？Spring Bean 的加载过程是怎样的？如果要你实现Spring AOP，请问怎么实现？如果要你实现Spring IOC，你会注意哪些问题？Spring 是如何管理事务的，事务管理机制？Spring 的不同事务传播行为有哪些，干什么用的？Spring 中用到了那些设计模式？Spring MVC 的工作原理？Spring 循环注入的原理？Spring AOP的理解，各个术语，他们是怎么相互工作的？Spring 如何保证 Controller 并发的安全？","tags":[{"name":"spring","slug":"spring","permalink":"https://yapengren.github.io/tags/spring/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"spring","slug":"技术开发/spring","permalink":"https://yapengren.github.io/categories/技术开发/spring/"}]},{"title":"FastDFS 流程图","date":"2019-08-04T03:34:10.000Z","path":"wiki/FastDFS-流程图/","text":"FastDFS 执行流程FastDFS 服务端有三个角色：跟踪服务器（Tracker Server）、存储服务器（Storage Server）和客户端（Client）。 Tracker Server：跟踪服务器，主要做调度工作，起负载均衡的作用。在内存记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽。相比 GFS 中的 Master 更为精简，不记录文件索引信息，占用的内存量很少。 Storage Server：存储服务器（又称存储节点或数据服务器），文件和文件属性（Meta Data）都保存到存储服务器上。Storage Server 直接利用 OS 的文件系统调用管理文件。 Client：客户端，作为业务请求的发起方，通过专有接口，使用 TCP/IP 协议与跟踪器服务器或存储节点进行数据交互。FastDFS 向使用者提供基本文件访问接口，如 upload、download、append、delete 等，以客户端库的方式提供给用户使用。 通过一张图来看一下 FastDFS 的运行机制： Tracker 相当于 FastDFS 的大脑，不论是上传还是下载都是通过 Tracker 来分配资源；客户端一般可以使用 Ngnix 等静态服务器来调用或者做一部分的缓存；存储服务器内部分为卷（或者叫做组），卷与卷之间是平行的关系，可以根据资源的使用情况随时增加，卷内服务器文件相互同步备份，以达到容灾的目的。 上传机制首先客户端请求 Tracker 服务获取到存储服务器的 IP 地址和端口，然后客户端根据返回的 IP 地址和端口号请求上传文件，存储服务器接收到请求后生产文件，并且将文件内容写入磁盘并返回给客户端 file_id、路径信息、文件名等信息，客户端保存相关信息上传完毕。 下载机制客户端带上文件名信息请求 Tracker 服务获取到存储服务器的 IP 地址和端口，然后客户端根据返回的 IP 地址和端口号请求下载文件，存储服务器接收到请求后返回文件给客户端。","tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"https://yapengren.github.io/tags/FastDFS/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"文件存储","slug":"技术开发/文件存储","permalink":"https://yapengren.github.io/categories/技术开发/文件存储/"}]},{"title":"springMVC 流程图","date":"2019-08-04T03:30:24.000Z","path":"wiki/springMVC-流程图/","text":"springMVC执行流程 用户发送请求至前端控制器 DispatcherServlet 前端控制器 DispatcherServlet 收到请求调用处理器映射器HandlerMapping。 处理器映射器 HandlerMapping 根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器一并返回给前端控制器DispatcherServlet。 前端控制器 DispatcherServlet 通过处理器适配器 HandlerAdapter 调用处理器 执行处理器，执行业务逻辑(Controller，也叫后端控制器)。 Controller 执行完成返回 ModelAndView 处理器适配器 HandlerAdapter 将 controller 执行结果 ModelAndView 返回给前端控制器 DispatcherServlet 前端控制器 DispatcherServlet 将 ModelAndView 传给视图解析器 ViewResolver 视图解析器 ViewResolver 解析后返回具体 View DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet 响应用户","tags":[{"name":"spring","slug":"spring","permalink":"https://yapengren.github.io/tags/spring/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"spring","slug":"技术开发/spring","permalink":"https://yapengren.github.io/categories/技术开发/spring/"}]},{"title":"shiro 流程图","date":"2019-08-04T03:28:49.000Z","path":"wiki/shiro-流程图/","text":"","tags":[{"name":"shiro","slug":"shiro","permalink":"https://yapengren.github.io/tags/shiro/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"权限认证","slug":"技术开发/权限认证","permalink":"https://yapengren.github.io/categories/技术开发/权限认证/"}]},{"title":"Mybatis 架构图","date":"2019-08-04T03:21:42.000Z","path":"wiki/Mybatis-架构图/","text":"mybatis配置 SqlMapConfig.xml，此文件作为 mybatis 的全局配置文件，配置了 mybatis 的运行环境等信息。 mapper.xml 文件即sql映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 SqlMapConfig.xml 中加载。 通过 mybatis 环境等配置信息构造 SqlSessionFactory 即会话工厂 由会话工厂创建 sqlSession 即会话，操作数据库需要通过 sqlSession 进行。 mybatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。 Mapped Statement 也是 mybatis 一个底层封装对象，它包装了 mybatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 Mapped Statement 对象，sql 的 id 即是 Mapped statement 的id。 Mapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql前将输入的 java 对象映射至 sql 中，输入参数映射就是 jdbc 编程中对preparedStatement 设置参数。 Mapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql 后将输出结果映射至 java 对象中，输出结果映射过程相当于 jdbc 编程中对结果的解析处理过程。","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://yapengren.github.io/tags/mybatis/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"Mybatis","slug":"技术开发/Mybatis","permalink":"https://yapengren.github.io/categories/技术开发/Mybatis/"}]},{"title":"Dubbo 架构","date":"2019-08-04T03:15:00.000Z","path":"wiki/Dubbo-架构/","text":"节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 参考http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html","tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://yapengren.github.io/tags/dubbo/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"Dubbo","slug":"技术开发/Dubbo","permalink":"https://yapengren.github.io/categories/技术开发/Dubbo/"}]},{"title":"Java 基础知识点","date":"2019-08-03T10:01:30.000Z","path":"wiki/Java-基础知识点/","text":"List 和 Set 的区别HashSet 是如何保证不重复的HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）HashMap 的扩容过程HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？final finally finalize强引用 、软引用、 弱引用、虚引用Java反射Arrays.sort 实现原理和 Collection 实现原理LinkedHashMap的应用cloneable接口实现原理异常分类以及处理机制wait和sleep的区别数组在内存中如何分配","tags":[{"name":"java","slug":"java","permalink":"https://yapengren.github.io/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"java基础","slug":"技术开发/java基础","permalink":"https://yapengren.github.io/categories/技术开发/java基础/"}]},{"title":"Mysql 知识点","date":"2019-08-03T09:36:37.000Z","path":"wiki/Mysql-知识点/","text":"数据库mysql 索引类型sql 优化的几种方式数据库事务数据库事务的 4 种隔离级别数据库事务的 4 个基本特性SQLMysql中FIND_IN_SET()和IN区别简析MySQL Explain详解MySQL中concat以及group_concat的使用MySQL中order by语句对null字段的排序SQL练习MySQL经典练习题及答案，常用SQL语句练习50题","tags":[{"name":"mysql","slug":"mysql","permalink":"https://yapengren.github.io/tags/mysql/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"数据库","slug":"技术开发/数据库","permalink":"https://yapengren.github.io/categories/技术开发/数据库/"}]},{"title":"intellij idea 修改记录","date":"2019-08-02T10:13:00.000Z","path":"wiki/intellij-idea-修改记录/","text":"过滤文件 显示多 Tabs","tags":[{"name":"util","slug":"util","permalink":"https://yapengren.github.io/tags/util/"}],"categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yapengren.github.io/categories/开发工具/"},{"name":"IDE","slug":"开发工具/IDE","permalink":"https://yapengren.github.io/categories/开发工具/IDE/"}]},{"title":"mac brew 服务","date":"2019-08-02T09:40:48.000Z","path":"wiki/mac-brew-服务/","text":"brew 常用命令brew 搜索软件brew search nginxbrew 安装软件brew install nginxbrew 卸载软件brew uninstall nginxbrew 升级sudo brew update查看安装信息sudo brew info nginx 查看已安装软件brew list brew 安装nginx安装sudo brew install nginx启动sudo brew services start nginx重启sudo brew services restart nginx停止sudo brew services stop nginx查看cat /usr/local/etc/nginx/nignx.conf brew redis启动redis-server /usr/local/etc/redis-6379.conf停止redis-cli -p 6379 shutdown brew 安装 activemq安装brew install activemq查看版本activemq —version启动activemq start地址http://localhost:8161 admin admin brew 安装 rabbitmq安装brew install rabbitmq启动brew services start rabbitmq地址http://localhost:15672 guest guest brew 安装 mongodb参考：https://blog.csdn.net/ligh_sqh/article/details/81112428 mongo启动 mongodb 客户端cd ~/software/adminmongonpm start客户端地址 http://localhost:1234 nacos 启动命令sh ～/software/nacos/bin/startup.sh -m standalone elasticsearch-head 安装和启动 -elasticsearch GUI客户端git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run starthttp://localhost:9100","tags":[{"name":"mac","slug":"mac","permalink":"https://yapengren.github.io/tags/mac/"}],"categories":[{"name":"系统方面","slug":"系统方面","permalink":"https://yapengren.github.io/categories/系统方面/"},{"name":"mac","slug":"系统方面/mac","permalink":"https://yapengren.github.io/categories/系统方面/mac/"}]},{"title":"token 防表单重复提交","date":"2019-08-02T03:16:10.000Z","path":"wiki/token-防表单重复提交/","text":"生成 token加载页面时候调用 initToken() 方法，生成 token 存入页面隐藏域中 &lt;%--隐藏域-防止表单的重复提交--%&gt;&lt;input type=&quot;hidden&quot; name=&quot;examToken&quot; id=&quot;examToken&quot;&gt;&lt;/input&gt; 表单提交表单提交的时候带上 token 方法添加注解springMVC 方法上添加注解 @TokenCheck(isCheckToken = true) 自定义注解自定义注解 TokenCheck.java // 注解会在class字节码文件中存在，在运行时可以通过反射获取到@Retention(RetentionPolicy.RUNTIME) // 定义注解的作用目标**作用范围字段、枚举的常量/方法@Target(&#123;ElementType.METHOD&#125;)// 说明该注解将被包含在javadoc中@Documentedpublic @interface TokenCheck &#123; /** * 是否需要校验 */ boolean isCheckToken() default false;&#125; 自定义注解拦截器springMVC 配置文件 spring-servlet.xml 添加 &lt;mvc:interceptors 拦截器 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.ycx.exam.web.comm.interceptor.TokenCheckDuplicateSubmitInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器内容TokenCheckDuplicateSubmitInterceptor.java 在拦截器中判断TokenCheck注解isCheckToken是否为 true，如果为 true，则执行缓存校验； 先从 redis 缓存中获取到 token 集合，再从缓存中查询 token； 如果存在，则属于重复提交，返回； 如果不存在，则属于首次提交，将此token压入token集合中并将token集合放回redis中； public class TokenCheckDuplicateSubmitInterceptor extends HandlerInterceptorAdapter &#123; private static final Logger log = Logger.getLogger(TokenCheckDuplicateSubmitInterceptor.class); @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; WebApplicationContext context = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext()); CacheService cacheService = (CacheService) context.getBean(\"cacheService\"); if (cacheService == null) &#123; log.warn(\"token拦截器校验重复提交，缓存service为空!\"); return true; &#125; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); TokenCheck annotation = method.getAnnotation(TokenCheck.class); if (annotation != null) &#123; boolean isCheckToken = annotation.isCheckToken(); if (isCheckToken) &#123; boolean isExist = true; boolean isgetLock = getLock(cacheService, \"examTokenLock\", 1); if (isgetLock) &#123; isExist = checkTokenExist(request, cacheService); if (!isExist) &#123; log.warn(\"token拦截重复提交校验\" + method.getName() + \"重复提交!\"); &#125; &#125; cacheService.releaseLock(\"examTokenLock\"); return isExist; &#125; &#125; &#125; else &#123; try &#123; return super.preHandle(request, response, handler); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; /** * @param cacheService * @param cacheKey * @param second 秒 * @return */ private boolean getLock(CacheService cacheService, String cacheKey, long second) &#123; boolean isgetLock = cacheService.getLock(cacheKey, \"1\", second); //如果没有获得锁，将默认进行三次锁的获取 if (!isgetLock) &#123; log.info(\"获得分布式锁失败，进入等待...........\"); for (int i = 0; i &lt;= 2; i++) &#123; isgetLock = cacheService.getLock(cacheKey, \"1\", second); try &#123; if (!isgetLock) &#123; Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (isgetLock) &#123; break; &#125; &#125; &#125; return isgetLock; &#125; /** * 缓存校验 * * @param request * @param cacheService * @return */ private boolean checkTokenExist(HttpServletRequest request, CacheService cacheService) &#123; String token = request.getParameter(\"examToken\"); if (StringUtils.isEmpty(token)) &#123; log.warn(\"token拦截器校验重复提交，页面提交过来token为空!\"); return true; &#125; token = token.trim(); LRULinkedHashMap&lt;String, String&gt; cmap = (LRULinkedHashMap&lt;String, String&gt;) cacheService.getCacheData(\"examTokenMap\"); if (cmap == null) &#123; int size = 131072; // 最近最少使用算法，linkedHashMap实现，主要是针对缓存过期策略实现 cmap = new LRULinkedHashMap&lt;String, String&gt;(size); &#125; else &#123; log.info(\"token缓存map存在，size=\" + cmap.size()); &#125; String ieExist = cmap.get(token); if (StringUtils.isEmpty(ieExist)) &#123; log.info(\"缓存不存在token=\" + token); String valu = cmap.put(token, \"1\"); cacheService.setCacheDataForType(\"examTokenMap\", cmap, 1, TimeUnit.HOURS); log.info(\"将token=\" + token + \"加入缓存成功!\"); return true; &#125; else &#123; log.info(\"将token=\" + token + \"已经存在，重复提交!\"); return false; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"https://yapengren.github.io/tags/java/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://yapengren.github.io/categories/技术开发/"},{"name":"解决方案","slug":"技术开发/解决方案","permalink":"https://yapengren.github.io/categories/技术开发/解决方案/"}]}]}
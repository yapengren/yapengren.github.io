{"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","path":"404.html","text":""},{"title":"Categories","date":"2019-08-01T09:53:44.844Z","path":"categories/index.html","text":""},{"title":"About","date":"2019-08-01T09:53:44.844Z","path":"about/index.html","text":""},{"title":"Tags","date":"2019-08-01T09:53:44.846Z","path":"tags/index.html","text":""}],"posts":[{"title":"token 防表单重复提交","date":"2019-08-02T03:16:10.000Z","path":"wiki/token-防表单重复提交/","text":"1、加载页面时候调用 initToken() 方法，生成 token 存入页面隐藏域中 12&lt;%--隐藏域-防止表单的重复提交--%&gt;&lt;input type=&quot;hidden&quot; name=&quot;examToken&quot; id=&quot;examToken&quot;&gt;&lt;/input&gt; 2、表单提交的时候带上 token 3、springMVC 方法上添加注解 @TokenCheck(isCheckToken = true 4、自定义注解 TokenCheck.java 12345678910111213// 注解会在class字节码文件中存在，在运行时可以通过反射获取到@Retention(RetentionPolicy.RUNTIME) // 定义注解的作用目标**作用范围字段、枚举的常量/方法@Target(&#123;ElementType.METHOD&#125;)// 说明该注解将被包含在javadoc中@Documentedpublic @interface TokenCheck &#123; /** * 是否需要校验 */ boolean isCheckToken() default false;&#125; 5、springMVC 配置文件 spring-servlet.xml 添加 &lt;mvc:interceptors 拦截器 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.ycx.exam.web.comm.interceptor.TokenCheckDuplicateSubmitInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; TokenCheckDuplicateSubmitInterceptor.java 在拦截器中判断TokenCheck注解isCheckToken是否为 true，如果为 true，则执行缓存校验； 先从 redis 缓存中获取到 token 集合，再从缓存中查询 token； 如果存在，则属于重复提交，返回； 如果不存在，则属于首次提交，将此token压入token集合中并将token集合放回redis中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class TokenCheckDuplicateSubmitInterceptor extends HandlerInterceptorAdapter &#123; private static final Logger log = Logger.getLogger(TokenCheckDuplicateSubmitInterceptor.class); @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; WebApplicationContext context = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext()); CacheService cacheService = (CacheService) context.getBean(\"cacheService\"); if (cacheService == null) &#123; log.warn(\"token拦截器校验重复提交，缓存service为空!\"); return true; &#125; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); TokenCheck annotation = method.getAnnotation(TokenCheck.class); if (annotation != null) &#123; boolean isCheckToken = annotation.isCheckToken(); if (isCheckToken) &#123; boolean isExist = true; boolean isgetLock = getLock(cacheService, \"examTokenLock\", 1); if (isgetLock) &#123; isExist = checkTokenExist(request, cacheService); if (!isExist) &#123; log.warn(\"token拦截重复提交校验\" + method.getName() + \"重复提交!\"); &#125; &#125; cacheService.releaseLock(\"examTokenLock\"); return isExist; &#125; &#125; &#125; else &#123; try &#123; return super.preHandle(request, response, handler); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; /** * @param cacheService * @param cacheKey * @param second 秒 * @return */ private boolean getLock(CacheService cacheService, String cacheKey, long second) &#123; boolean isgetLock = cacheService.getLock(cacheKey, \"1\", second); //如果没有获得锁，将默认进行三次锁的获取 if (!isgetLock) &#123; log.info(\"获得分布式锁失败，进入等待...........\"); for (int i = 0; i &lt;= 2; i++) &#123; isgetLock = cacheService.getLock(cacheKey, \"1\", second); try &#123; if (!isgetLock) &#123; Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (isgetLock) &#123; break; &#125; &#125; &#125; return isgetLock; &#125; /** * 缓存校验 * * @param request * @param cacheService * @return */ private boolean checkTokenExist(HttpServletRequest request, CacheService cacheService) &#123; String token = request.getParameter(\"examToken\"); if (StringUtils.isEmpty(token)) &#123; log.warn(\"token拦截器校验重复提交，页面提交过来token为空!\"); return true; &#125; token = token.trim(); LRULinkedHashMap&lt;String, String&gt; cmap = (LRULinkedHashMap&lt;String, String&gt;) cacheService.getCacheData(\"examTokenMap\"); if (cmap == null) &#123; int size = 131072; // 最近最少使用算法，linkedHashMap实现，主要是针对缓存过期策略实现 cmap = new LRULinkedHashMap&lt;String, String&gt;(size); &#125; else &#123; log.info(\"token缓存map存在，size=\" + cmap.size()); &#125; String ieExist = cmap.get(token); if (StringUtils.isEmpty(ieExist)) &#123; log.info(\"缓存不存在token=\" + token); String valu = cmap.put(token, \"1\"); cacheService.setCacheDataForType(\"examTokenMap\", cmap, 1, TimeUnit.HOURS); log.info(\"将token=\" + token + \"加入缓存成功!\"); return true; &#125; else &#123; log.info(\"将token=\" + token + \"已经存在，重复提交!\"); return false; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"categories":[{"name":"知识点","slug":"知识点","permalink":"http://yoursite.com/categories/知识点/"},{"name":"解决方案","slug":"知识点/解决方案","permalink":"http://yoursite.com/categories/知识点/解决方案/"}]},{"title":"Hello World","date":"2019-08-01T09:52:13.459Z","path":"wiki/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}]}